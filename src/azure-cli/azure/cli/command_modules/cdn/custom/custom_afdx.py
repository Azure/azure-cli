# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# --------------------------------------------------------------------------------------------

from typing import (Optional, List)
from azure.mgmt.cdn.models import (AFDEndpoint, HealthProbeRequestType, EnabledState, Route, LinkToDefaultDomain,
                                   ResourceReference, AFDEndpointProtocols, HttpsRedirect, ForwardingProtocol,
                                   AfdQueryStringCachingBehavior, HealthProbeParameters, MatchProcessingBehavior,
                                   AFDOrigin, AFDOriginGroup, SharedPrivateLinkResourceProperties, CompressionSettings,
                                   LoadBalancingSettingsParameters, SecurityPolicyWebApplicationFirewallParameters,
                                   SecurityPolicyWebApplicationFirewallAssociation, CustomerCertificateParameters,
                                   AFDDomain, AFDDomainHttpsParameters, AfdCertificateType, AfdMinimumTlsVersion,
                                   AFDEndpointUpdateParameters, SkuName, AfdPurgeParameters, ActivatedResourceReference,
                                   SecurityPolicy, ProfileUpdateParameters, AfdRouteCacheConfiguration,
                                   AutoGeneratedDomainNameLabelScope, Secret)

from azure.mgmt.cdn.operations import (AFDOriginGroupsOperations, AFDOriginsOperations, AFDProfilesOperations,
                                       SecretsOperations, AFDEndpointsOperations, RoutesOperations, RuleSetsOperations,
                                       RulesOperations, SecurityPoliciesOperations, AFDCustomDomainsOperations,
                                       ProfilesOperations)

from azure.cli.core.commands.client_factory import get_subscription_id
from azure.cli.core.util import (sdk_no_wait)
from azure.cli.core.azclierror import (InvalidArgumentValueError)
from azure.core.exceptions import (ResourceNotFoundError)

from knack.log import get_logger
from msrest.polling import LROPoller, NoPolling

from .custom import _update_mapper
from azure.cli.core.aaz._base import has_value

logger = get_logger(__name__)


def default_content_types():
    return ["application/eot",
            "application/font",
            "application/font-sfnt",
            "application/javascript",
            "application/json",
            "application/opentype",
            "application/otf",
            "application/pkcs7-mime",
            "application/truetype",
            "application/ttf",
            "application/vnd.ms-fontobject",
            "application/xhtml+xml",
            "application/xml",
            "application/xml+rss",
            "application/x-font-opentype",
            "application/x-font-truetype",
            "application/x-font-ttf",
            "application/x-httpd-cgi",
            "application/x-javascript",
            "application/x-mpegurl",
            "application/x-opentype",
            "application/x-otf",
            "application/x-perl",
            "application/x-ttf",
            "font/eot",
            "font/ttf",
            "font/otf",
            "font/opentype",
            "image/svg+xml",
            "text/css",
            "text/csv",
            "text/html",
            "text/javascript",
            "text/js",
            "text/plain",
            "text/richtext",
            "text/tab-separated-values",
            "text/xml",
            "text/x-script",
            "text/x-component",
            "text/x-java-source"]

from azure.cli.command_modules.cdn.aaz.latest.afd.origin import Create as _AFDOriginCreate
class AFDOriginCreate(_AFDOriginCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZBoolArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.enable_private_link = AAZBoolArg(options=['--enable-private-link'],
                                                  help="Indicates whether private link is enanbled on that origin.",
                                                  required=True)
        return args_schema

    def pre_operations(self):
        args = self.ctx.args
        if args.enable_private_link is None:
            args.private_link_location = None
            args.private_link_resource = None
            args.private_link_request_message = None
            args.private_link_sub_resource_type = None

from azure.cli.command_modules.cdn.aaz.latest.afd.origin import Update as _AFDOriginUpdate
class AFDOriginUpdate(_AFDOriginUpdate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZBoolArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.enable_private_link = AAZBoolArg(options=['--enable-private-link'],
                                                  help="Indicates whether private link is enanbled on that origin.",
                                                  required=True)
        return args_schema

    def pre_operations(self):
        args = self.ctx.args
        if args.enable_private_link is None:
            args.private_link_location = None
            args.private_link_resource = None
            args.private_link_request_message = None
            args.private_link_sub_resource_type = None

from azure.cli.command_modules.cdn.aaz.latest.afd.route import Create as _AFDRouteCreate
class AFDRouteCreate(_AFDRouteCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZBoolArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.enable_caching = AAZBoolArg(options=['--enable-caching'],
                                                  help="Indicates whether caching is enanbled on that route.",
                                                  required=True)
        return args_schema

    def pre_operations(self):
        args = self.ctx.args
        if args.enable_caching is None:
            args.query_string_caching_behavior = None
            args.query_parameters = None

from azure.cli.command_modules.cdn.aaz.latest.afd.route import Update as _AFDRouteUpdate
class AFDRouteUpdate(_AFDRouteUpdate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZBoolArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.enable_caching = AAZBoolArg(options=['--enable-caching'],
                                                  help="Indicates whether caching is enanbled on that route.",
                                                  required=True)
        return args_schema

    def pre_operations(self):
        args = self.ctx.args
        if args.enable_caching is None:
            args.query_string_caching_behavior = None
            args.query_parameters = None

from azure.cli.command_modules.cdn.aaz.latest.afd.rule import Create as RuleCreate, Show as RuleShow

def create_afd_rule(cmd, resource_group_name, profile_name, rule_set_name,
                    order, rule_name, action_name, match_variable=None, operator=None,
                    match_values=None, selector=None, negate_condition=None, transforms=None,
                    cache_behavior=None, cache_duration=None, header_action=None,
                    header_name=None, header_value=None, query_parameters=None,
                    redirect_type=None, redirect_protocol=None, custom_hostname=None, custom_path=None,
                    custom_querystring=None, custom_fragment=None, source_pattern=None,
                    destination=None, preserve_unmatched_path=None, origin_group=None,
                    enable_caching=None, is_compression_enabled=None, query_string_caching_behavior=None,
                    match_processing_behavior: MatchProcessingBehavior = None,
                    forwarding_protocol: ForwardingProtocol = None):
    from azure.mgmt.cdn.models import Rule
    from .custom import create_condition
    from .custom import create_action

    conditions = []
    condition = create_condition(match_variable, operator, match_values, selector, negate_condition, transforms)
    if condition is not None:
        conditions.append(condition)

    actions = []
    action = create_action(action_name, cache_behavior, cache_duration, header_action, header_name,
                           header_value, None, None if query_parameters is None else ",".join(query_parameters),
                           redirect_type, redirect_protocol, custom_hostname, custom_path, custom_querystring,
                           custom_fragment, source_pattern, destination, preserve_unmatched_path,
                           origin_group=origin_group,
                           cmd=cmd,
                           enable_caching=enable_caching,
                           resource_group_name=resource_group_name,
                           profile_name=profile_name,
                           is_compression_enabled=is_compression_enabled,
                           query_string_caching_behavior=query_string_caching_behavior,
                           forwarding_protocol=forwarding_protocol)
    if action is not None:
        actions.append(action)

    rule = Rule(
        name=rule_name,
        order=order,
        conditions=conditions,
        actions=actions,
        match_processing_behavior=match_processing_behavior
    )

    return RuleCreate(resource_group_name,
                               profile_name,
                               rule_set_name,
                               rule_name,
                               rule=rule)

def add_afd_rule_condition(cmd, resource_group_name, profile_name, rule_set_name,
                           rule_name, match_variable, operator, match_values=None, selector=None,
                           negate_condition=None, transforms=None):
    existing_rule = RuleShow(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name
    })

    from .custom import create_condition

    condition = create_condition(match_variable, operator, match_values, selector, negate_condition, transforms)
    existing_rule["conditions"].append(condition)

    return RuleCreate(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name,
        "rule": existing_rule,
    })

def add_afd_rule_action(cmd, resource_group_name, profile_name, rule_set_name,
                        rule_name, action_name, cache_behavior=None, cache_duration=None,
                        header_action=None, header_name=None, header_value=None,
                        query_parameters=None, redirect_type=None, redirect_protocol=None, custom_hostname=None,
                        custom_path=None, custom_querystring=None, custom_fragment=None, source_pattern=None,
                        destination=None, preserve_unmatched_path=None, origin_group=None,
                        forwarding_protocol: ForwardingProtocol = None,
                        query_string_caching_behavior: AfdQueryStringCachingBehavior = None,
                        is_compression_enabled=None,
                        enable_caching=None):

    existing_rule = RuleShow(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name
    })

    from .custom import create_action
    action = create_action(action_name, cache_behavior, cache_duration, header_action, header_name,
                           header_value, None, None if query_parameters is None else ",".join(query_parameters),
                           redirect_type, redirect_protocol, custom_hostname, custom_path, custom_querystring,
                           custom_fragment, source_pattern, destination, preserve_unmatched_path,
                           cmd=cmd, resource_group_name=resource_group_name,
                           forwarding_protocol=forwarding_protocol,
                           origin_group=origin_group, profile_name=profile_name,
                           query_string_caching_behavior=query_string_caching_behavior,
                           is_compression_enabled=is_compression_enabled,
                           enable_caching=enable_caching)

    existing_rule["actions"].append(action)

    return RuleCreate(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name,
        "rule": existing_rule,
    })

def remove_afd_rule_condition(cmd, resource_group_name, profile_name,
                              rule_set_name, rule_name, index):

    existing_rule = RuleShow(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name
    })
    if len(existing_rule["conditions"]) > 1 and index < len(existing_rule["conditions"]):
        existing_rule["conditions"].pop(index)
    else:
        logger.warning("Invalid condition index found. This command will be skipped. Please check the rule.")

    return RuleCreate(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name,
        "rule": existing_rule,
    })


def remove_afd_rule_action(cmd, resource_group_name, profile_name, rule_set_name, rule_name, index):

    existing_rule = RuleShow(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name
    })
    if len(existing_rule["actions"]) > 1 and index < len(existing_rule["actions"]):
        existing_rule["actions"].pop(index)
    else:
        logger.warning("Invalid condition index found. This command will be skipped. Please check the rule.")

    return RuleCreate(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name,
        "rule": existing_rule,
    })


def list_afd_rule_condition(cmd, resource_group_name,
                            profile_name, rule_set_name,
                            rule_name):
    rule = RuleShow(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name
    })

    return rule["conditions"]


def list_afd_rule_action(cmd, resource_group_name,
                         profile_name, rule_set_name,
                         rule_name):
    rule = RuleShow(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name
    })
    
    return rule["actions"]

from azure.cli.command_modules.cdn.aaz.latest.afd.secret import Create as _AFDSecretCreate
class AFDSecretCreate(_AFDSecretCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZStrArg, AAZBoolArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.secret_source = AAZStrArg(options=['--secret-source'],
                                                  help="Resource ID of the Azure Key Vault certificate, expected format is like /subscriptions/sub1/resourceGroups/rg1/providers/Microsoft.KeyVault/vaults/vault1/secrets/cert1.",
                                                  required=True)
        args_schema.secret_version = AAZStrArg(options=['--secret-version'],
                                                  help="Version of the certificate to be used.",
                                                  required=False)
        args_schema.use_latest_version = AAZBoolArg(options=['--use-latest-version'],
                                                  help="Whether to use the latest version for the certificate.",
                                                  required=False)
        return args_schema
    def pre_operations(self):
        args = self.ctx.args
        args.parameters.customer_certificate.secret_source = args.secret_source
        if has_value(args.secret_version):
            args.parameters.customer_certificate.secret_version = args.secret_version
        if has_value(args.use_latest_version):
            args.parameters.customer_certificate.use_latest_version = args.use_latest_version
            
from azure.cli.command_modules.cdn.aaz.latest.afd.secret import Create as _AFDSecretCreate
class AFDSecretCreate(_AFDSecretCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZStrArg, AAZBoolArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.secret_source = AAZStrArg(options=['--secret-source'],
                                                  help="Resource ID of the Azure Key Vault certificate, expected format is like /subscriptions/sub1/resourceGroups/rg1/providers/Microsoft.KeyVault/vaults/vault1/secrets/cert1.",
                                                  required=True)
        args_schema.secret_version = AAZStrArg(options=['--secret-version'],
                                                  help="Version of the certificate to be used.",
                                                  required=False)
        args_schema.use_latest_version = AAZBoolArg(options=['--use-latest-version'],
                                                  help="Whether to use the latest version for the certificate.",
                                                  required=False)
        return args_schema
    def pre_operations(self):
        args = self.ctx.args
        args.parameters.customer_certificate.secret_source = args.secret_source
        if has_value(args.secret_version):
            args.parameters.customer_certificate.secret_version = args.secret_version
        if has_value(args.use_latest_version):
            args.parameters.customer_certificate.use_latest_version = args.use_latest_version

from azure.cli.command_modules.cdn.aaz.latest.afd.secret import Update as _AFDSecretUpdate
class AFDSecretUpdate(_AFDSecretUpdate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZStrArg, AAZBoolArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.secret_source = AAZStrArg(options=['--secret-source'],
                                                  help="Resource ID of the Azure Key Vault certificate, expected format is like /subscriptions/sub1/resourceGroups/rg1/providers/Microsoft.KeyVault/vaults/vault1/secrets/cert1.",
                                                  required=True)
        args_schema.secret_version = AAZStrArg(options=['--secret-version'],
                                                  help="Version of the certificate to be used.",
                                                  required=False)
        args_schema.use_latest_version = AAZBoolArg(options=['--use-latest-version'],
                                                  help="Whether to use the latest version for the certificate.",
                                                  required=False)
        return args_schema
    def pre_operations(self):
        args = self.ctx.args
        args.parameters.customer_certificate.secret_source = args.secret_source
        if has_value(args.secret_version):
            args.parameters.customer_certificate.secret_version = args.secret_version
        if has_value(args.use_latest_version):
            args.parameters.customer_certificate.use_latest_version = args.use_latest_version

from azure.cli.command_modules.cdn.aaz.latest.afd.security_policy import Create as _AFDSecurityPolicyCreate
from azure.cli.core.aaz.utils import assign_aaz_list_arg
class AFDSecurityPolicyCreate(_AFDSecurityPolicyCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZListArg, AAZStrArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.domains = AAZListArg(options=['--domains'],
                                                  help="The domains to associate with the WAF policy. Could either be the ID of an endpoint (default domain will be used in that case) or ID of a custom domain.",
                                                  required=True)
        args_schema.domains.Element = AAZStrArg()
        args_schema.waf_policy = AAZStrArg(options=['--waf-policy'],
                                                  help="The ID of Front Door WAF policy.",
                                                  required=True)
        return args_schema
    def pre_operations(self):
        args = self.ctx.args
        args.web_application_firewall.waf_policy = args.waf_policy
        args.web_application_firewall.associations[0].domains = assign_aaz_list_arg(
            args.web_application_firewall.associations[0].domains,
            args.domains,
            element_transformer=lambda _, domains_id: {"id": domains_id})
    
from azure.cli.command_modules.cdn.aaz.latest.afd.security_policy import Update as _AFDSecurityPolicyUpdate
class AFDSecurityPolicyUpdate(_AFDSecurityPolicyUpdate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZListArg, AAZStrArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.domains = AAZListArg(options=['--domains'],
                                                  help="The domains to associate with the WAF policy. Could either be the ID of an endpoint (default domain will be used in that case) or ID of a custom domain.",
                                                  required=True)
        args_schema.domains.Element = AAZStrArg()
        
        args_schema.waf_policy = AAZStrArg(options=['--waf-policy'],
                                                  help="The ID of Front Door WAF policy.",
                                                  required=True)
        return args_schema
    def pre_operations(self):
        args = self.ctx.args
        args.web_application_firewall.waf_policy = args.waf_policy
        args.web_application_firewall.associations[0].domains = assign_aaz_list_arg(
            args.web_application_firewall.associations[0].domains,
            args.domains,
            element_transformer=lambda _, domains_id: {"id": domains_id})