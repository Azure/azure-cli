# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
#
# Code generated by aaz-dev-tools
# --------------------------------------------------------------------------------------------

# pylint: disable=too-many-lines
# pylint: disable=too-many-statements

provider_namespace = "Microsoft.DataBoxEdge"
sub_provider = "Microsoft.EdgeMarketPlace"
api_version = "2023-08-01-preview"


def _get_management_endpoint(cli_ctx):
    """Helper function to determine management endpoint based on cloud configuration."""
    cloud = cli_ctx.cloud
    return cloud.endpoints.resource_manager
    # return "brazilus.management.azure.com"


def _handle_directory_cleanup(version_level_path, logger):
    """Helper function to clean up existing directory."""
    import os
    import shutil

    if os.path.exists(version_level_path):
        try:
            # Remove directory and all its contents
            shutil.rmtree(version_level_path)
            logger.info("Cleaned up existing version directory: %s", version_level_path)
        except OSError as e:
            error_message = f"Failed to clean up directory {version_level_path}: {str(e)}"
            logger.error(error_message)
            return {
                "error": error_message,
                "status": "failed",
                "path": version_level_path,
            }
    return None


def _download_icons(icon_uris, icon_path, logger):
    """Helper function to download icons."""
    import os

    import requests

    for size, uri in icon_uris.items():
        file_extension = "png"
        file_path = os.path.join(icon_path, f"{size}.{file_extension}")

        # Skip if icon already exists
        if os.path.exists(file_path):
            logger.info("Icon %s already exists at %s, skipping download", size, file_path)
            continue

        try:
            logo_response = requests.get(uri)
            if logo_response.status_code == 200:
                with open(file_path, "wb") as f:
                    f.write(logo_response.content)
                logger.info("Downloaded %s logo to %s", size, file_path)
            else:
                logger.error("Failed to download %s logo: %s", size, logo_response.status_code)
        except requests.RequestException as e:
            logger.error("Error downloading %s logo: %s", size, str(e))


def _prepare_paths_and_metadata(output_folder, publisher_id, offer_id, sku, version_id, data, logger):
    """Helper function to prepare directories and save metadata."""
    import json
    import os

    # Create base path for this version
    base_path = os.path.join(output_folder, "catalog_artifacts", publisher_id, offer_id, sku)
    version_level_path = os.path.join(base_path, version_id)
    icon_path = os.path.join(base_path, "icons")

    # Clean up existing directory if needed
    cleanup_result = _handle_directory_cleanup(version_level_path, logger)
    if cleanup_result:
        return cleanup_result, None, None

    os.makedirs(icon_path, exist_ok=True)
    os.makedirs(version_level_path, exist_ok=True)

    # Save metadata.json
    metadata_path = os.path.join(version_level_path, "metadata.json")
    with open(metadata_path, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2)
        logger.info("Saved metadata to %s", metadata_path)

    return None, version_level_path, icon_path


def _find_sku_and_version(skus, sku, version, logger):
    """Helper function to find matching SKU and version."""
    for _sku in skus:
        sku_id = _sku.get("marketplaceSkuId", "")
        if sku_id != sku:
            continue

        # Store the generation information
        generation = _sku.get("generation")
        # Get all versions for this SKU
        versions = _sku.get("marketplaceSkuVersions", [])
        versions = [v for v in versions if v.get("name") == version]

        if not versions:
            logger.warning("No matching version found for SKU %s", sku_id)
            return None, None

        # print if version and generation are found
        print("Found VM version: %s" % versions[0].get('name'))
        print("VM Generation: %s" % generation)
        version_id = versions[0].get("name")
        return version_id, generation

    # If we get here, no matching SKU was found
    logger.warning("No matching SKU found: %s", sku)
    return None, None


def package_offer(cmd, resource_group_name, resource_name, publisher_name,
                  offer_name, sku, version, output_folder):
    """Get details of a specific marketplace offer and download its logos."""

    import requests
    from knack.log import get_logger

    from azure.cli.core.commands.client_factory import get_subscription_id
    from azure.cli.core.util import send_raw_request

    logger = get_logger(__name__)
    management_endpoint = _get_management_endpoint(cmd.cli_ctx)
    subscription_id = get_subscription_id(cmd.cli_ctx)

    # Construct URL with parameters
    url = (
        f"https://{management_endpoint}"
        f"/subscriptions/{subscription_id}"
        f"/resourceGroups/{resource_group_name}"
        f"/providers/{provider_namespace}/dataBoxEdgeDevices/{resource_name}"
        f"/providers/{sub_provider}/offers/{publisher_name}:{offer_name}"
        f"?api-version={api_version}"
    )

    try:
        response = send_raw_request(cmd.cli_ctx, "get", url, resource=management_endpoint)

        if response.status_code != 200:
            error_message = f"Request failed with status code: {response.status_code}"
            logger.error(error_message)
            return {
                "error": error_message,
                "status": "failed",
                "resource_group_name": resource_group_name,
                "response": response.text,
            }

        data = response.json()
        offer_content = data.get("properties", {}).get("offerContent", {})
        icon_uris = offer_content.get("iconFileUris", {})

        # Download logos and metadata if output folder is specified
        if output_folder:
            publisher_id = offer_content.get("offerPublisher", {}).get("publisherId", "")
            offer_id = offer_content.get("offerId", "")
            skus = data.get("properties", {}).get("marketplaceSkus", [])

            # Find matching SKU and version
            version_id, generation = _find_sku_and_version(skus, sku, version, logger)

            if not version_id:
                return

            # Prepare directories and save metadata
            result, version_level_path, icon_path = _prepare_paths_and_metadata(
                output_folder, publisher_id, offer_id, sku, version_id, data, logger
            )

            if result:  # Error occurred
                return result

            # Download icons
            if icon_uris:
                _download_icons(icon_uris, icon_path, logger)

            print("Metadata and icons downloaded successfully")
            print("Offer details retrieved successfully. Proceeding to download VHD.")

            # Downloading VM image
            return download_vhd(
                cmd, resource_group_name, resource_name, publisher_name,
                offer_name, sku, version, generation, version_level_path
            )

    except requests.RequestException as e:
        logger.error("Failed to retrieve offer: %s", str(e))
        return {
            "error": str(e),
            "status": "failed",
            "resource_group_name": resource_group_name,
        }


def _handle_token_response(token_response, output_folder, logger):
    """Helper function to handle token response and download."""
    import os

    if token_response.status_code != 200:
        logger.error("Failed to get access token: %s", token_response.status_code)
        return {
            "error": f"Failed to get access token: {token_response.status_code}",
            "status": "failed",
        }

    token_data = token_response.json()
    download_url = token_data.get("accessToken")

    # Construct and execute azcopy command
    command = f'azcopy copy "{download_url}" "{output_folder}" --check-md5 NoCheck'
    print(command)
    print("Executing command...")
    os.system(command)
    print("Download completed successfully.")

    return {
        "status": "succeeded",
        "message": "Download completed successfully.",
    }


def _get_token_url(management_endpoint, subscription_id, resource_group_name,
                   resource_name, publisher_name, offer_name):
    """Helper function to construct token URL."""
    return (
        f"https://{management_endpoint}"
        f"/subscriptions/{subscription_id}"
        f"/resourceGroups/{resource_group_name}"
        f"/providers/{provider_namespace}/dataBoxEdgeDevices/{resource_name}"
        f"/providers/Microsoft.EdgeMarketPlace/offers/{publisher_name}:{offer_name}"
        f"/getAccessToken?api-version={api_version}"
    )


def _process_async_operation(cmd, async_operation_url, logger, resource_group_name,
                             output_folder, subscription_id, resource_name, publisher_name, offer_name):
    """Process async operation and monitor status."""
    import datetime
    import json
    import time

    import requests

    from azure.cli.core.util import send_raw_request

    max_retries = 10
    base_delay = 2  # seconds
    timeout = 300  # 5 minutes timeout
    start_time = datetime.now()

    # Package parameters needed for token handling
    management_endpoint = _get_management_endpoint(cmd.cli_ctx)

    print("Hitting async operation URL...")
    for attempt in range(max_retries):
        print("Attempt %s of %s..." % (attempt + 1, max_retries))
        try:
            # Check timeout
            if (datetime.now() - start_time).total_seconds() > timeout:
                logger.error("Operation timed out after 5 minutes")
                return {"error": "Operation timed out", "status": "failed"}

            # Get operation status
            status_response = send_raw_request(
                cmd.cli_ctx, "get", async_operation_url,
                resource="https://management.azure.com"
            )

            if status_response.status_code not in (200, 202):
                logger.error("Failed to get operation status: %s", status_response.status_code)
                return {
                    "error": f"Status check failed: {status_response.status_code}",
                    "status": "failed",
                }

            status_data = status_response.json()
            status = status_data.get("status", "").lower()
            print("Current status:", status)

            # Handle successful completion
            if status == "succeeded":
                logger.info("VHD download URL generation succeeded")
                print(status_response)
                requestId = status_data.get("properties", {}).get("requestId")

                if not requestId:
                    logger.error("Download URL not found in response")
                    return {"error": "Download URL not found", "status": "failed"}

                print(f"Fetched request Id for VHD Download: {requestId}")

                # Obtaining SAS token using request Id
                token_url = _get_token_url(
                    management_endpoint, subscription_id, resource_group_name,
                    resource_name, publisher_name, offer_name
                )
                token_body = {"requestId": requestId}

                token_response = send_raw_request(
                    cmd.cli_ctx, "post", token_url,
                    resource="https://management.azure.com",
                    body=json.dumps(token_body)
                )

                return _handle_token_response(token_response, output_folder, logger)

            # Handle failure
            if status == "failed":
                error_message = status_data.get("error", {}).get("message", "Unknown error")
                logger.error("Operation failed: %s", error_message)
                return {"error": error_message, "status": "failed"}

            # Still in progress, wait and retry
            logger.info("Operation in progress... (attempt %s/%s)", attempt + 1, max_retries)
            delay = base_delay * (2**attempt)  # Exponential backoff
            time.sleep(delay)

        except (requests.RequestException, ValueError) as e:
            logger.error("Error checking operation status: %s", str(e))
            delay = base_delay * (2**attempt)
            time.sleep(delay)

    # Exhausted all retries
    logger.error("Maximum retry attempts reached")
    return {"error": "Maximum retry attempts reached", "status": "failed"}


def download_vhd(cmd, resource_group_name, resource_name, publisher_name,
                 offer_name, sku, version, generation, output_folder):
    """Generate access token for VHD download."""
    import json

    import requests
    from knack.log import get_logger

    from azure.cli.core.commands.client_factory import get_subscription_id
    from azure.cli.core.util import send_raw_request

    logger = get_logger(__name__)
    management_endpoint = _get_management_endpoint(cmd.cli_ctx)
    subscription_id = get_subscription_id(cmd.cli_ctx)

    # API endpoint construction
    url = (
        f"https://{management_endpoint}"
        f"/subscriptions/{subscription_id}"
        f"/resourceGroups/{resource_group_name}"
        f"/providers/{provider_namespace}/dataBoxEdgeDevices/{resource_name}"
        f"/providers/Microsoft.EdgeMarketPlace/offers/{publisher_name}:{offer_name}"
        f"/generateAccessToken?api-version=2023-08-01-preview"
    )

    # Request body
    body = {
        "edgeMarketPlaceRegion": "westus",
        "hypervGeneration": generation,
        "marketPlaceSku": sku,
        "marketPlaceSkuVersion": version,
    }

    try:
        print("Generating access token for VHD download...")
        response = send_raw_request(
            cmd.cli_ctx, "post", url,
            resource="https://management.azure.com",
            body=json.dumps(body)
        )

        print("Checking status of VHD download URL generation...")

        # Check if the request was successful
        if response.status_code not in (200, 202):
            error_message = f"Request failed with status code: {response.status_code}"
            logger.error(error_message)
            return {
                "error": error_message,
                "status": "failed",
                "resource_group_name": resource_group_name,
                "response": response.text,
            }

        # Get async operation URL from headers
        async_operation_url = response.headers.get("Azure-AsyncOperation")

        if not async_operation_url:
            logger.error("Async operation URL not found in response")
            return {
                "error": "Async operation URL not found",
                "status": "failed",
            }

        # Process the async operation
        return _process_async_operation(
            cmd, async_operation_url, logger, resource_group_name,
            output_folder, subscription_id, resource_name,
            publisher_name, offer_name
        )

    except requests.RequestException as e:
        logger.error("Failed to generate access token: %s", str(e))
        return {
            "error": str(e),
            "status": "failed",
            "resource_group_name": resource_group_name,
        }


def list_offers(cmd, resource_group_name, resource_name):
    """List all offers for disconnected operations."""
    import requests
    from knack.log import get_logger

    from azure.cli.core.commands.client_factory import get_subscription_id
    from azure.cli.core.util import send_raw_request

    logger = get_logger(__name__)
    management_endpoint = _get_management_endpoint(cmd.cli_ctx)
    subscription_id = get_subscription_id(cmd.cli_ctx)

    # Construct URL with parameters
    url = (
        f"https://{management_endpoint}"
        f"/subscriptions/{subscription_id}"
        f"/resourceGroups/{resource_group_name}"
        f"/providers/{provider_namespace}/dataBoxEdgeDevices/{resource_name}"
        f"/providers/{sub_provider}/offers"
        f"?api-version={api_version}"
    )

    try:
        response = send_raw_request(cmd.cli_ctx, "get", url, resource="https://management.azure.com")

        if response.status_code == 200:
            data = response.json()
            result = []

            for offer in data.get("value", []):
                offer_content = offer.get("properties", {}).get("offerContent", {})
                skus = offer.get("properties", {}).get("marketplaceSkus", [])

                for sku in skus:
                    versions = sku.get("marketplaceSkuVersions", [])[:]
                    row = {
                        "Publisher": offer_content.get("offerPublisher", {}).get("publisherId"),
                        "Offer": offer_content.get("offerId"),
                        "SKU": sku.get("marketplaceSkuId"),
                        "Versions": f"{len(versions)} {'version' if len(versions) == 1 else 'versions'} available",
                        "OS_Type": sku.get("operatingSystem", {}).get("type"),
                    }
                    result.append(row)

            return result

        error_message = f"Request failed with status code: {response.status_code}"
        logger.error(error_message)
        return {
            "error": error_message,
            "status": "failed",
            "resource_group_name": resource_group_name,
            "response": response.text,
        }

    except requests.RequestException as e:
        logger.error("Failed to retrieve offers: %s", str(e))
        return {
            "error": str(e),
            "status": "failed",
            "resource_group_name": resource_group_name,
        }


def get_offer(cmd, resource_group_name, resource_name, publisher_name, offer_name):
    """List all offers for disconnected operations."""
    import requests
    from knack.log import get_logger

    from azure.cli.core.commands.client_factory import get_subscription_id
    from azure.cli.core.util import send_raw_request

    logger = get_logger(__name__)
    management_endpoint = _get_management_endpoint(cmd.cli_ctx)
    subscription_id = get_subscription_id(cmd.cli_ctx)

    # Construct URL with parameters
    url = (
        f"https://{management_endpoint}"
        f"/subscriptions/{subscription_id}"
        f"/resourceGroups/{resource_group_name}"
        f"/providers/{provider_namespace}/dataBoxEdgeDevices/{resource_name}"
        f"/providers/{sub_provider}/offers/{publisher_name}:{offer_name}"
        f"?api-version={api_version}"
    )

    try:
        response = send_raw_request(cmd.cli_ctx, "get", url, resource="https://management.azure.com")

        if response.status_code == 200:
            data = response.json()
            result = []

            offer_content = data.get("properties", {}).get("offerContent", {})
            skus = data.get("properties", {}).get("marketplaceSkus", [])

            for sku in skus:
                # Get all versions for this SKU
                versions = sku.get("marketplaceSkuVersions", [])[:]

                # transform versions and size array into a multi-line string
                version_str = ", ".join(
                    f"{v.get('name')}({v.get('minimumDownloadSizeInMb')}MB)" for v in versions
                )

                # Create a single row with flattened version info
                row = {
                    "Publisher": offer_content.get("offerPublisher", {}).get("publisherId"),
                    "Offer": offer_content.get("offerId"),
                    "SKU": sku.get("marketplaceSkuId"),
                    "Versions": version_str,
                    "OS_Type": sku.get("operatingSystem", {}).get("type"),
                }
                result.append(row)
            return result

        error_message = f"Request failed with status code: {response.status_code}"
        logger.error(error_message)
        return {
            "error": error_message,
            "status": "failed",
            "resource_group_name": resource_group_name,
            "response": response.text,
        }

    except requests.RequestException as e:
        logger.error("Failed to retrieve offers: %s", str(e))
        return {
            "error": str(e),
            "status": "failed",
            "resource_group_name": resource_group_name,
        }
