# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# --------------------------------------------------------------------------------------------
import os
import re
import shutil


class CompactorCtx:

    def __init__(self):
        self._code_pieces = {}
        self._namespace = None
        self._write_mode = False
        self._written_namespaces = set()
        self._parent_namespaces = set()

    def add_code_piece(self, key, code):
        assert self._namespace is not None and self._write_mode, "Namespace is not set or readonly"
        key = code
        if key not in self._code_pieces:
            self._code_pieces[key] = {
                self._namespace: {
                    "max_count_code": code,
                    "codes": {
                        code: 1
                    }
                }
            }
            return

        if self._namespace in self._code_pieces[key] and code in self._code_pieces[key][self._namespace]["codes"]:
            # if the code defined in the current namespace increase the count and update the max_count_code
            codes = self._code_pieces[key][self._namespace]["codes"]
            codes[code] += 1
            max_count_code = self._code_pieces[key][self._namespace]["max_count_code"]
            if codes[code] > codes[max_count_code]:
                self._code_pieces[key][self._namespace]["max_count_code"] = code
            return

        # the code is defined in other _helpers
        if self.find_code_piece_in_parent(key, code):
            return

        # add code piece
        if self._namespace not in self._code_pieces[key]:
            self._code_pieces[key] = {
                self._namespace: {
                    "max_count_code": code,
                    "codes": {
                        code: 1
                    }
                }
            }
            return

        self._code_pieces[key][self._namespace]["codes"][code] = 1

    def set_current_namespace(self, namespace, write_mode):
        assert not write_mode or namespace not in self._written_namespaces
        self._namespace = namespace
        self._write_mode = write_mode
        if not namespace:
            # clean namespace
            return

        self._parent_namespaces.clear()
        pieces = namespace.split(os.sep)
        for i in range(1, len(pieces)-1):
            parent_namespace = os.sep.join(pieces[:-i])
            self._parent_namespaces.add(parent_namespace)

        if write_mode:
            self._written_namespaces.add(namespace)

    def find_code_piece_in_parent(self, key, code):
        """find code piece in frozen namespaces"""
        if key not in self._code_pieces:
            return
        for namespace, value in self._code_pieces[key].items:
            if namespace not in self._parent_namespaces:
                continue
            if value["max_count_code"] == code and value["codes"][code] > 1:
                return namespace

    def fetch_code_piece(self, key, code):
        assert not self._write_mode, "Fetch code piece is not supported in write mode"
        parent_namespace = self.find_code_piece_in_parent(key, code)
        if parent_namespace:
            return parent_namespace
        if key in self._code_pieces and self._namespace in self._code_pieces[key] and \
                code == self._code_pieces[key][self._namespace]["max_count_code"] and \
                self._code_pieces[key][self._namespace]["codes"][code] > 1:
            return self._namespace


_PY_HEADER = """# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
#
# Code generated by aaz-dev-tools
# --------------------------------------------------------------------------------------------
# pylint: skip-file
# flake8: noqa

"""


class MainModuleCompactor:

    _command_group_pattern = re.compile(r'^class\s+(.*)\(.*AAZCommandGroup.*\)\s*:\s*$')
    _command_pattern = re.compile(r'^class\s+(.*)\(.*AAZ(Wait)?Command.*\)\s*:\s*$')
    _file_end_pattern = re.compile(r'^__all__ = \[.*\]\s*$')

    def __init__(self, mod_name):
        self._mod_name = mod_name
        self._folder = self._get_module_folder()

    def compact(self):
        self._create_compact_aaz_folder()
        from azure.cli.core.profiles import AZURE_API_PROFILES
        for profile in AZURE_API_PROFILES:
            profile_mod_name = profile.lower().replace('-', '_')
            profile_path = self._get_aaz_rg_path(profile_mod_name)
            if not os.path.exists(profile_path):
                continue

            # create profile folders
            compact_folder = self._get_compact_aaz_rg_path(profile_mod_name)
            os.mkdir(compact_folder)
            self._write_py_file(os.path.join(compact_folder, '__init__.py'), content="")

            ctx = CompactorCtx()
            self.compact_sub_resource_groups(ctx, profile_mod_name)

    def _write_py_file(self, path, content):
        init_content = _PY_HEADER + content
        with open(path, 'w') as f:
            f.write(init_content)

    def _create_compact_aaz_folder(self):
        folder = self._get_compact_aaz_folder()
        if os.path.exists(folder):
            shutil.rmtree(folder)
        os.mkdir(folder)
        self._write_py_file(os.path.join(folder, '__init__.py'), content="")

    def compact_sub_resource_groups(self, ctx: CompactorCtx, dirs):
        folder = self._get_aaz_rg_path(dirs)
        assert os.path.isdir(folder), f'Invalid folder path {folder}'
        for name in os.listdir(folder):
            sub_dir = os.path.join(dirs, name)
            self.compact_resource_group(ctx, sub_dir)

    def compact_resource_group(self, ctx: CompactorCtx, dirs):
        folder = self._get_aaz_rg_path(dirs)
        init_file = os.path.join(folder, '__init__.py')
        if not os.path.exists(init_file):
            return
        if not os.path.isfile(init_file):
            raise ValueError("Invalid init file: {}".format(init_file))

        compact_folder = self._get_compact_aaz_rg_path(dirs)
        os.mkdir(compact_folder)
        self.compact_resource_group_commands(ctx, dirs)
        self.compact_sub_resource_groups(ctx, dirs)

    def compact_resource_group_commands(self, ctx: CompactorCtx, dirs):
        folder = self._get_aaz_rg_path(dirs)
        ctx.set_current_namespace(dirs, write_mode=True)

        compact_folder = self._get_compact_aaz_rg_path(dirs)

        cmds_content, grp_cls = self._parse_cmd_group_file(folder, None)

        cmds_content, cmd_clses = self._parse_cmd_files(folder, cmds_content)

        init_content = "from .__cmds import *\n" if cmds_content else ""
        self._write_py_file(os.path.join(compact_folder, '__init__.py'), content=init_content)

        if cmds_content:
            self._write_py_file(os.path.join(compact_folder, '__cmds.py'), content=cmds_content)

        ctx.set_current_namespace(None, write_mode=False)

    def _parse_cmd_group_file(self, folder, cmds_content):
        cmd_group_file = os.path.join(folder, '__cmd_group.py')
        if not os.path.isfile(cmd_group_file):
            return None, None

        grp_cls = None

        if not cmds_content:
            cmds_content = "from azure.cli.core.aaz import *\n"

        cg_lines = []
        with open(cmd_group_file, 'r') as f:
            while f.readable():
                line = f.readline()
                if line.startswith('@register_command_group('):
                    cg_lines.append(line)
                    continue
                if not cg_lines:
                    continue
                match = self._command_group_pattern.match(line)
                if match:
                    grp_cls = match[1]
                if self._file_end_pattern.match(line):
                    break
                cg_lines.append(line)
        while cg_lines and not cg_lines[-1].strip():
            cg_lines.pop()

        cmds_content += ''.join(['\n', '\n', *cg_lines])

        return cmds_content, grp_cls

    def _parse_cmd_files(self, folder,  cmds_content):
        cmd_clses = []
        for name in os.listdir(folder):
            if name.startswith('__') or not name.startswith('_') or not name.endswith('.py'):
                continue
            cmd_file = os.path.join(folder, name)
            if not os.path.isfile(cmd_file):
                continue


        return cmds_content, cmd_clses

    def _get_module_folder(self):
        cli_folder = '..'
        module_folder = os.path.join(
            cli_folder, "src", "azure-cli", "azure", "cli", "command_modules", self._mod_name.replace('-', '_').lower())
        if not os.path.exists(module_folder):
            raise ValueError("Module folder is not exist: {}".format(cli_folder))
        return module_folder

    def _get_aaz_folder(self):
        return os.path.join(self._folder, 'aaz')

    def _get_aaz_rg_path(self, dirs):
        return os.path.join(self._get_aaz_folder(), dirs)

    def _get_compact_aaz_folder(self):
        return os.path.join(self._folder, 'aaz_compact')

    def _get_compact_aaz_rg_path(self, dirs):
        return os.path.join(self._get_compact_aaz_folder(), dirs)


if __name__ == "__main__":
    compactor = MainModuleCompactor("network")
    compactor.compact()
