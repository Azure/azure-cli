interactions:
- request:
    body: null
    headers:
      Accept:
      - application/json
      Accept-Encoding:
      - gzip, deflate
      CommandName:
      - storage account keys list
      Connection:
      - keep-alive
      Content-Length:
      - '0'
      ParameterSetName:
      - -n -g --query -o
      User-Agent:
      - AZURECLI/2.33.1 azsdk-python-azure-mgmt-storage/19.1.0 Python/3.7.9 (Windows-10-10.0.22000-SP0)
    method: POST
    uri: https://management.azure.com/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/clitest.rg000001/providers/Microsoft.Storage/storageAccounts/clitest000002/listKeys?api-version=2021-08-01&$expand=kerb
  response:
    body:
      string: '{"keys":[{"creationTime":"2022-02-23T03:37:04.7418756Z","keyName":"key1","value":"veryFakedStorageAccountKey==","permissions":"FULL"},{"creationTime":"2022-02-23T03:37:04.7418756Z","keyName":"key2","value":"veryFakedStorageAccountKey==","permissions":"FULL"}]}'
    headers:
      cache-control:
      - no-cache
      content-length:
      - '260'
      content-type:
      - application/json
      date:
      - Wed, 23 Feb 2022 03:37:25 GMT
      expires:
      - '-1'
      pragma:
      - no-cache
      server:
      - Microsoft-Azure-Storage-Resource-Provider/1.0,Microsoft-HTTPAPI/2.0 Microsoft-HTTPAPI/2.0
      strict-transport-security:
      - max-age=31536000; includeSubDomains
      transfer-encoding:
      - chunked
      vary:
      - Accept-Encoding
      x-content-type-options:
      - nosniff
      x-ms-ratelimit-remaining-subscription-resource-requests:
      - '11997'
    status:
      code: 200
      message: OK
- request:
    body: null
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '0'
      User-Agent:
      - Azure-Storage/2.0.0-2.0.1 (Python CPython 3.7.9; Windows 10) AZURECLI/2.33.1
      x-ms-date:
      - Wed, 23 Feb 2022 03:37:26 GMT
      x-ms-version:
      - '2018-11-09'
    method: PUT
    uri: https://clitest000002.blob.core.windows.net/cont000003?restype=container
  response:
    body:
      string: ''
    headers:
      content-length:
      - '0'
      date:
      - Wed, 23 Feb 2022 03:37:26 GMT
      etag:
      - '"0x8D9F67DD039285E"'
      last-modified:
      - Wed, 23 Feb 2022 03:37:27 GMT
      server:
      - Windows-Azure-Blob/1.0 Microsoft-HTTPAPI/2.0
      x-ms-version:
      - '2018-11-09'
    status:
      code: 201
      message: Created
- request:
    body: "# --------------------------------------------------------------------------------------------\r\n#
      Copyright (c) Microsoft Corporation. All rights reserved.\r\n# Licensed under
      the MIT License. See License.txt in the project root for license information.\r\n#
      --------------------------------------------------------------------------------------------\r\n\r\nimport
      os\r\nimport re\r\nimport unittest\r\nfrom datetime import datetime, timedelta\r\nfrom
      azure.cli.testsdk import (ScenarioTest, ResourceGroupPreparer, StorageAccountPreparer,\r\n
      \                              JMESPathCheck, JMESPathCheckExists, NoneCheck,
      api_version_constraint)\r\nfrom knack.util import CLIError\r\nfrom azure.cli.core.profiles
      import ResourceType\r\n\r\nfrom azure.cli.command_modules.storage._client_factory
      import MISSING_CREDENTIALS_ERROR_MESSAGE\r\nfrom ..storage_test_util import
      StorageScenarioMixin\r\nfrom azure.cli.testsdk.scenario_tests import AllowLargeResponse\r\n\r\n\r\n@api_version_constraint(ResourceType.MGMT_STORAGE,
      min_api='2016-12-01')\r\nclass StorageBlobUploadTests(StorageScenarioMixin,
      ScenarioTest):\r\n    @ResourceGroupPreparer()\r\n    @StorageAccountPreparer(parameter_name='source_account')\r\n
      \   @StorageAccountPreparer(parameter_name='target_account')\r\n    def test_storage_blob_incremental_copy(self,
      resource_group, source_account, target_account):\r\n        source_file = self.create_temp_file(16)\r\n
      \       source_account_info = self.get_account_info(resource_group, source_account)\r\n
      \       source_container = self.create_container(source_account_info)\r\n        self.storage_cmd('storage
      blob upload -c {} -n src -f \"{}\" -t page', source_account_info,\r\n                         source_container,
      source_file)\r\n\r\n        snapshot = self.storage_cmd('storage blob snapshot
      -c {} -n src', source_account_info,\r\n                                    source_container).get_output_in_json()['snapshot']\r\n\r\n
      \       target_account_info = self.get_account_info(resource_group, target_account)\r\n
      \       target_container = self.create_container(target_account_info)\r\n        self.storage_cmd('storage
      blob incremental-copy start --source-container {} --source-blob '\r\n                         'src
      --source-account-name {} --source-account-key {} --source-snapshot '\r\n                         '{}
      --destination-container {} --destination-blob backup '\r\n                         '--destination-if-modified-since
      \"2020-06-29T06:32Z\" ',\r\n                         target_account_info, source_container,
      source_account,\r\n                         source_account_info[1], snapshot,
      target_container)\r\n\r\n    def test_storage_blob_no_credentials_scenario(self):\r\n
      \       source_file = self.create_temp_file(1)\r\n        self.cmd('storage
      blob upload -c foo -n bar -f \"' + source_file + '\"', expect_failure=CLIError)\r\n\r\n
      \   @ResourceGroupPreparer()\r\n    @StorageAccountPreparer()\r\n    def test_storage_blob_upload_small_file(self,
      resource_group, storage_account):\r\n        for blob_type in ['block', 'page']:\r\n
      \           self.verify_blob_upload_and_download(resource_group, storage_account,
      1, blob_type, 0)\r\n\r\n    @ResourceGroupPreparer()\r\n    @StorageAccountPreparer()\r\n
      \   def test_storage_blob_upload_midsize_file(self, resource_group, storage_account):\r\n
      \       for blob_type in ['block', 'page']:\r\n            self.verify_blob_upload_and_download(resource_group,
      storage_account, 4096, 'block', 0)\r\n\r\n    def verify_blob_upload_and_download(self,
      group, account, file_size_kb, blob_type,\r\n                                        block_count=0,
      skip_download=False):\r\n        local_dir = self.create_temp_dir()\r\n        local_file
      = self.create_temp_file(file_size_kb)\r\n        blob_name = self.create_random_name(prefix='blob',
      length=24)\r\n        account_info = self.get_account_info(group, account)\r\n\r\n
      \       # create file for uploading without --name\r\n        local_file_without_name
      = self.create_temp_file(file_size_kb)\r\n        blob_name_for_substitution
      = self.create_random_name(prefix='blob', length=24)\r\n        old_file_name
      = os.path.basename(local_file_without_name)\r\n        new_file_name_with_path
      = local_file_without_name.replace(old_file_name, blob_name_for_substitution)\r\n
      \       os.rename(local_file_without_name, new_file_name_with_path)\r\n\r\n
      \       container = self.create_container(account_info)\r\n\r\n        self.storage_cmd('storage
      blob exists -n {} -c {}', account_info, blob_name, container) \\\r\n            .assert_with_checks(JMESPathCheck('exists',
      False))\r\n\r\n        self.storage_cmd('storage blob upload -c {} -f \"{}\"
      -n {} --type {}', account_info,\r\n                         container, local_file,
      blob_name, blob_type)\r\n        self.storage_cmd('storage blob exists -n {}
      -c {}', account_info, blob_name, container) \\\r\n            .assert_with_checks(JMESPathCheck('exists',
      True))\r\n\r\n        # upload without specifying name\r\n        self.storage_cmd('storage
      blob upload -c {} -f \"{}\" --type {}', account_info,\r\n                         container,
      new_file_name_with_path, blob_type)\r\n        os.rename(new_file_name_with_path,
      local_file_without_name)\r\n        self.storage_cmd('storage blob exists -n
      {} -c {}', account_info, blob_name_for_substitution, container) \\\r\n            .assert_with_checks(JMESPathCheck('exists',
      True))\r\n\r\n        self.storage_cmd('storage blob list -c {} -otable --num-results
      1', account_info, container)\r\n\r\n        show_result = self.storage_cmd('storage
      blob show -n {} -c {}', account_info, blob_name,\r\n                                       container).get_output_in_json()\r\n
      \       self.assertEqual(show_result.get('name'), blob_name)\r\n        if blob_type
      == 'page':\r\n            self.assertEqual(type(show_result.get('properties').get('pageRanges')),
      list)\r\n        else:\r\n            self.assertEqual(show_result.get('properties').get('pageRanges'),
      None)\r\n\r\n        expiry = (datetime.utcnow() + timedelta(hours=1)).strftime('%Y-%m-%dT%H:%MZ')\r\n
      \       sas = self.storage_cmd('storage blob generate-sas -n {} -c {} --expiry
      {} --permissions '\r\n                               'r --https-only', account_info,
      blob_name, container, expiry).output\r\n        self.assertTrue(sas)\r\n        self.assertIn('&sig=',
      sas)\r\n\r\n        self.storage_cmd('storage blob update -n {} -c {} --content-type
      application/test-content',\r\n                         account_info, blob_name,
      container)\r\n\r\n        self.storage_cmd('storage blob show -n {} -c {}',
      account_info, blob_name, container) \\\r\n            .assert_with_checks(\r\n
      \           [JMESPathCheck('properties.contentSettings.contentType', 'application/test-content'),\r\n
      \            JMESPathCheck('properties.contentLength', file_size_kb * 1024)])\r\n\r\n
      \       # check that blob properties can be set back to null\r\n        self.storage_cmd('storage
      blob update -n {} -c {} --content-type \"\"',\r\n                         account_info,
      blob_name, container)\r\n\r\n        self.storage_cmd('storage blob show -n
      {} -c {}', account_info, blob_name, container) \\\r\n            .assert_with_checks(JMESPathCheck('properties.contentSettings.contentType',
      None))\r\n\r\n        self.storage_cmd('storage blob service-properties show',
      account_info) \\\r\n            .assert_with_checks(JMESPathCheck('hourMetrics.enabled',
      True))\r\n\r\n        if not skip_download:\r\n            downloaded = os.path.join(local_dir,
      'test.file')\r\n\r\n            self.storage_cmd('storage blob download -n {}
      -c {} --file \"{}\"',\r\n                             account_info, blob_name,
      container, downloaded)\r\n            self.assertTrue(os.path.isfile(downloaded),
      'The file is not downloaded.')\r\n            self.assertEqual(file_size_kb
      * 1024, os.stat(downloaded).st_size,\r\n                             'The download
      file size is not right.')\r\n            self.storage_cmd('storage blob download
      -n {} -c {} --file \"{}\" --start-range 10 --end-range 499',\r\n                             account_info,
      blob_name, container, downloaded)\r\n            self.assertEqual(490, os.stat(downloaded).st_size,\r\n
      \                            'The download file size is not right.')\r\n\r\n
      \       # Verify the requests in cassette to ensure the count of the block requests
      is expected\r\n        # This portion of validation doesn't verify anything
      during playback because the recording\r\n        # is fixed.\r\n\r\n        def
      is_block_put_req(request):\r\n            if request.method != 'PUT':\r\n                return
      False\r\n\r\n            if not re.search('/cont[0-9]+/blob[0-9]+', request.path):\r\n
      \               return False\r\n\r\n            comp_block = False\r\n            has_blockid
      = False\r\n            for key, value in request.query:\r\n                if
      key == 'comp' and value == 'block':\r\n                    comp_block = True\r\n
      \               elif key == 'blockid':\r\n                    has_blockid =
      True\r\n\r\n            return comp_block and has_blockid\r\n\r\n        requests
      = self.cassette.requests\r\n        put_blocks = [request for request in requests
      if is_block_put_req(request)]\r\n        self.assertEqual(block_count, len(put_blocks),\r\n
      \                        'The expected number of block put requests is {} but
      the actual '\r\n                         'number is {}.'.format(block_count,
      len(put_blocks)))\r\n\r\n    @ResourceGroupPreparer()\r\n    @StorageAccountPreparer()\r\n
      \   def test_storage_blob_download_directory(self, resource_group, storage_account):\r\n
      \       local_dir = self.create_temp_dir()\r\n        account_info = self.get_account_info(resource_group,
      storage_account)\r\n        from azure.cli.core.azclierror import FileOperationError\r\n
      \       with self.assertRaisesRegex(FileOperationError, 'File is expected, not
      a directory'):\r\n            self.storage_cmd('storage blob download -c mycontainer
      -n myblob -f \"{}\"', account_info, local_dir)\r\n\r\n    @ResourceGroupPreparer()\r\n
      \   @StorageAccountPreparer()\r\n    def test_storage_blob_socket_timeout(self,
      resource_group, storage_account):\r\n        local_dir = self.create_temp_dir()\r\n
      \       local_file = self.create_temp_file(1)\r\n        blob_name = self.create_random_name(prefix='blob',
      length=24)\r\n        account_info = self.get_account_info(resource_group, storage_account)\r\n\r\n
      \       container = self.create_container(account_info)\r\n\r\n        from
      azure.common import AzureException\r\n        with self.assertRaises(AzureException):\r\n
      \           self.storage_cmd('storage blob upload -c {} -f \"{}\" -n {} --type
      block --socket-timeout -11',\r\n                             account_info, container,
      local_file, blob_name)\r\n\r\n        self.storage_cmd('storage blob exists
      -n {} -c {}', account_info, blob_name, container) \\\r\n            .assert_with_checks(JMESPathCheck('exists',
      False))\r\n\r\n        self.storage_cmd('storage blob upload -c {} -f \"{}\"
      -n {} --type block --socket-timeout 10',\r\n                         account_info,
      container, local_file, blob_name)\r\n        self.storage_cmd('storage blob
      exists -n {} -c {}', account_info, blob_name, container) \\\r\n            .assert_with_checks(JMESPathCheck('exists',
      True))\r\n\r\n        self.storage_cmd('storage blob show -n {} -c {}', account_info,
      blob_name, container) \\\r\n            .assert_with_checks(JMESPathCheck('name',
      blob_name))\r\n\r\n        downloaded = os.path.join(local_dir, 'test.file')\r\n\r\n
      \       self.storage_cmd('storage blob download -n {} -c {} --file \"{}\" --socket-timeout
      10',\r\n                         account_info, blob_name, container, downloaded)\r\n
      \       self.assertTrue(os.path.isfile(downloaded), 'The file is not downloaded.')\r\n\r\n
      \   @ResourceGroupPreparer()\r\n    @StorageAccountPreparer()\r\n    def test_storage_blob_lease_operations(self,
      resource_group, storage_account):\r\n        account_info = self.get_account_info(resource_group,
      storage_account)\r\n        local_file = self.create_temp_file(128)\r\n        c
      = self.create_container(account_info)\r\n        b = self.create_random_name('blob',
      24)\r\n        proposed_lease_id = 'abcdabcd-abcd-abcd-abcd-abcdabcdabcd'\r\n
      \       new_lease_id = 'dcbadcba-dcba-dcba-dcba-dcbadcbadcba'\r\n        date
      = '2016-04-01t12:00z'\r\n\r\n        self.storage_cmd('storage blob upload -c
      {} -n {} -f \"{}\"', account_info, c, b, local_file)\r\n\r\n        # test lease
      operations\r\n        self.storage_cmd('storage blob lease acquire --lease-duration
      60 -b {} -c {} '\r\n                         '--if-modified-since {} --proposed-lease-id
      {}', account_info, b, c, date,\r\n                         proposed_lease_id)\r\n
      \       self.storage_cmd('storage blob show -n {} -c {}', account_info, b, c)
      \\\r\n            .assert_with_checks(JMESPathCheck('properties.lease.duration',
      'fixed'),\r\n                                JMESPathCheck('properties.lease.state',
      'leased'),\r\n                                JMESPathCheck('properties.lease.status',
      'locked'))\r\n        self.storage_cmd('storage blob lease change -b {} -c {}
      --lease-id {} '\r\n                         '--proposed-lease-id {}', account_info,
      b, c, proposed_lease_id,\r\n                         new_lease_id)\r\n        self.storage_cmd('storage
      blob lease renew -b {} -c {} --lease-id {}', account_info, b, c,\r\n                         new_lease_id)\r\n
      \       self.storage_cmd('storage blob show -n {} -c {}', account_info, b, c)
      \\\r\n            .assert_with_checks(JMESPathCheck('properties.lease.duration',
      'fixed'),\r\n                                JMESPathCheck('properties.lease.state',
      'leased'),\r\n                                JMESPathCheck('properties.lease.status',
      'locked'))\r\n        self.storage_cmd('storage blob lease break -b {} -c {}
      --lease-break-period 30',\r\n                         account_info, b, c)\r\n
      \       self.storage_cmd('storage blob show -n {} -c {}', account_info, b, c)
      \\\r\n            .assert_with_checks(JMESPathCheck('properties.lease.duration',
      None),\r\n                                JMESPathCheck('properties.lease.state',
      'breaking'),\r\n                                JMESPathCheck('properties.lease.status',
      'locked'))\r\n        self.storage_cmd('storage blob lease release -b {} -c
      {} --lease-id {}', account_info, b, c,\r\n                         new_lease_id)\r\n
      \       self.storage_cmd('storage blob show -n {} -c {}', account_info, b, c)
      \\\r\n            .assert_with_checks(JMESPathCheck('properties.lease.duration',
      None),\r\n                                JMESPathCheck('properties.lease.state',
      'available'),\r\n                                JMESPathCheck('properties.lease.status',
      'unlocked'))\r\n\r\n    @ResourceGroupPreparer()\r\n    @StorageAccountPreparer()\r\n
      \   def test_storage_blob_snapshot_operations(self, resource_group, storage_account):\r\n
      \       account_info = self.get_account_info(resource_group, storage_account)\r\n
      \       local_file = self.create_temp_file(128)\r\n        c = self.create_container(account_info)\r\n
      \       b = self.create_random_name('blob', 24)\r\n\r\n        self.storage_cmd('storage
      blob upload -c {} -n {} -f \"{}\"', account_info, c, b, local_file)\r\n\r\n
      \       snapshot_dt = self.storage_cmd('storage blob snapshot -c {} -n {}',
      account_info, c, b) \\\r\n            .get_output_in_json()['snapshot']\r\n
      \       self.storage_cmd('storage blob exists -n {} -c {} --snapshot {}', account_info,
      b, c,\r\n                         snapshot_dt) \\\r\n            .assert_with_checks(JMESPathCheck('exists',
      True))\r\n\r\n    @ResourceGroupPreparer()\r\n    @StorageAccountPreparer()\r\n
      \   def test_storage_blob_metadata_operations(self, resource_group, storage_account):\r\n
      \       account_info = self.get_account_info(resource_group, storage_account)\r\n
      \       c = self.create_container(account_info)\r\n        b = self.create_random_name('blob',
      24)\r\n\r\n        self.storage_cmd('storage blob upload -c {} -n {} -f \"{}\"',
      account_info, c, b, __file__)\r\n        self.storage_cmd('storage blob metadata
      update -n {} -c {} --metadata a=b c=d',\r\n                         account_info,
      b, c)\r\n        self.storage_cmd('storage blob metadata show -n {} -c {}',
      account_info, b, c) \\\r\n            .assert_with_checks(JMESPathCheck('a',
      'b'), JMESPathCheck('c', 'd'))\r\n        self.storage_cmd('storage blob metadata
      update -n {} -c {}', account_info, b, c)\r\n        self.storage_cmd('storage
      blob metadata show -n {} -c {}', account_info, b, c) \\\r\n            .assert_with_checks(NoneCheck())\r\n\r\n
      \   @ResourceGroupPreparer()\r\n    @StorageAccountPreparer()\r\n    def test_storage_blob_container_operations(self,
      resource_group, storage_account):\r\n        account_info = self.get_account_info(resource_group,
      storage_account)\r\n        c = self.create_container(account_info)\r\n        proposed_lease_id
      = 'abcdabcd-abcd-abcd-abcd-abcdabcdabcd'\r\n        new_lease_id = 'dcbadcba-dcba-dcba-dcba-dcbadcbadcba'\r\n
      \       date = '2016-04-01t12:00z'\r\n\r\n        self.storage_cmd('storage
      container exists -n {}', account_info, c) \\\r\n            .assert_with_checks(JMESPathCheck('exists',
      True))\r\n\r\n        self.storage_cmd('storage container set-permission -n
      {} --public-access blob',\r\n                         account_info, c)\r\n        self.storage_cmd('storage
      container show-permission -n {}', account_info, c) \\\r\n            .assert_with_checks(JMESPathCheck('publicAccess',
      'blob'))\r\n        self.storage_cmd('storage container set-permission -n {}
      --public-access off', account_info,\r\n                         c)\r\n        self.storage_cmd('storage
      container show-permission -n {}', account_info, c) \\\r\n            .assert_with_checks(JMESPathCheck('publicAccess',
      'off'))\r\n\r\n        self.storage_cmd('storage container show -n {}', account_info,
      c) \\\r\n            .assert_with_checks(JMESPathCheck('name', c))\r\n\r\n        self.assertIn(c,
      self.storage_cmd('storage container list --query \"[].name\"',\r\n                                          account_info).get_output_in_json())\r\n\r\n
      \       self.storage_cmd('storage container metadata update -n {} --metadata
      foo=bar moo=bak',\r\n                         account_info, c)\r\n        self.storage_cmd('storage
      container metadata show -n {}', account_info, c) \\\r\n            .assert_with_checks(JMESPathCheck('foo',
      'bar'), JMESPathCheck('moo', 'bak'))\r\n        self.storage_cmd('storage container
      metadata update -n {}', account_info, c)\r\n        self.storage_cmd('storage
      container metadata show -n {}', account_info, c) \\\r\n            .assert_with_checks(NoneCheck())\r\n\r\n
      \       # test lease operations\r\n        self.storage_cmd('storage container
      lease acquire --lease-duration 60 -c {} '\r\n                         '--if-modified-since
      {} --proposed-lease-id {}', account_info, c, date,\r\n                         proposed_lease_id)\r\n
      \       self.storage_cmd('storage container show --name {}', account_info, c)
      \\\r\n            .assert_with_checks(JMESPathCheck('properties.lease.duration',
      'fixed'),\r\n                                JMESPathCheck('properties.lease.state',
      'leased'),\r\n                                JMESPathCheck('properties.lease.status',
      'locked'))\r\n        self.storage_cmd('storage container lease change -c {}
      --lease-id {} '\r\n                         '--proposed-lease-id {}', account_info,
      c, proposed_lease_id, new_lease_id)\r\n        self.storage_cmd('storage container
      lease renew -c {} --lease-id {}',\r\n                         account_info,
      c, new_lease_id)\r\n        self.storage_cmd('storage container show -n {}',
      account_info, c) \\\r\n            .assert_with_checks(JMESPathCheck('properties.lease.duration',
      'fixed'),\r\n                                JMESPathCheck('properties.lease.state',
      'leased'),\r\n                                JMESPathCheck('properties.lease.status',
      'locked'))\r\n        self.storage_cmd('storage container lease break -c {}
      --lease-break-period 30',\r\n                         account_info, c)\r\n        self.storage_cmd('storage
      container show --name {}', account_info, c) \\\r\n            .assert_with_checks(JMESPathCheck('properties.lease.duration',
      None),\r\n                                JMESPathCheck('properties.lease.state',
      'breaking'),\r\n                                JMESPathCheck('properties.lease.status',
      'locked'))\r\n        self.storage_cmd('storage container lease release -c {}
      --lease-id {}', account_info, c,\r\n                         new_lease_id)\r\n
      \       self.storage_cmd('storage container show --name {}', account_info, c)
      \\\r\n            .assert_with_checks(JMESPathCheck('properties.lease.duration',
      None),\r\n                                JMESPathCheck('properties.lease.state',
      'available'),\r\n                                JMESPathCheck('properties.lease.status',
      'unlocked'))\r\n\r\n        from datetime import datetime, timedelta\r\n        expiry
      = (datetime.utcnow() + timedelta(hours=1)).strftime('%Y-%m-%dT%H:%MZ')\r\n        self.assertIn('sig=',
      self.storage_cmd('storage container generate-sas -n {} --permissions r --expiry
      {}',\r\n                                               account_info, c, expiry).output)\r\n\r\n
      \       # verify delete operation\r\n        self.storage_cmd('storage container
      delete --name {} --fail-not-exist', account_info, c) \\\r\n            .assert_with_checks(JMESPathCheck('deleted',
      True))\r\n        self.storage_cmd('storage container exists -n {}', account_info,
      c) \\\r\n            .assert_with_checks(JMESPathCheck('exists', False))\r\n\r\n
      \   @ResourceGroupPreparer()\r\n    @StorageAccountPreparer(kind='StorageV2')\r\n
      \   def test_storage_blob_soft_delete(self, resource_group, storage_account_info):\r\n
      \       container = self.create_container(storage_account_info)\r\n        import
      time\r\n\r\n        # create a blob\r\n        local_file = self.create_temp_file(1)\r\n
      \       blob_name = self.create_random_name(prefix='blob', length=24)\r\n\r\n
      \       self.storage_cmd('storage blob upload -c {} -f \"{}\" -n {} --type block',
      storage_account_info,\r\n                         container, local_file, blob_name)\r\n
      \       self.assertEqual(len(self.storage_cmd('storage blob list -c {}',\r\n
      \                                             storage_account_info, container).get_output_in_json()),
      1)\r\n\r\n        # set delete-policy to enable soft-delete\r\n        self.storage_cmd('storage
      blob service-properties delete-policy update --enable true --days-retained 2',\r\n
      \                        storage_account_info)\r\n        self.storage_cmd('storage
      blob service-properties delete-policy show',\r\n                         storage_account_info).assert_with_checks(JMESPathCheck('enabled',
      True),\r\n                                                                  JMESPathCheck('days',
      2))\r\n        time.sleep(10)\r\n        # soft-delete and check\r\n        self.storage_cmd('storage
      blob delete -c {} -n {}', storage_account_info, container, blob_name)\r\n        self.assertEqual(len(self.storage_cmd('storage
      blob list -c {}',\r\n                                              storage_account_info,
      container).get_output_in_json()), 0)\r\n\r\n        time.sleep(30)\r\n        self.assertEqual(len(self.storage_cmd('storage
      blob list -c {} --include d',\r\n                                              storage_account_info,
      container).get_output_in_json()), 1)\r\n\r\n        # undelete and check\r\n
      \       self.storage_cmd('storage blob undelete -c {} -n {}', storage_account_info,
      container, blob_name)\r\n        self.assertEqual(len(self.storage_cmd('storage
      blob list -c {}',\r\n                                              storage_account_info,
      container).get_output_in_json()), 1)\r\n\r\n    @ResourceGroupPreparer()\r\n
      \   @StorageAccountPreparer()\r\n    def test_storage_blob_append(self, resource_group,
      storage_account):\r\n        account_info = self.get_account_info(resource_group,
      storage_account)\r\n        container = self.create_container(account_info)\r\n\r\n
      \       # create an append blob\r\n        local_file = self.create_temp_file(1)\r\n
      \       blob_name = self.create_random_name(prefix='blob', length=24)\r\n\r\n
      \       self.storage_cmd('storage blob upload -c {} -f \"{}\" -n {} --type append
      --if-none-match *', account_info,\r\n                         container, local_file,
      blob_name)\r\n        self.assertEqual(len(self.storage_cmd('storage blob list
      -c {}',\r\n                                              account_info, container).get_output_in_json()),
      1)\r\n\r\n        # append if-none-match should throw exception\r\n        with
      self.assertRaises(Exception):\r\n            self.storage_cmd('storage blob
      upload -c {} -f \"{}\" -n {} --type append --if-none-match *', account_info,\r\n
      \                            container, local_file, blob_name)\r\n\r\n    @ResourceGroupPreparer()\r\n
      \   def test_storage_blob_update_service_properties(self, resource_group):\r\n
      \       storage_account = self.create_random_name(prefix='account', length=24)\r\n\r\n
      \       self.cmd('storage account create -n {} -g {} --kind StorageV2'.format(storage_account,
      resource_group))\r\n        account_info = self.get_account_info(resource_group,
      storage_account)\r\n\r\n        self.storage_cmd('storage blob service-properties
      show', account_info) \\\r\n            .assert_with_checks(JMESPathCheck('staticWebsite.enabled',
      False),\r\n                                JMESPathCheck('hourMetrics.enabled',
      True),\r\n                                JMESPathCheck('minuteMetrics.enabled',
      False),\r\n                                JMESPathCheck('minuteMetrics.includeApis',
      None),\r\n                                JMESPathCheck('logging.delete', False))\r\n\r\n
      \       self.storage_cmd('storage blob service-properties update --static-website
      --index-document index.html '\r\n                         '--404-document error.html',
      account_info)\r\n\r\n        self.storage_cmd('storage blob service-properties
      update --delete-retention --delete-retention-period 1',\r\n                         account_info)\r\n\r\n
      \       self.storage_cmd('storage blob service-properties update --set hourMetrics.enabled=false',\r\n
      \                        account_info)\r\n\r\n        self.storage_cmd('storage
      blob service-properties update --set minuteMetrics.enabled=true minuteMetrics.includeApis=true',\r\n
      \                        account_info)\r\n\r\n        self.storage_cmd('storage
      blob service-properties update --set logging.delete=true',\r\n                         account_info)\r\n\r\n
      \       self.storage_cmd('storage blob service-properties show', account_info)
      \\\r\n            .assert_with_checks(JMESPathCheck('staticWebsite.enabled',
      True),\r\n                                JMESPathCheck('staticWebsite.errorDocument_404Path',
      'error.html'),\r\n                                JMESPathCheck('staticWebsite.indexDocument',
      'index.html'),\r\n                                JMESPathCheck('deleteRetentionPolicy.enabled',
      True),\r\n                                JMESPathCheck('deleteRetentionPolicy.days',
      1),\r\n                                JMESPathCheck('hourMetrics.enabled',
      False),\r\n                                JMESPathCheck('minuteMetrics.enabled',
      True),\r\n                                JMESPathCheck('minuteMetrics.includeApis',
      True),\r\n                                JMESPathCheck('logging.delete', True))\r\n\r\n
      \   @ResourceGroupPreparer()\r\n    @StorageAccountPreparer()\r\n    def test_storage_blob_copy_cancel_nopendingcopyoperation_error(self,
      resource_group, storage_account):\r\n        account_info = self.get_account_info(resource_group,
      storage_account)\r\n        c = self.create_container(account_info)\r\n        b
      = self.create_random_name('blob', 24)\r\n        local_file = self.create_temp_file(1)\r\n
      \       copy_id = 'abcdabcd-abcd-abcd-abcd-abcdabcdabcd'\r\n\r\n        self.storage_cmd('storage
      blob upload -c {} -n {} -f \"{}\"', account_info, c, b, local_file)\r\n        from
      azure.common import AzureException\r\n        with self.assertRaisesRegex(AzureException,
      \"NoPendingCopyOperation\"):\r\n            self.storage_cmd('storage blob copy
      cancel -c {} -b {} --copy-id {}', account_info, c, b, copy_id)\r\n\r\n    @ResourceGroupPreparer()\r\n
      \   @StorageAccountPreparer()\r\n    def test_storage_blob_generate_sas_full_uri(self,
      resource_group, storage_account):\r\n        account_info = self.get_account_info(resource_group,
      storage_account)\r\n        c = self.create_container(account_info)\r\n        b
      = self.create_random_name('blob', 24)\r\n\r\n        expiry = (datetime.utcnow()
      + timedelta(hours=1)).strftime('%Y-%m-%dT%H:%MZ')\r\n        blob_uri = self.storage_cmd('storage
      blob generate-sas -n {} -c {} --expiry {} --permissions '\r\n                                    'r
      --https-only --full-uri', account_info, b, c, expiry).output\r\n        self.assertTrue(blob_uri)\r\n
      \       self.assertIn('&sig=', blob_uri)\r\n        self.assertTrue(blob_uri.startswith('\"https://{}.blob.core.windows.net/{}/{}?s'.format(storage_account,
      c, b)))\r\n\r\n    @ResourceGroupPreparer()\r\n    @StorageAccountPreparer()\r\n
      \   def test_storage_blob_generate_sas_as_user(self, resource_group, storage_account):\r\n
      \       account_info = self.get_account_info(resource_group, storage_account)\r\n
      \       c = self.create_container(account_info)\r\n        b = self.create_random_name('blob',
      24)\r\n\r\n        expiry = (datetime.utcnow() + timedelta(hours=1)).strftime('%Y-%m-%dT%H:%MZ')\r\n\r\n
      \       with self.assertRaisesRegex(CLIError, \"incorrect usage: specify --as-user
      when --auth-mode login\"):\r\n            self.cmd('storage blob generate-sas
      --account-name {} -n {} -c {} --expiry {} --permissions r --https-only '\r\n
      \                    '--auth-mode login'.format(storage_account, b, c, expiry))\r\n\r\n
      \       blob_sas = self.cmd('storage blob generate-sas --account-name {} -n
      {} -c {} --expiry {} --permissions '\r\n                            'r --https-only
      --as-user --auth-mode login'.format(storage_account, b, c, expiry)).output\r\n
      \       self.assertIn('&sig=', blob_sas)\r\n        self.assertIn('skoid=',
      blob_sas)\r\n        self.assertIn('sktid=', blob_sas)\r\n        self.assertIn('skt=',
      blob_sas)\r\n        self.assertIn('ske=', blob_sas)\r\n        self.assertIn('sks=',
      blob_sas)\r\n        self.assertIn('skv=', blob_sas)\r\n\r\n        container_sas
      = self.cmd('storage container generate-sas --account-name {} -n {} --expiry
      {} --permissions '\r\n                                 'r --https-only --as-user
      --auth-mode login'.format(storage_account, c, expiry)).output\r\n        self.assertIn('&sig=',
      container_sas)\r\n        self.assertIn('skoid=', container_sas)\r\n        self.assertIn('sktid=',
      container_sas)\r\n        self.assertIn('skt=', container_sas)\r\n        self.assertIn('ske=',
      container_sas)\r\n        self.assertIn('sks=', container_sas)\r\n        self.assertIn('skv=',
      container_sas)\r\n        self.assertIn('skv=', container_sas)\r\n\r\n    @ResourceGroupPreparer()\r\n
      \   @StorageAccountPreparer()\r\n    @api_version_constraint(resource_type=ResourceType.DATA_STORAGE_BLOB,
      min_api='2019-02-02')\r\n    def test_storage_blob_suppress_400(self, resource_group,
      storage_account):\r\n        account_info = self.get_account_info(resource_group,
      storage_account)\r\n        # test for azure.cli.command_modules.storage.StorageCommandGroup.get_handler_suppress_some_400\r\n
      \       # test 404\r\n        with self.assertRaises(SystemExit) as ex:\r\n
      \           self.storage_cmd('storage blob show -c foo -n bar.txt', account_info)\r\n
      \       self.assertEqual(ex.exception.code, 3)\r\n\r\n        # test 403\r\n
      \       from azure.core.exceptions import ClientAuthenticationError\r\n        with
      self.assertRaisesRegex(ClientAuthenticationError, \"Authentication failure\"):\r\n
      \           self.cmd('storage blob show --account-name {} --account-key=\"YQ==\"
      -c foo -n bar.txt '.format(storage_account))\r\n\r\n\r\n@api_version_constraint(ResourceType.DATA_STORAGE_BLOB,
      min_api='2019-02-02')\r\nclass StorageBlobSetTierTests(StorageScenarioMixin,
      ScenarioTest):\r\n\r\n    @ResourceGroupPreparer()\r\n    @StorageAccountPreparer(kind='StorageV2',
      sku='Premium_LRS')\r\n    def test_storage_page_blob_set_tier(self, resource_group,
      storage_account):\r\n\r\n        source_file = self.create_temp_file(16)\r\n
      \       account_info = self.get_account_info(resource_group, storage_account)\r\n
      \       container_name = self.create_container(account_info)\r\n        blob_name
      = self.create_random_name(prefix='blob', length=24)\r\n\r\n        self.storage_cmd('storage
      blob upload -c {} -n {} -f \"{}\" -t page --tier P10', account_info,\r\n                         container_name,
      blob_name, source_file)\r\n\r\n        self.storage_cmd('az storage blob show
      -c {} -n {} ', account_info, container_name, blob_name)\\\r\n            .assert_with_checks(JMESPathCheck('properties.blobTier',
      'P10'))\r\n\r\n        with self.assertRaises(SystemExit):\r\n            self.storage_cmd('storage
      blob set-tier -c {} -n {} --tier P20 -r High -t page', account_info,\r\n                             container_name,
      blob_name)\r\n\r\n        self.storage_cmd('storage blob set-tier -c {} -n {}
      --tier P20 -t page', account_info,\r\n                         container_name,
      blob_name)\r\n\r\n        self.storage_cmd('az storage blob show -c {} -n {}
      ', account_info, container_name, blob_name)\\\r\n            .assert_with_checks(JMESPathCheck('properties.blobTier',
      'P20'))\r\n\r\n    @ResourceGroupPreparer()\r\n    @StorageAccountPreparer(kind='StorageV2')\r\n
      \   def test_storage_block_blob_set_tier(self, resource_group, storage_account):\r\n\r\n
      \       source_file = self.create_temp_file(16)\r\n        account_info = self.get_account_info(resource_group,
      storage_account)\r\n        container_name = self.create_container(account_info)\r\n\r\n
      \       # test rehydrate from Archive to Cool by High priority\r\n        blob_name
      = self.create_random_name(prefix='blob', length=24)\r\n\r\n        self.storage_cmd('storage
      blob upload -c {} -n {} -f \"{}\"', account_info,\r\n                         container_name,
      blob_name, source_file)\r\n\r\n        with self.assertRaises(SystemExit):\r\n
      \           self.storage_cmd('storage blob set-tier -c {} -n {} --tier Cool
      -r Middle', account_info,\r\n                             container_name, blob_name)\r\n\r\n
      \       with self.assertRaises(SystemExit):\r\n            self.storage_cmd('storage
      blob set-tier -c {} -n {} --tier Archive -r High', account_info,\r\n                             container_name,
      blob_name)\r\n\r\n        self.storage_cmd('storage blob set-tier -c {} -n {}
      --tier Archive', account_info,\r\n                         container_name, blob_name)\r\n\r\n
      \       self.storage_cmd('az storage blob show -c {} -n {} ', account_info,
      container_name, blob_name) \\\r\n            .assert_with_checks(JMESPathCheck('properties.blobTier',
      'Archive'))\r\n\r\n        self.storage_cmd('storage blob set-tier -c {} -n
      {} --tier Cool -r High', account_info,\r\n                         container_name,
      blob_name)\r\n\r\n        self.storage_cmd('az storage blob show -c {} -n {}
      ', account_info, container_name, blob_name) \\\r\n            .assert_with_checks(JMESPathCheck('properties.blobTier',
      'Archive'),\r\n                                JMESPathCheck('properties.rehydrationStatus',
      'rehydrate-pending-to-cool'))\r\n\r\n        # test rehydrate from Archive to
      Hot by Standard priority\r\n        blob_name2 = self.create_random_name(prefix='blob',
      length=24)\r\n\r\n        self.storage_cmd('storage blob upload -c {} -n {}
      -f \"{}\"', account_info,\r\n                         container_name, blob_name2,
      source_file)\r\n\r\n        self.storage_cmd('storage blob set-tier -c {} -n
      {} --tier Archive', account_info,\r\n                         container_name,
      blob_name2)\r\n\r\n        self.storage_cmd('az storage blob show -c {} -n {}
      ', account_info, container_name, blob_name2) \\\r\n            .assert_with_checks(JMESPathCheck('properties.blobTier',
      'Archive'))\r\n\r\n        self.storage_cmd('storage blob set-tier -c {} -n
      {} --tier Hot', account_info,\r\n                         container_name, blob_name2)\r\n\r\n
      \       self.storage_cmd('az storage blob show -c {} -n {} ', account_info,
      container_name, blob_name2) \\\r\n            .assert_with_checks(JMESPathCheck('properties.blobTier',
      'Archive'),\r\n                                JMESPathCheck('properties.rehydrationStatus',
      'rehydrate-pending-to-hot'))\r\n\r\n\r\n@api_version_constraint(ResourceType.DATA_STORAGE_BLOB,
      min_api='2020-10-02')\r\nclass StorageBlobImmutabilityTests(StorageScenarioMixin,
      ScenarioTest):\r\n    @ResourceGroupPreparer(name_prefix='clitest')\r\n    @StorageAccountPreparer(name_prefix='version',
      kind='StorageV2', location='centraluseuap')\r\n    def test_storage_blob_vlm(self,
      resource_group, storage_account_info):\r\n        container = self.create_random_name(prefix='container',
      length=18)\r\n        blob = self.create_random_name(prefix='blob', length=18)\r\n
      \       self.kwargs.update({\r\n            'container': container,\r\n            'blob':
      blob\r\n        })\r\n        # Enable blob versioning\r\n        self.cmd('storage
      account blob-service-properties update -n {sa} -g {rg} --enable-versioning')\r\n
      \       # Enable vlm on container creation\r\n        self.cmd('storage container-rm
      create -n {container} --storage-account {sa} -g {rg} --enable-vlw')\r\n        #
      Prepare blob resource\r\n        file = self.create_temp_file(10)\r\n        self.storage_cmd('storage
      blob upload -c {} -f \"{}\" -n {} ', storage_account_info, container, file,
      blob)\r\n\r\n        # Test set immutability policy\r\n        from datetime
      import datetime, timedelta\r\n        expiry = (datetime.utcnow() + timedelta(hours=1)).strftime('%Y-%m-%dT%H:%MZ')\r\n
      \       result = self.storage_cmd('storage blob immutability-policy set -n {}
      -c {} '\r\n                                  '--expiry-time {} --policy-mode
      Unlocked',\r\n                                  storage_account_info, blob,
      container, expiry).get_output_in_json()\r\n        self.assertEqual(result.get('immutability_policy_mode'),
      'unlocked')\r\n        self.assertIsNotNone(result.get('immutability_policy_until_date'))\r\n
      \       # Test delete immutability policy\r\n        self.storage_cmd('storage
      blob immutability-policy delete -n {} -c {}', storage_account_info, blob, container)\r\n
      \       # Test set legal hold\r\n        self.storage_cmd('storage blob set-legal-hold
      --legal-hold -n {} -c {}', storage_account_info, blob, container)\\\r\n            .assert_with_checks(JMESPathCheck('legal_hold',
      True))\r\n        self.storage_cmd('storage blob set-legal-hold --legal-hold
      false -n {} -c {}', storage_account_info, blob, container) \\\r\n            .assert_with_checks(JMESPathCheck('legal_hold',
      False))\r\n\r\n\r\n@api_version_constraint(ResourceType.DATA_STORAGE_BLOB, min_api='2019-02-02')\r\nclass
      StorageBlobCommonTests(StorageScenarioMixin, ScenarioTest):\r\n    @ResourceGroupPreparer(name_prefix='clitest')\r\n
      \   @StorageAccountPreparer(name_prefix='storage', kind='StorageV2', location='eastus2',
      sku='Standard_RAGZRS')\r\n    def test_storage_blob_list_scenarios(self, resource_group,
      storage_account):\r\n        account_info = self.get_account_info(resource_group,
      storage_account)\r\n        container = self.create_container(account_info,
      prefix=\"con\")\r\n\r\n        local_file = self.create_temp_file(128)\r\n        blob_name1
      = \"/\".join([\"dir\", self.create_random_name(prefix='blob', length=24)])\r\n
      \       blob_name2 = \"/\".join([\"dir\", self.create_random_name(prefix='blob',
      length=24)])\r\n\r\n        # Prepare blob 1\r\n        self.storage_cmd('storage
      blob upload -c {} -f \"{}\" -n {} ', account_info,\r\n                         container,
      local_file, blob_name1)\r\n        # Test\r\n        self.storage_cmd('storage
      blob list -c {} ', account_info, container) \\\r\n            .assert_with_checks(JMESPathCheck('[0].objectReplicationDestinationPolicy',
      None),\r\n                                JMESPathCheck('[0].objectReplicationSourceProperties',
      []))\r\n\r\n        # Test with include snapshot\r\n        result = self.storage_cmd('storage
      blob snapshot -c {} -n {} ', account_info, container, blob_name1)\\\r\n            .get_output_in_json()\r\n
      \       self.assertIsNotNone(result['snapshot'])\r\n        snapshot = result['snapshot']\r\n\r\n
      \       self.storage_cmd('storage blob list -c {} --include s', account_info,
      container) \\\r\n            .assert_with_checks(JMESPathCheck('[0].snapshot',
      snapshot))\r\n\r\n        # Test with include metadata\r\n        self.storage_cmd('storage
      blob metadata update -c {} -n {} --metadata test=1 ', account_info,\r\n                         container,
      blob_name1)\r\n        self.storage_cmd('storage blob metadata show -c {} -n
      {} ', account_info, container, blob_name1)\\\r\n            .assert_with_checks(JMESPathCheck('test',
      '1'))\r\n\r\n        self.storage_cmd('storage blob list -c {} --include m',
      account_info, container) \\\r\n            .assert_with_checks(JMESPathCheck('[0].metadata.test',
      '1'))\r\n\r\n        # Prepare blob 2\r\n        self.storage_cmd('storage blob
      upload -c {} -f \"{}\" -n {} ', account_info,\r\n                         container,
      local_file, blob_name2)\r\n\r\n        self.storage_cmd('storage blob list -c
      {} ', account_info, container).assert_with_checks(\r\n            JMESPathCheck('length(@)',
      2)\r\n        )\r\n\r\n        # Test num_results and next marker\r\n        self.storage_cmd('storage
      blob list -c {} --num-results 1 ', account_info, container).assert_with_checks(\r\n
      \           JMESPathCheck('length(@)', 1))\r\n\r\n        result = self.storage_cmd('storage
      blob list -c {} --num-results 1 --show-next-marker',\r\n                                  account_info,
      container).get_output_in_json()\r\n        self.assertIsNotNone(result[1]['nextMarker'])\r\n
      \       next_marker = result[1]['nextMarker']\r\n\r\n        # Test with marker\r\n
      \       self.storage_cmd('storage blob list -c {} --marker {} ', account_info,
      container, next_marker) \\\r\n            .assert_with_checks(JMESPathCheck('length(@)',
      1))\r\n\r\n        # Test with prefix\r\n        self.storage_cmd('storage blob
      list -c {} --prefix {}', account_info, container, 'dir/') \\\r\n            .assert_with_checks(JMESPathCheck('length(@)',
      2))\r\n\r\n        # Test with delimiter\r\n        self.storage_cmd('storage
      blob list -c {} --delimiter \"/\"', account_info, container) \\\r\n            .assert_with_checks(JMESPathCheck('length(@)',
      1),\r\n                                JMESPathCheck('[0].name', 'dir/'))\r\n\r\n
      \       # Test with custom delimiter\r\n        self.storage_cmd('storage blob
      list -c {} --delimiter \"ir\"', account_info, container) \\\r\n            .assert_with_checks(JMESPathCheck('length(@)',
      1),\r\n                                JMESPathCheck('[0].name', 'dir'))\r\n\r\n
      \       # Test secondary location\r\n        account_name = account_info[0]
      + '-secondary'\r\n        account_key = account_info[1]\r\n        self.cmd('storage
      blob list -c {} --account-name {} --account-key {} '.format(\r\n            container,
      account_name, account_key)).assert_with_checks(\r\n            JMESPathCheck('length(@)',
      2))\r\n\r\n\r\n@api_version_constraint(ResourceType.MGMT_STORAGE, min_api='2019-06-01')\r\nclass
      StorageBlobPITRTests(StorageScenarioMixin, ScenarioTest):\r\n    @AllowLargeResponse()\r\n
      \   @ResourceGroupPreparer(name_prefix=\"storage_blob_restore\", location=\"centraluseuap\")\r\n
      \   @StorageAccountPreparer(name_prefix=\"restore\", kind=\"StorageV2\", sku='Standard_LRS',
      location=\"centraluseuap\")\r\n    def test_storage_blob_restore(self, resource_group,
      storage_account):\r\n        import time\r\n        # Enable Policy\r\n        self.cmd('storage
      account blob-service-properties update --enable-change-feed --enable-delete-retention
      --delete-retention-days 2 --enable-versioning -n {sa}')\\\r\n            .assert_with_checks(JMESPathCheck('changeFeed.enabled',
      True),\r\n                                JMESPathCheck('deleteRetentionPolicy.enabled',
      True),\r\n                                JMESPathCheck('deleteRetentionPolicy.days',
      2))\r\n\r\n        self.cmd('storage account blob-service-properties update
      --enable-restore-policy --restore-days 1 -n {sa} ')\r\n\r\n        c1 = self.create_random_name(prefix='containera',
      length=24)\r\n        c2 = self.create_random_name(prefix='containerb', length=24)\r\n
      \       b1 = self.create_random_name(prefix='blob1', length=24)\r\n        b2
      = self.create_random_name(prefix='blob2', length=24)\r\n        b3 = self.create_random_name(prefix='blob3',
      length=24)\r\n        b4 = self.create_random_name(prefix='blob4', length=24)\r\n\r\n
      \       local_file = self.create_temp_file(256)\r\n\r\n        account_key =
      self.cmd('storage account keys list -n {} -g {} --query \"[0].value\" -otsv'\r\n
      \                              .format(storage_account, resource_group)).output\r\n\r\n
      \       # Prepare containers and blobs\r\n        for container in [c1, c2]:\r\n
      \           self.cmd('storage container create -n {} --account-name {} --account-key
      {}'.format(\r\n                container, storage_account, account_key)) \\\r\n
      \               .assert_with_checks(JMESPathCheck('created', True))\r\n            for
      blob in [b1, b2, b3, b4]:\r\n                self.cmd('storage blob upload -c
      {} -f \"{}\" -n {} --account-name {} --account-key {}'.format(\r\n                    container,
      local_file, blob, storage_account, account_key))\r\n            self.cmd('storage
      blob list -c {} --account-name {} --account-key {}'.format(\r\n                container,
      storage_account, account_key)) \\\r\n                .assert_with_checks(JMESPathCheck('length(@)',
      4))\r\n\r\n            self.cmd('storage container delete -n {} --account-name
      {} --account-key {}'.format(\r\n                container, storage_account,
      account_key)) \\\r\n                .assert_with_checks(JMESPathCheck('deleted',
      True))\r\n\r\n        time.sleep(60)\r\n\r\n        # Restore blobs, with specific
      ranges\r\n        self.cmd('storage account blob-service-properties show -n
      {sa}') \\\r\n            .assert_with_checks(JMESPathCheck('restorePolicy.enabled',
      True),\r\n                                JMESPathCheck('restorePolicy.days',
      1),\r\n                                JMESPathCheckExists('restorePolicy.minRestoreTime'))\r\n\r\n
      \       time_to_restore = (datetime.utcnow() + timedelta(seconds=-5)).strftime('%Y-%m-%dT%H:%MZ')\r\n\r\n
      \       # c1/b1 -> c1/b2\r\n        start_range = '/'.join([c1, b1])\r\n        end_range
      = '/'.join([c1, b2])\r\n        self.cmd('storage blob restore -t {} -r {} {}
      --account-name {} -g {}'.format(\r\n            time_to_restore, start_range,
      end_range, storage_account, resource_group), checks=[\r\n            JMESPathCheck('status',
      'Complete'),\r\n            JMESPathCheck('parameters.blobRanges[0].startRange',
      start_range),\r\n            JMESPathCheck('parameters.blobRanges[0].endRange',
      end_range)])\r\n\r\n        self.cmd('storage blob restore -t {} -r {} {} --account-name
      {} -g {} --no-wait'.format(\r\n            time_to_restore, start_range, end_range,
      storage_account, resource_group))\r\n\r\n        time.sleep(300)\r\n\r\n        time_to_restore
      = (datetime.utcnow() + timedelta(seconds=-5)).strftime('%Y-%m-%dT%H:%MZ')\r\n
      \       # c1/b2 -> c2/b3\r\n        start_range = '/'.join([c1, b2])\r\n        end_range
      = '/'.join([c2, b3])\r\n        self.cmd('storage blob restore -t {} -r {} {}
      --account-name {} -g {}'.format(\r\n            time_to_restore, start_range,
      end_range, storage_account, resource_group), checks=[\r\n            JMESPathCheck('status',
      'Complete'),\r\n            JMESPathCheck('parameters.blobRanges[0].startRange',
      start_range),\r\n            JMESPathCheck('parameters.blobRanges[0].endRange',
      end_range)])\r\n\r\n        time.sleep(120)\r\n        self.cmd('storage blob
      restore -t {} --account-name {} -g {} --no-wait'.format(\r\n            time_to_restore,
      storage_account, resource_group))\r\n\r\n\r\nclass StorageBlobCopyTestScenario(StorageScenarioMixin,
      ScenarioTest):\r\n    @ResourceGroupPreparer()\r\n    @StorageAccountPreparer(kind='storageV2')\r\n
      \   def test_storage_blob_copy_rehydrate_priority(self, resource_group, storage_account):\r\n
      \       source_file = self.create_temp_file(16)\r\n        account_info = self.get_account_info(resource_group,
      storage_account)\r\n\r\n        source_container = self.create_container(account_info)\r\n
      \       target_container = self.create_container(account_info)\r\n\r\n        self.storage_cmd('storage
      blob upload -c {} -f \"{}\" -n src ', account_info,\r\n                         source_container,
      source_file)\r\n        self.storage_cmd('storage blob set-tier -c {} -n {}
      --tier Archive', account_info,\r\n                         source_container,
      'src')\r\n        self.storage_cmd('az storage blob show -c {} -n {} ', account_info,
      source_container, 'src') \\\r\n            .assert_with_checks(JMESPathCheck('properties.blobTier',
      'Archive'))\r\n\r\n        source_uri = self.storage_cmd('storage blob url -c
      {} -n src', account_info, source_container).output\r\n\r\n        self.storage_cmd('storage
      blob copy start -b dst -c {} --source-uri {} --tier Cool -r High', account_info,\r\n
      \                        target_container, source_uri)\r\n        self.storage_cmd('storage
      blob show -c {} -n {} ', account_info, target_container, 'dst') \\\r\n            .assert_with_checks(JMESPathCheck('properties.blobTier',
      'Archive'),\r\n                                JMESPathCheck('properties.rehydrationStatus',
      'rehydrate-pending-to-cool'))\r\n\r\n    @AllowLargeResponse()\r\n    @ResourceGroupPreparer(name_prefix='clitest')\r\n
      \   @StorageAccountPreparer(kind='StorageV2', name_prefix='clitest', location='centraluseuap')\r\n
      \   def test_storage_container_vlm_scenarios(self, resource_group, storage_account):\r\n
      \       self.kwargs.update({\r\n            'container1': self.create_random_name(prefix='con1',
      length=10),\r\n            'container2': self.create_random_name(prefix='con2',
      length=10)\r\n        })\r\n        self.cmd('storage account blob-service-properties
      update -n {sa} -g {rg} --enable-versioning ',\r\n                 checks={\r\n
      \                    JMESPathCheck('isVersioningEnabled', True)\r\n                 })\r\n
      \       # Enable vlm when creation\r\n        self.cmd('storage container-rm
      create -n {container1} --storage-account {sa} -g {rg} --enable-vlw',\r\n                 checks={\r\n
      \                    JMESPathCheck('name', self.kwargs['container1']),\r\n                     JMESPathCheck('immutableStorageWithVersioning.enabled',
      True),\r\n                     JMESPathCheck('immutableStorageWithVersioning.migrationState',
      None)})\r\n        self.cmd('storage container-rm show -n {container1} --storage-account
      {sa} -g {rg}',\r\n                 checks={\r\n                     JMESPathCheck('name',
      self.kwargs['container1']),\r\n                     JMESPathCheck('immutableStorageWithVersioning.enabled',
      True),\r\n                     JMESPathCheck('immutableStorageWithVersioning.migrationState',
      None)})\r\n\r\n        # Enable vlm for containers with immutability policy\r\n
      \       self.cmd('storage container-rm create -n {container2} --storage-account
      {sa} -g {rg}',\r\n                 checks={\r\n                     JMESPathCheck('name',
      self.kwargs['container2']),\r\n                     JMESPathCheck('immutableStorageWithVersioning.enabled',
      None)})\r\n\r\n        self.cmd('storage container immutability-policy create
      -c {container2} --account-name {sa} -g {rg} -w --period 1',\r\n                 checks={\r\n
      \                    JMESPathCheck('name', self.kwargs['container2']),\r\n                     JMESPathCheck('immutabilityPeriodSinceCreationInDays',
      1)})\r\n\r\n        self.cmd('storage container-rm migrate-vlw -n {container2}
      --storage-account {sa} -g {rg} --no-wait')\r\n        self.cmd('storage container-rm
      show -n {container2} --storage-account {sa} -g {rg}',\r\n                 checks={\r\n
      \                    JMESPathCheck('name', self.kwargs['container2']),\r\n                     JMESPathCheck('immutableStorageWithVersioning.enabled',
      False),\r\n                     JMESPathCheck('immutableStorageWithVersioning.migrationState',
      'InProgress')})\r\n\r\n\r\nclass StorageContainerScenarioTest(StorageScenarioMixin,
      ScenarioTest):\r\n    @ResourceGroupPreparer(name_prefix='clitest')\r\n    @StorageAccountPreparer(kind='StorageV2',
      name_prefix='clitest', location='eastus2euap')\r\n    def test_storage_container_list_scenarios(self,
      resource_group, storage_account):\r\n        account_info = self.get_account_info(resource_group,
      storage_account)\r\n        container1 = self.create_container(account_info,
      prefix=\"con1\")\r\n        container2 = self.create_container(account_info,
      prefix=\"con2\")\r\n        self.cmd('storage account blob-service-properties
      update -n {sa} -g {rg} --container-delete-retention-days 7 '\r\n                 '--enable-container-delete-retention',\r\n
      \                checks={\r\n                     JMESPathCheck('containerDeleteRetentionPolicy.days',
      7),\r\n                     JMESPathCheck('containerDeleteRetentionPolicy.enabled',
      True)\r\n                 })\r\n        self.storage_cmd('storage container
      list ', account_info) \\\r\n            .assert_with_checks(JMESPathCheck('length(@)',
      2))\r\n\r\n        # Test with include metadata\r\n        self.storage_cmd('storage
      container metadata update -n {} --metadata test=1 ', account_info, container1)\r\n
      \       self.storage_cmd('storage container metadata show -n {} ', account_info,
      container1)\\\r\n            .assert_with_checks(JMESPathCheck('test', '1'))\r\n\r\n
      \       self.storage_cmd('storage container list --include-metadata', account_info,
      container1) \\\r\n            .assert_with_checks(JMESPathCheck('[0].metadata.test',
      '1'))\r\n\r\n        # Test num_results and next marker\r\n        self.storage_cmd('storage
      container list --num-results 1 ', account_info).assert_with_checks(\r\n            JMESPathCheck('length(@)',
      1))\r\n\r\n        result = self.storage_cmd('storage container list --num-results
      1 --show-next-marker',\r\n                                  account_info).get_output_in_json()\r\n
      \       self.assertIsNotNone(result[1]['nextMarker'])\r\n        next_marker
      = result[1]['nextMarker']\r\n\r\n        # Test with marker\r\n        self.storage_cmd('storage
      container list --marker {} ', account_info, next_marker) \\\r\n            .assert_with_checks(JMESPathCheck('length(@)',
      1))\r\n\r\n        # Test with prefix\r\n        self.storage_cmd('storage container
      list --prefix {}', account_info, 'con1') \\\r\n            .assert_with_checks(JMESPathCheck('length(@)',
      1))\r\n\r\n        # Test with include deleted\r\n        self.storage_cmd('storage
      container delete -n {} ', account_info, container2)\r\n        self.storage_cmd('storage
      container list ', account_info) \\\r\n            .assert_with_checks(JMESPathCheck('length(@)',
      1))\r\n        self.storage_cmd('storage container list --include-deleted ',
      account_info) \\\r\n            .assert_with_checks(JMESPathCheck('length(@)',
      2))\r\n\r\n    @ResourceGroupPreparer(name_prefix='clitest')\r\n    @StorageAccountPreparer(kind='StorageV2',
      name_prefix='clitest', location='eastus2euap')\r\n    def test_storage_container_soft_delete_scenarios(self,
      resource_group, storage_account):\r\n        import time\r\n        account_info
      = self.get_account_info(resource_group, storage_account)\r\n        container
      = self.create_container(account_info, prefix=\"con1\")\r\n        self.cmd('storage
      account blob-service-properties update -n {sa} -g {rg} --container-delete-retention-days
      7 '\r\n                 '--enable-container-delete-retention',\r\n                 checks={\r\n
      \                    JMESPathCheck('containerDeleteRetentionPolicy.days', 7),\r\n
      \                    JMESPathCheck('containerDeleteRetentionPolicy.enabled',
      True)\r\n                 })\r\n        self.storage_cmd('storage container
      list ', account_info) \\\r\n            .assert_with_checks(JMESPathCheck('length(@)',
      1))\r\n\r\n        self.storage_cmd('storage container delete -n {} ', account_info,
      container)\r\n        self.storage_cmd('storage container list ', account_info)
      \\\r\n            .assert_with_checks(JMESPathCheck('length(@)', 0))\r\n        self.storage_cmd('storage
      container list --include-deleted', account_info).assert_with_checks(\r\n            JMESPathCheck('length(@)',
      1),\r\n            JMESPathCheck('[0].deleted', True))\r\n\r\n        time.sleep(30)\r\n
      \       version = self.storage_cmd('storage container list --include-deleted
      --query [0].version -o tsv', account_info)\\\r\n            .output.strip('\\n')\r\n
      \       self.storage_cmd('storage container restore -n {} --deleted-version
      {}', account_info, container, version)\\\r\n            .assert_with_checks(JMESPathCheck('containerName',
      container))\r\n\r\n        self.storage_cmd('storage container list ', account_info)
      \\\r\n            .assert_with_checks(JMESPathCheck('length(@)', 1))\r\n        self.storage_cmd('storage
      container list --include-deleted ', account_info) \\\r\n            .assert_with_checks(JMESPathCheck('length(@)',
      1))\r\n\r\n\r\nif __name__ == '__main__':\r\n    unittest.main()\r\n"
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '55692'
      User-Agent:
      - Azure-Storage/2.0.0-2.0.1 (Python CPython 3.7.9; Windows 10) AZURECLI/2.33.1
      x-ms-blob-content-type:
      - text/x-python
      x-ms-blob-type:
      - BlockBlob
      x-ms-date:
      - Wed, 23 Feb 2022 03:37:27 GMT
      x-ms-version:
      - '2018-11-09'
    method: PUT
    uri: https://clitest000002.blob.core.windows.net/cont000003/blob000004
  response:
    body:
      string: ''
    headers:
      content-length:
      - '0'
      content-md5:
      - 0IoFOECiPwO00YdTy5fcmA==
      date:
      - Wed, 23 Feb 2022 03:37:28 GMT
      etag:
      - '"0x8D9F67DD150C690"'
      last-modified:
      - Wed, 23 Feb 2022 03:37:29 GMT
      server:
      - Windows-Azure-Blob/1.0 Microsoft-HTTPAPI/2.0
      x-ms-request-server-encrypted:
      - 'true'
      x-ms-version:
      - '2018-11-09'
    status:
      code: 201
      message: Created
- request:
    body: null
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '0'
      User-Agent:
      - Azure-Storage/2.0.0-2.0.1 (Python CPython 3.7.9; Windows 10) AZURECLI/2.33.1
      x-ms-date:
      - Wed, 23 Feb 2022 03:37:29 GMT
      x-ms-meta-a:
      - b
      x-ms-meta-c:
      - d
      x-ms-version:
      - '2018-11-09'
    method: PUT
    uri: https://clitest000002.blob.core.windows.net/cont000003/blob000004?comp=metadata
  response:
    body:
      string: ''
    headers:
      content-length:
      - '0'
      date:
      - Wed, 23 Feb 2022 03:37:29 GMT
      etag:
      - '"0x8D9F67DD2083C32"'
      last-modified:
      - Wed, 23 Feb 2022 03:37:30 GMT
      server:
      - Windows-Azure-Blob/1.0 Microsoft-HTTPAPI/2.0
      x-ms-request-server-encrypted:
      - 'true'
      x-ms-version:
      - '2018-11-09'
    status:
      code: 200
      message: OK
- request:
    body: null
    headers:
      Connection:
      - keep-alive
      User-Agent:
      - Azure-Storage/2.0.0-2.0.1 (Python CPython 3.7.9; Windows 10) AZURECLI/2.33.1
      x-ms-date:
      - Wed, 23 Feb 2022 03:37:30 GMT
      x-ms-version:
      - '2018-11-09'
    method: GET
    uri: https://clitest000002.blob.core.windows.net/cont000003/blob000004?comp=metadata
  response:
    body:
      string: ''
    headers:
      content-length:
      - '0'
      date:
      - Wed, 23 Feb 2022 03:37:31 GMT
      etag:
      - '"0x8D9F67DD2083C32"'
      last-modified:
      - Wed, 23 Feb 2022 03:37:30 GMT
      server:
      - Windows-Azure-Blob/1.0 Microsoft-HTTPAPI/2.0
      x-ms-meta-a:
      - b
      x-ms-meta-c:
      - d
      x-ms-version:
      - '2018-11-09'
    status:
      code: 200
      message: OK
- request:
    body: null
    headers:
      Connection:
      - keep-alive
      Content-Length:
      - '0'
      User-Agent:
      - Azure-Storage/2.0.0-2.0.1 (Python CPython 3.7.9; Windows 10) AZURECLI/2.33.1
      x-ms-date:
      - Wed, 23 Feb 2022 03:37:31 GMT
      x-ms-version:
      - '2018-11-09'
    method: PUT
    uri: https://clitest000002.blob.core.windows.net/cont000003/blob000004?comp=metadata
  response:
    body:
      string: ''
    headers:
      content-length:
      - '0'
      date:
      - Wed, 23 Feb 2022 03:37:32 GMT
      etag:
      - '"0x8D9F67DD3710DE1"'
      last-modified:
      - Wed, 23 Feb 2022 03:37:32 GMT
      server:
      - Windows-Azure-Blob/1.0 Microsoft-HTTPAPI/2.0
      x-ms-request-server-encrypted:
      - 'true'
      x-ms-version:
      - '2018-11-09'
    status:
      code: 200
      message: OK
- request:
    body: null
    headers:
      Connection:
      - keep-alive
      User-Agent:
      - Azure-Storage/2.0.0-2.0.1 (Python CPython 3.7.9; Windows 10) AZURECLI/2.33.1
      x-ms-date:
      - Wed, 23 Feb 2022 03:37:32 GMT
      x-ms-version:
      - '2018-11-09'
    method: GET
    uri: https://clitest000002.blob.core.windows.net/cont000003/blob000004?comp=metadata
  response:
    body:
      string: ''
    headers:
      content-length:
      - '0'
      date:
      - Wed, 23 Feb 2022 03:37:33 GMT
      etag:
      - '"0x8D9F67DD3710DE1"'
      last-modified:
      - Wed, 23 Feb 2022 03:37:32 GMT
      server:
      - Windows-Azure-Blob/1.0 Microsoft-HTTPAPI/2.0
      x-ms-version:
      - '2018-11-09'
    status:
      code: 200
      message: OK
version: 1
