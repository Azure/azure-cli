# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
#
# Code generated by aaz-dev-tools
# --------------------------------------------------------------------------------------------

# pylint: disable=too-many-lines
# pylint: disable=too-many-statements

provider_namespace = "Microsoft.Edge"
sub_provider = "Microsoft.EdgeMarketplace"
api_version = "2023-08-01-preview"


def _get_management_endpoint(cli_ctx):
    """Helper function to determine management endpoint based on cloud configuration."""
    cloud = cli_ctx.cloud
    # Remove ending slash if exists
    if cloud.endpoints.resource_manager.endswith("/"):
        cloud.endpoints.resource_manager = cloud.endpoints.resource_manager[:-1]

    # Append https:// if not exists
    if not cloud.endpoints.resource_manager.startswith("https://"):
        cloud.endpoints.resource_manager = "https://" + cloud.endpoints.resource_manager

    return cloud.endpoints.resource_manager


def _handle_directory_cleanup(version_level_path, logger):
    """Helper function to clean up existing directory."""
    import os
    import shutil

    if os.path.exists(version_level_path):
        try:
            # Remove directory and all its contents
            shutil.rmtree(version_level_path)
            logger.info("Cleaned up existing version directory: %s", version_level_path)
        except OSError as e:
            error_message = f"Failed to clean up directory {version_level_path}: {str(e)}"
            logger.error(error_message)
            return {
                "error": error_message,
                "status": "failed",
                "path": version_level_path,
            }
    return None


def _download_icons(icon_uris, icon_path, logger):
    """Helper function to download icons."""
    import os

    import requests

    for size, uri in icon_uris.items():
        file_extension = "png"
        file_path = os.path.join(icon_path, f"{size}.{file_extension}")

        # Skip if icon already exists
        if os.path.exists(file_path):
            logger.info("Icon %s already exists at %s, skipping download", size, file_path)
            continue

        try:
            logo_response = requests.get(uri)
            if logo_response.status_code == 200:
                with open(file_path, "wb") as f:
                    f.write(logo_response.content)
                logger.info("Downloaded %s logo to %s", size, file_path)
            else:
                logger.error("Failed to download %s logo: %s", size, logo_response.status_code)
        except requests.RequestException as e:
            logger.error("Error downloading %s logo: %s", size, str(e))


def _prepare_paths_and_metadata(output_folder, publisher_id, offer_id, sku, version_id, data, catalog_content, logger):
    """Helper function to prepare directories and save metadata."""
    import json
    import os

    # Create base path for this version
    base_path = os.path.join(output_folder, "catalog_artifacts", publisher_id, offer_id, sku)
    version_level_path = os.path.join(base_path, version_id)
    icon_path = os.path.join(base_path, "icons")

    # Clean up existing directory if needed
    cleanup_result = _handle_directory_cleanup(version_level_path, logger)
    if cleanup_result:
        return cleanup_result, None, None

    os.makedirs(icon_path, exist_ok=True)
    os.makedirs(version_level_path, exist_ok=True)

    # Save metadata.json
    metadata_path = os.path.join(base_path, "metadata.json")
    with open(metadata_path, "w", encoding="utf-8") as f:
        json.dump(catalog_content, f, indent=2)
        logger.info("Saved metadata to %s", metadata_path)

    return None, version_level_path, icon_path


def _find_sku_and_version(skus, sku, version, logger):
    """Helper function to find matching SKU and version."""
    for _sku in skus:
        sku_id = _sku.get("marketplaceSkuId", "")
        if sku_id != sku:
            continue

        # Store the generation information
        generation = _sku.get("generation")
        # Get all versions for this SKU
        versions = _sku.get("marketplaceSkuVersions", [])
        versions = [v for v in versions if v.get("name") == version]

        if not versions:
            logger.warning("No matching version found for SKU %s", sku_id)
            return None, None

        # print if version and generation are found
        print("Found VM version: %s" % versions[0].get('name'))
        print("VM Generation: %s" % generation)
        version_id = versions[0].get("name")
        return version_id, generation

    # If we get here, no matching SKU was found
    logger.warning("No matching SKU found: %s", sku)
    return None, None


def package_offer(cmd, resource_group_name, resource_name, publisher_name,
                  offer_id, sku, version, output_folder):
    """Get details of a specific marketplace offer and download its logos."""

    import requests
    from knack.log import get_logger

    from azure.cli.core.commands.client_factory import get_subscription_id
    from azure.cli.core.util import send_raw_request

    logger = get_logger(__name__)
    management_endpoint = _get_management_endpoint(cmd.cli_ctx)
    subscription_id = get_subscription_id(cmd.cli_ctx)
    catalog_api_version = "2021-06-01"
    # Construct URL with parameters
    url = (
        f"{management_endpoint}"
        f"/subscriptions/{subscription_id}"
        f"/resourceGroups/{resource_group_name}"
        f"/providers/{provider_namespace}/disconnectedOperations/{resource_name}"
        f"/providers/{sub_provider}/offers/{publisher_name}:{offer_id}"
        f"?api-version={api_version}"
    )

    catalog_url = (
        f"https://catalogapi.azure.com"
        f"/offers/{publisher_name}.{offer_id}"
        f"?api-version={catalog_api_version}"
    )

    try:
        response = send_raw_request(cmd.cli_ctx, "get", url, resource="https://management.azure.com")

        if response.status_code != 200:
            error_message = f"Request failed with status code: {response.status_code}"
            logger.error(error_message)
            return {
                "error": error_message,
                "status": "failed",
                "resource_group_name": resource_group_name,
                "response": response.text,
            }
        
        catalog_content =  requests.get(catalog_url)

        if catalog_content.status_code != 200:
            error_message = f"Catalog request failed with status code: {catalog_content.status_code}"
            logger.error(error_message)
            return {
                "error": error_message,
                "status": "failed",
                "response": catalog_content.text,
            }

        data = response.json()
        catalog_data = catalog_content.json()
        offer_content = data.get("properties", {}).get("offerContent", {})
        icon_uris = offer_content.get("iconFileUris", {})

        # Download logos and metadata if output folder is specified
        if output_folder:
            publisher_id = offer_content.get("offerPublisher", {}).get("publisherId", "")
            offer_id = offer_content.get("offerId", "")
            skus = data.get("properties", {}).get("marketplaceSkus", [])

            # Find matching SKU and version
            version_id, generation = _find_sku_and_version(skus, sku, version, logger)

            if not version_id:
                return

            # Prepare directories and save metadata
            result, version_level_path, icon_path = _prepare_paths_and_metadata(
                output_folder, publisher_id, offer_id, sku, version_id, data, catalog_data, logger
            )

            if result:  # Error occurred
                return result

            # Download icons
            if icon_uris:
                _download_icons(icon_uris, icon_path, logger)

            print("Metadata and icons downloaded successfully")
            print("Offer details retrieved successfully. Proceeding to download VHD.")

            # Downloading VM image
            return download_vhd(
                cmd, resource_group_name, resource_name, publisher_name,
                offer_id, sku, version, generation, version_level_path
            )

    except requests.RequestException as e:
        logger.error("Failed to retrieve offer: %s", str(e))
        return {
            "error": str(e),
            "status": "failed",
            "resource_group_name": resource_group_name,
        }


def _check_azcopy_available():
    """Check if azcopy is available in the system path."""
    import shutil
    import subprocess

    # First try using shutil.which which is the proper way to check for executables
    if shutil.which("azcopy"):
        return True

    # Fallback to trying the command directly
    try:
        result = subprocess.run(["azcopy", "--version"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=False)
        return result.returncode == 0
    except FileNotFoundError:
        return False


def _handle_token_response(token_response, output_folder, logger):
    """Helper function to handle token response and download."""
    import platform
    import subprocess

    download_url = token_response.get("accessToken")

    # Check if azcopy is available
    if not _check_azcopy_available():
        # Determine OS-specific download link
        system = platform.system().lower()
        if system == 'windows':
            azcopy_url = "https://aka.ms/downloadazcopy-v10-windows"
            install_instructions = "Download, extract the ZIP file, and add the extracted folder to your PATH."
        elif system == 'linux':
            azcopy_url = "https://aka.ms/downloadazcopy-v10-linux"
            install_instructions = "Download, extract the tar.gz file, and move the azcopy binary to a directory in your PATH."
        elif system == 'darwin':  # macOS
            azcopy_url = "https://aka.ms/downloadazcopy-v10-mac"
            install_instructions = "Download, extract the .zip file, and move the azcopy binary to a directory in your PATH."
        else:
            azcopy_url = "https://aka.ms/downloadazcopy"
            install_instructions = "Download and install AzCopy for your platform."

        error_message = (
            f"AzCopy tool not found. Please install AzCopy for your {system} system and make sure it's available in your PATH.\n"
            f"Download link: {azcopy_url}\n"
            f"Installation: {install_instructions}"
        )
        logger.error(error_message)
        return {
            "error": error_message,
            "status": "failed",
            "download_url": azcopy_url
        }

    # Construct and execute azcopy command
        
    print(f"Executing: azcopy copy [URL] {output_folder} --check-md5 NoCheck")
    print("Executing command...")

    # This will display output in real-time (just like os.system)
    result = subprocess.run(
        ["azcopy", "copy", download_url, output_folder, "--check-md5", "NoCheck"],
        check=False  # Don't raise exception on non-zero exit
    )

    if result.returncode == 0:
        print("Download completed successfully.")
        return {
            "status": "succeeded",
            "message": "Download completed successfully.",
        }
    else:
        error_msg = f"AzCopy failed with return code: {result.returncode}"
        logger.error(error_msg)
        return {
            "error": error_msg,
            "status": "failed",
        }


def _process_download_operation(cmd, async_operation_url, logger, resource_group_name,
                             output_folder, subscription_id, resource_name, publisher_name, offer_id):
    """Process async operation and monitor status."""
    import requests

    from azure.cli.command_modules.disconnectedoperations.aaz.latest.edge_marketplace.offer import (
        GetAccessToken,
    )
    from azure.cli.core.util import send_raw_request

    try:        
        # Get operation status - has to be raw request because this is an async operation - no swagger listing for this
        status_response = send_raw_request(
            cmd.cli_ctx, "get", async_operation_url,
            resource="https://management.azure.com"
        )

        if status_response.status_code not in (200, 202):
            logger.error("Failed to get operation status: %s", status_response.status_code)
            return {
                "error": f"Status check failed: {status_response.status_code}",
                "status": "failed",
            }

        status_data = status_response.json()
        status = status_data.get("status", "").lower()
        print("Current status:", status)

        # Handle successful completion
        if status == "succeeded":
            logger.info("VHD download URL generation succeeded")
            print(status_response)
            requestId = status_data.get("properties", {}).get("requestId")

            if not requestId:
                logger.error("Download URL not found in response")
                return {"error": "Download URL not found", "status": "failed"}

            print(f"Fetched request Id for VHD Download: {requestId}")

            # Obtaining SAS token using request Id
            resource_uri = (
                f"/subscriptions/{subscription_id}"
                f"/resourceGroups/{resource_group_name}"
                f"/providers/Microsoft.Edge/disconnectedOperations/{resource_name}"
            )
            
            # Create command arguments dictionary
            command_args = {
                "resource_uri": resource_uri,
                "offer_id": offer_id,
                "request_id": requestId
            }

            token_command = GetAccessToken(cmd)
            result = token_command(command_args=command_args)
            return _handle_token_response(result, output_folder, logger)

        # Handle failure
        if status == "failed":
            error_message = status_data.get("error", {}).get("message", "Unknown error")
            logger.error("Operation failed: %s", error_message)
            return {"error": error_message, "status": "failed"}
        
    except requests.RequestException as e:
        logger.error("Failed to process async operation: %s", str(e))
        return {
            "error": str(e),
            "status": "failed",
        }


def download_vhd(cmd, resource_group_name, resource_name, publisher_name,
                 offer_id, sku, version, generation, output_folder):
    """Generate access token for VHD download."""

    import requests
    from knack.log import get_logger

    from azure.cli.command_modules.disconnectedoperations.aaz.latest.edge_marketplace.offer import (
        GenerateAccessToken,
    )
    from azure.cli.core.commands.client_factory import get_subscription_id

    class CustomGenerateAccessToken(GenerateAccessToken):
        """Extended version of GenerateAccessToken that captures headers properly"""
        
        def _output(self, *args, **kwargs):
            # Get the original result
            result = super()._output(*args, **kwargs)
            # Convert to dict if not already
            if not isinstance(result, dict):
                result = {}
            # Add headers if they were captured in the ctx
            if hasattr(self.ctx, 'captured_headers'):
                result['_headers'] = self.ctx.captured_headers
            return result
        
        class OffersGenerateAccessToken(GenerateAccessToken.OffersGenerateAccessToken):
            def __init__(self, ctx):
                super().__init__(ctx)
                # Initialize headers on context
                if not hasattr(ctx, 'captured_headers'):
                    ctx.captured_headers = {}
            
            def __call__(self, *args, **kwargs):
                # Override the send_request method to capture headers
                original_send_request = self.client.send_request
                
                def intercepted_send_request(request, **kwargs):
                    # Call the original method
                    response = original_send_request(request, **kwargs)
                    # Capture headers from the response
                    if hasattr(response, 'http_response') and hasattr(response.http_response, 'headers'):
                        headers = dict(response.http_response.headers)
                        # Store headers on the context object
                        self.ctx.captured_headers.update(headers)
                        
                        # Check for the specific header
                        if 'Azure-AsyncOperation' in headers:
                            print("âœ… Captured Azure-AsyncOperation header")
                    return response
                
                # Replace the send_request method
                self.client.send_request = intercepted_send_request
                
                try:
                    # Call the original method to get the poller
                    return super().__call__(*args, **kwargs)
                finally:
                    # Restore the original send_request method
                    self.client.send_request = original_send_request

    logger = get_logger(__name__)
    subscription_id = get_subscription_id(cmd.cli_ctx)

    # Construct URL with parameters
    # Create resource URI
    resource_uri = (
        f"/subscriptions/{subscription_id}"
        f"/resourceGroups/{resource_group_name}"
        f"/providers/Microsoft.Edge/disconnectedOperations/{resource_name}"
    )


    command_args = {
    # Required URL parameters
    "resource_uri": resource_uri,
    "offer_id": publisher_name + ":" + offer_id,  # Format required by the API
    
    # Required body parameters
    "edge_market_place_region": "eastus",  # Required in the body
    
    # Optional body parameters as needed
    "hyperv_generation": generation,
    "market_place_sku": sku,
    "market_place_sku_version": version,
    "publisher_name": publisher_name,
    
    # For long-running operations, you can set no_wait
    "no_wait": False  # Set to True if you don't want to wait for completion
    }
    
    try:
        # Create and call the command
        generate_token_command = CustomGenerateAccessToken(cmd)        
        poller = generate_token_command(command_args=command_args)

        print("Generating VHD download SAS token...")
        # Wait for completion and get the result
        result = poller.result()

        # Try to get headers from either the result or command object
        headers = result.get('_headers') if isinstance(result, dict) else None
        if not headers and hasattr(generate_token_command, '_headers'):
            headers = generate_token_command._headers

        if headers:
            async_op_url = headers.get('Azure-AsyncOperation')
            if async_op_url:
                # Process the async operation
                return _process_download_operation(
                    cmd, async_op_url, logger, resource_group_name,
                    output_folder, subscription_id, resource_name,
                    publisher_name, offer_id
                )

    except requests.RequestException as e:
        logger.error("Failed to generate access token: %s", str(e))
        return {
            "error": str(e),
            "status": "failed",
            "resource_group_name": resource_group_name,
        }


def list_offers(cmd, resource_group_name, resource_name):
    """List all offers for disconnected operations."""
    import requests
    from knack.log import get_logger

    from azure.cli.command_modules.disconnectedoperations.aaz.latest.edge_marketplace.offer import (
        List,
    )
    from azure.cli.core.commands.client_factory import get_subscription_id

    logger = get_logger(__name__)
    subscription_id = get_subscription_id(cmd.cli_ctx)

    # Construct URL with parameters
    resource_uri = (
        f"/subscriptions/{subscription_id}"
        f"/resourceGroups/{resource_group_name}"
        f"/providers/{provider_namespace}/disconnectedOperations/{resource_name}"
    )
    command_args = {
    "resource_uri": resource_uri,
    }
    try:
        list_command = List(cmd)
        result_items_iterator = list_command(command_args=command_args)

        result_items = list(result_items_iterator)

        result = []
        for offer in result_items:
            offer_content = offer.get("offerContent", {})
            skus = offer.get("marketplaceSkus", [])

            for sku in skus:
                versions = sku.get("marketplaceSkuVersions", [])[:]
                row = {
                    "Publisher": offer_content.get("offerPublisher", {}).get("publisherId"),
                    "Offer": offer_content.get("offerId"),
                    "SKU": sku.get("marketplaceSkuId"),
                    "Versions": f"{len(versions)} {'version' if len(versions) == 1 else 'versions'} available",
                    "OS_Type": sku.get("operatingSystem", {}).get("type"),
                }
                result.append(row)

        return result

    except requests.RequestException as e:
        logger.error("Failed to retrieve offers: %s", str(e))
        return {
            "error": str(e),
            "status": "failed",
            "resource_group_name": resource_group_name,
        }


def get_offer(cmd, resource_group_name, resource_name, publisher_name, offer_id):
    """Get a specific for disconnected operations given its publisher and offer name"""
    import requests
    from knack.log import get_logger

    from azure.cli.command_modules.disconnectedoperations.aaz.latest.edge_marketplace.offer import (
        Show,
    )
    from azure.cli.core.commands.client_factory import get_subscription_id
    
    logger = get_logger(__name__)
    subscription_id = get_subscription_id(cmd.cli_ctx)

    # Construct URL with parameters
    # Create resource URI
    resource_uri = (
        f"/subscriptions/{subscription_id}"
        f"/resourceGroups/{resource_group_name}"
        f"/providers/Microsoft.Edge/disconnectedOperations/{resource_name}"
    )

    # Set up command arguments
    command_args = {
        "resource_uri": resource_uri,
        "offer_id": publisher_name + ":" + offer_id  # Format required by the API
    }
    try:
        # Create and call the Show command
        show_command = Show(cmd)  # Pass the cmd object directly
        show_result = show_command(command_args=command_args)  # Returns the deserialized result
        result = []
        offer_content = show_result.get("offerContent", {})
        skus = show_result.get("marketplaceSkus", [])

        for sku in skus:
            # Get all versions for this SKU
            versions = sku.get("marketplaceSkuVersions", [])[:]

            # transform versions and size array into a multi-line string
            version_str = ", ".join(
                f"{v.get('name')}({v.get('minimumDownloadSizeInMb')}MB)" for v in versions
            )

            # Create a single row with flattened version info
            row = {
                "Publisher": offer_content.get("offerPublisher", {}).get("publisherId"),
                "Offer": offer_content.get("offerId"),
                "SKU": sku.get("marketplaceSkuId"),
                "Versions": version_str,
                "OS_Type": sku.get("operatingSystem", {}).get("type"),
            }
            result.append(row)
        return result
    except requests.RequestException as e:
        logger.error("Failed to retrieve offers: %s", str(e))
        return {
            "error": str(e),
            "status": "failed",
            "resource_group_name": resource_group_name,
        }