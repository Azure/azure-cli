# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
#
# Code generated by aaz-dev-tools
# --------------------------------------------------------------------------------------------

# pylint: disable=too-many-lines
# pylint: disable=too-many-statements

from knack.log import get_logger

logger = get_logger(__name__)

def _get_management_endpoint(cli_ctx):
    """Helper function to determine management endpoint based on cloud configuration."""
    # cloud = cli_ctx.cloud
    # return cloud.endpoints.resource_manager
    return "brazilus.management.azure.com" # For testing purposes

def package_offer(cmd, 
              resource_group_name,
              resource_name,
              publisher_name,
              offer_name,
              sku,
              version,
              output_folder):
    """Get details of a specific marketplace offer and download its logos."""

    import os
    import json
    import requests
    from azure.cli.core.commands.client_factory import get_subscription_id
    from azure.cli.core.util import send_raw_request
    from knack.log import get_logger

    # Use helper function if management_endpoint not explicitly provided
    management_endpoint = _get_management_endpoint(cmd.cli_ctx)
    logger = get_logger(__name__)

    # Get subscription ID from current context
    subscription_id = get_subscription_id(cmd.cli_ctx)
    
    provider_namespace = "Private.EdgeInternal"
    sub_provider = "Microsoft.EdgeMarketPlace"
    api_version = "2023-08-01-preview"

    # Construct URL with parameters
    url = (
        f"https://{management_endpoint}"
        f"/subscriptions/{subscription_id}"
        f"/resourceGroups/{resource_group_name}"
        f"/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{resource_name}"
        f"/providers/{sub_provider}/offers/{publisher_name}:{offer_name}"
        f"?api-version={api_version}"
    )

    resource = "https://management.azure.com"
    
    try:
        response = send_raw_request(cmd.cli_ctx, 'get', url, resource=resource)
        
        if response.status_code == 200:
            data = response.json()
            offer_content = data.get('properties', {}).get('offerContent', {})
            icon_uris = offer_content.get('iconFileUris', {})
            
            # Download logos and metadata if output folder is specified
            if output_folder:
                publisher_id = offer_content.get('offerPublisher', {}).get('publisherId', '')
                offer_id = offer_content.get('offerId', '')
                skus = data.get('properties', {}).get('marketplaceSkus', [])
                
                for sku in skus:
                    sku_id = sku.get('marketplaceSkuId', '')
                    versions = sku.get('marketplaceSkuVersions', [])
                    
                    # If version is specified, filter for that version, else take the latest
                    if version:
                        versions = [v for v in versions if v.get('name') == version]
                    else:
                        versions = versions[:1]  # Take only the latest version
                    
                    if not versions:
                        logger.warning(f"No matching version found for SKU {sku_id}")
                        continue

                    for version in versions:
                        version_id = version.get('name')
                        
                        # Create base path for this version
                        base_path = os.path.join(output_folder, 'catalog_artifacts', 
                                               publisher_id, offer_id, sku_id)
                        version_level_path = os.path.join(base_path, version_id)
                        icon_path = os.path.join(base_path, 'icons')
                        
                        # Check if version directory exists and has content
                        if os.path.exists(version_level_path):
                            # Check if directory has any files
                            if os.path.exists(os.path.join(version_level_path, 'metadata.json')) or \
                               any(os.scandir(version_level_path)):
                                error_message = f"Version directory already exists and contains files: {version_level_path}. Please delete the version folder in case you want to re-download the package."
                                logger.error(error_message)
                                return {
                                    'error': error_message,
                                    'status': 'failed',
                                    'path': version_level_path
                                }

                        os.makedirs(icon_path, exist_ok=True)
                        os.makedirs(version_level_path, exist_ok=True)

                        # Save metadata.json
                        metadata_path = os.path.join(version_level_path, 'metadata.json')
                        metadata = {
                            'name': data.get('name'),
                            'publisher': offer_content.get('offerPublisher'),
                            'offer_id': offer_content.get('offerId'),
                            'summary': offer_content.get('summary'),
                            'description': offer_content.get('description'),
                            'sku': {
                                'name': sku.get('displayName'),
                                'id': sku.get('marketplaceSkuId'),
                                'os_type': sku.get('operatingSystem'),
                                'version': version
                            }
                        }
                        
                        with open(metadata_path, 'w', encoding='utf-8') as f:
                            json.dump(metadata, f, indent=2)
                            logger.info(f"Saved metadata to {metadata_path}")
                        
                        # Download icons
                        if icon_uris:
                            for size, uri in icon_uris.items():
                                file_extension = 'png'
                                file_path = os.path.join(icon_path, f"{size}.{file_extension}")
                                
                                # Skip if icon already exists
                                if os.path.exists(file_path):
                                    logger.info(f"Icon {size} already exists at {file_path}, skipping download")
                                    continue
                                
                                try:
                                    logo_response = requests.get(uri)
                                    if logo_response.status_code == 200:
                                        with open(file_path, 'wb') as f:
                                            f.write(logo_response.content)
                                        logger.info(f"Downloaded {size} logo to {file_path}")
                                    else:
                                        logger.error(f"Failed to download {size} logo: {logo_response.status_code}")
                                except Exception as e:
                                    logger.error(f"Error downloading {size} logo: {str(e)}")

            print ("Metadata and icons downloaded successfully")
            
        else:
            error_message = f"Request failed with status code: {response.status_code}"
            logger.error(error_message)
            return {
                'error': error_message,
                'status': 'failed',
                'resource_group_name': resource_group_name,
                'response': response.text
            }
            
    except Exception as e:
        logger.error(f"Failed to retrieve offer: {str(e)}")
        return {
            'error': str(e),
            'status': 'failed',
            'resource_group_name': resource_group_name
        }

def list_offers(cmd, resource_group_name, resource_name):
    """List all offers for disconnected operations."""

    from azure.cli.core.commands.client_factory import get_subscription_id
    from azure.cli.core.util import send_raw_request
    from knack.log import get_logger

    logger = get_logger(__name__)

    management_endpoint = _get_management_endpoint(cmd.cli_ctx)
    
    # Get subscription ID from current context
    subscription_id = get_subscription_id(cmd.cli_ctx)
    provider_namespace="Private.EdgeInternal"
    sub_provider="Microsoft.EdgeMarketPlace"
    api_version="2023-08-01-preview"
    
    # Construct URL with parameters
    url = (
        f"https://{management_endpoint}"
        f"/subscriptions/{subscription_id}"
        f"/resourceGroups/{resource_group_name}"
        f"/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{resource_name}"
        f"/providers/{sub_provider}/offers"
        f"?api-version={api_version}"
    )

    # Define headers with resource for authentication
    headers = {
        'Content-Type': 'application/json',
    }

    # Define the resource for authentication
    resource = "https://management.azure.com"  # Using standard Azure management endpoint
    
    try:
        response = send_raw_request(cmd.cli_ctx, 'get', url, resource=resource)
        
        if response.status_code == 200:
            data = response.json()
            result = []
            
            for offer in data.get('value', []):
                offer_content = offer.get('properties', {}).get('offerContent', {})
                skus = offer.get('properties', {}).get('marketplaceSkus', [])
                
                for sku in skus:
                    versions = sku.get('marketplaceSkuVersions', [])[:]
                    row = {
                        'Publisher': offer_content.get('offerPublisher', {}).get('publisherId'),
                        'Offer': offer_content.get('offerId'),
                        'SKU': sku.get('marketplaceSkuId'),
                        'Versions': f"{len(versions)} {'version' if len(versions) == 1 else 'versions'} available",                        
                        'OS_Type': sku.get('operatingSystem', {}).get('type')
                    }
                    result.append(row)
            
            return result
            
        else:
            error_message = f"Request failed with status code: {response.status_code}"
            logger.error(error_message)
            return {
                'error': error_message,
                'status': 'failed',
                'resource_group_name': resource_group_name,
                'response': response.text
            }
            
    except Exception as e:
        logger.error(f"Failed to retrieve offers: {str(e)}")
        return {
            'error': str(e),
            'status': 'failed',
            'resource_group_name': resource_group_name
        }
    
def get_offer(cmd, resource_group_name, resource_name, publisher_name, offer_name):
    """List all offers for disconnected operations."""

    from azure.cli.core.commands.client_factory import get_subscription_id
    from azure.cli.core.util import send_raw_request
    from knack.log import get_logger

    logger = get_logger(__name__)

    management_endpoint = _get_management_endpoint(cmd.cli_ctx)
    
    # Get subscription ID from current context
    subscription_id = get_subscription_id(cmd.cli_ctx)
    provider_namespace="Private.EdgeInternal"
    sub_provider="Microsoft.EdgeMarketPlace"
    api_version="2023-08-01-preview"
    
    # Construct URL with parameters
    url = (
        f"https://{management_endpoint}"
        f"/subscriptions/{subscription_id}"
        f"/resourceGroups/{resource_group_name}"
        f"/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{resource_name}"
        f"/providers/{sub_provider}/offers/{publisher_name}:{offer_name}"
        f"?api-version={api_version}"
    )

    # Define headers with resource for authentication
    headers = {
        'Content-Type': 'application/json',
    }

    # Define the resource for authentication
    resource = "https://management.azure.com"  # Using standard Azure management endpoint
    
    try:
        response = send_raw_request(cmd.cli_ctx, 'get', url, resource=resource)
        
        if response.status_code == 200:
            data = response.json()
            result = []
            

            offer_content = data.get('properties', {}).get('offerContent', {})
            skus = data.get('properties', {}).get('marketplaceSkus', [])

            for sku in skus:
                # Get all versions for this SKU
                versions = sku.get('marketplaceSkuVersions', [])[:]

                # transform versions and size array into a multi-line string
                version_str = ', '.join([f"{v.get('name')}({v.get('minimumDownloadSizeInMb')}MB)" 
                                        for v in versions])
                
                # Create a single row with flattened version info
                row = {
                    'Publisher': offer_content.get('offerPublisher', {}).get('publisherId'),
                    'Offer': offer_content.get('offerId'),
                    'SKU': sku.get('marketplaceSkuId'),
                    'Versions': version_str,
                    'OS_Type': sku.get('operatingSystem', {}).get('type')
                }
                result.append(row)
            return result
            
        else:
            error_message = f"Request failed with status code: {response.status_code}"
            logger.error(error_message)
            return {
                'error': error_message,
                'status': 'failed',
                'resource_group_name': resource_group_name,
                'response': response.text
            }
            
    except Exception as e:
        logger.error(f"Failed to retrieve offers: {str(e)}")
        return {
            'error': str(e),
            'status': 'failed',
            'resource_group_name': resource_group_name
        }