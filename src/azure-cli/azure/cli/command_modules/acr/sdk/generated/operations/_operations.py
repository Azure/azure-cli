# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import sys
from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
import urllib.parse

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat
from azure.mgmt.core.polling.arm_polling import ARMPolling

from .._serialization import Serializer
from .._vendor import _format_url_section

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
if sys.version_info >= (3, 8):
    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
else:
    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_cache_rules_list_request(
    resource_group_name: str, registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/cacheRules"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = api_version

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_cache_rules_get_request(
    resource_group_name: str, registry_name: str, cache_rule_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/cacheRules/{cacheRuleName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "cacheRuleName": _SERIALIZER.url(
            "cache_rule_name", cache_rule_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9-]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = api_version
    #_params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_cache_rules_create_request(
    resource_group_name: str, registry_name: str, cache_rule_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/cacheRules/{cacheRuleName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "cacheRuleName": _SERIALIZER.url(
            "cache_rule_name", cache_rule_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9-]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_cache_rules_delete_request(
    resource_group_name: str, registry_name: str, cache_rule_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/cacheRules/{cacheRuleName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "cacheRuleName": _SERIALIZER.url(
            "cache_rule_name", cache_rule_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9-]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_cache_rules_update_request(
    resource_group_name: str, registry_name: str, cache_rule_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/cacheRules/{cacheRuleName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "cacheRuleName": _SERIALIZER.url(
            "cache_rule_name", cache_rule_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9-]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_connected_registries_list_request(
    resource_group_name: str, registry_name: str, subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/connectedRegistries"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_connected_registries_get_request(
    resource_group_name: str, registry_name: str, connected_registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/connectedRegistries/{connectedRegistryName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "connectedRegistryName": _SERIALIZER.url(
            "connected_registry_name",
            connected_registry_name,
            "str",
            max_length=50,
            min_length=5,
            pattern=r"^[a-zA-Z0-9]*$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_connected_registries_create_request(
    resource_group_name: str, registry_name: str, connected_registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/connectedRegistries/{connectedRegistryName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "connectedRegistryName": _SERIALIZER.url(
            "connected_registry_name",
            connected_registry_name,
            "str",
            max_length=50,
            min_length=5,
            pattern=r"^[a-zA-Z0-9]*$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_connected_registries_delete_request(
    resource_group_name: str, registry_name: str, connected_registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/connectedRegistries/{connectedRegistryName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "connectedRegistryName": _SERIALIZER.url(
            "connected_registry_name",
            connected_registry_name,
            "str",
            max_length=50,
            min_length=5,
            pattern=r"^[a-zA-Z0-9]*$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_connected_registries_update_request(
    resource_group_name: str, registry_name: str, connected_registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/connectedRegistries/{connectedRegistryName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "connectedRegistryName": _SERIALIZER.url(
            "connected_registry_name",
            connected_registry_name,
            "str",
            max_length=50,
            min_length=5,
            pattern=r"^[a-zA-Z0-9]*$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_connected_registries_deactivate_request(
    resource_group_name: str, registry_name: str, connected_registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/connectedRegistries/{connectedRegistryName}/deactivate"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "connectedRegistryName": _SERIALIZER.url(
            "connected_registry_name",
            connected_registry_name,
            "str",
            max_length=50,
            min_length=5,
            pattern=r"^[a-zA-Z0-9]*$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_credential_sets_list_request(
    resource_group_name: str, registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/credentialSets"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_credential_sets_get_request(
    resource_group_name: str, registry_name: str, credential_set_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/credentialSets/{credentialSetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "credentialSetName": _SERIALIZER.url(
            "credential_set_name", credential_set_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9-]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_credential_sets_create_request(
    resource_group_name: str, registry_name: str, credential_set_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/credentialSets/{credentialSetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "credentialSetName": _SERIALIZER.url(
            "credential_set_name", credential_set_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9-]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_credential_sets_delete_request(
    resource_group_name: str, registry_name: str, credential_set_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/credentialSets/{credentialSetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "credentialSetName": _SERIALIZER.url(
            "credential_set_name", credential_set_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9-]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_credential_sets_update_request(
    resource_group_name: str, registry_name: str, credential_set_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/credentialSets/{credentialSetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "credentialSetName": _SERIALIZER.url(
            "credential_set_name", credential_set_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9-]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_export_pipelines_list_request(
    resource_group_name: str, registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/exportPipelines"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_export_pipelines_get_request(
    resource_group_name: str, registry_name: str, export_pipeline_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/exportPipelines/{exportPipelineName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "exportPipelineName": _SERIALIZER.url(
            "export_pipeline_name", export_pipeline_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_export_pipelines_create_request(
    resource_group_name: str, registry_name: str, export_pipeline_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/exportPipelines/{exportPipelineName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "exportPipelineName": _SERIALIZER.url(
            "export_pipeline_name", export_pipeline_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_export_pipelines_delete_request(
    resource_group_name: str, registry_name: str, export_pipeline_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/exportPipelines/{exportPipelineName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "exportPipelineName": _SERIALIZER.url(
            "export_pipeline_name", export_pipeline_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_registries_import_image_request(
    resource_group_name: str, registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/importImage"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_registries_check_name_availability_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.ContainerRegistry/checkNameAvailability"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_registries_list_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.ContainerRegistry/registries"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_registries_list_by_resource_group_request(
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_registries_get_request(
    resource_group_name: str, registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_registries_create_request(
    resource_group_name: str, registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_registries_delete_request(
    resource_group_name: str, registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, **kwargs)


def build_registries_update_request(
    resource_group_name: str, registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_registries_list_usages_request(
    resource_group_name: str, registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/listUsages"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_registries_list_private_link_resources_request(
    resource_group_name: str, registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/privateLinkResources"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_registries_get_private_link_resource_request(
    resource_group_name: str, registry_name: str, group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/privateLinkResources/{groupName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "groupName": _SERIALIZER.url("group_name", group_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_registries_list_credentials_request(
    resource_group_name: str, registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/listCredentials"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_registries_regenerate_credential_request(
    resource_group_name: str, registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/regenerateCredential"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_registries_generate_credentials_request(
    resource_group_name: str, registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/generateCredentials"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_import_pipelines_list_request(
    resource_group_name: str, registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/importPipelines"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_import_pipelines_get_request(
    resource_group_name: str, registry_name: str, import_pipeline_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/importPipelines/{importPipelineName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "importPipelineName": _SERIALIZER.url(
            "import_pipeline_name", import_pipeline_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_import_pipelines_create_request(
    resource_group_name: str, registry_name: str, import_pipeline_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/importPipelines/{importPipelineName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "importPipelineName": _SERIALIZER.url(
            "import_pipeline_name", import_pipeline_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_import_pipelines_delete_request(
    resource_group_name: str, registry_name: str, import_pipeline_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/importPipelines/{importPipelineName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "importPipelineName": _SERIALIZER.url(
            "import_pipeline_name", import_pipeline_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_operations_list_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.ContainerRegistry/operations"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_pipeline_runs_list_request(
    resource_group_name: str, registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/pipelineRuns"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_pipeline_runs_get_request(
    resource_group_name: str, registry_name: str, pipeline_run_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/pipelineRuns/{pipelineRunName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "pipelineRunName": _SERIALIZER.url(
            "pipeline_run_name", pipeline_run_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_pipeline_runs_create_request(
    resource_group_name: str, registry_name: str, pipeline_run_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/pipelineRuns/{pipelineRunName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "pipelineRunName": _SERIALIZER.url(
            "pipeline_run_name", pipeline_run_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_pipeline_runs_delete_request(
    resource_group_name: str, registry_name: str, pipeline_run_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/pipelineRuns/{pipelineRunName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "pipelineRunName": _SERIALIZER.url(
            "pipeline_run_name", pipeline_run_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_private_endpoint_connections_list_request(
    resource_group_name: str, registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/privateEndpointConnections"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_private_endpoint_connections_get_request(
    resource_group_name: str,
    registry_name: str,
    private_endpoint_connection_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/privateEndpointConnections/{privateEndpointConnectionName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "privateEndpointConnectionName": _SERIALIZER.url(
            "private_endpoint_connection_name", private_endpoint_connection_name, "str"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_private_endpoint_connections_create_or_update_request(
    resource_group_name: str,
    registry_name: str,
    private_endpoint_connection_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/privateEndpointConnections/{privateEndpointConnectionName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "privateEndpointConnectionName": _SERIALIZER.url(
            "private_endpoint_connection_name", private_endpoint_connection_name, "str"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_private_endpoint_connections_delete_request(
    resource_group_name: str,
    registry_name: str,
    private_endpoint_connection_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/privateEndpointConnections/{privateEndpointConnectionName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "privateEndpointConnectionName": _SERIALIZER.url(
            "private_endpoint_connection_name", private_endpoint_connection_name, "str"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, **kwargs)


def build_replications_list_request(
    resource_group_name: str, registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/replications"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_replications_get_request(
    resource_group_name: str, registry_name: str, replication_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/replications/{replicationName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "replicationName": _SERIALIZER.url(
            "replication_name", replication_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_replications_create_request(
    resource_group_name: str, registry_name: str, replication_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/replications/{replicationName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "replicationName": _SERIALIZER.url(
            "replication_name", replication_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_replications_delete_request(
    resource_group_name: str, registry_name: str, replication_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/replications/{replicationName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "replicationName": _SERIALIZER.url(
            "replication_name", replication_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, **kwargs)


def build_replications_update_request(
    resource_group_name: str, registry_name: str, replication_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/replications/{replicationName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "replicationName": _SERIALIZER.url(
            "replication_name", replication_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_scope_maps_list_request(
    resource_group_name: str, registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/scopeMaps"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_scope_maps_get_request(
    resource_group_name: str, registry_name: str, scope_map_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/scopeMaps/{scopeMapName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "scopeMapName": _SERIALIZER.url(
            "scope_map_name", scope_map_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9-_]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_scope_maps_create_request(
    resource_group_name: str, registry_name: str, scope_map_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/scopeMaps/{scopeMapName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "scopeMapName": _SERIALIZER.url(
            "scope_map_name", scope_map_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9-_]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_scope_maps_delete_request(
    resource_group_name: str, registry_name: str, scope_map_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/scopeMaps/{scopeMapName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "scopeMapName": _SERIALIZER.url(
            "scope_map_name", scope_map_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9-_]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_scope_maps_update_request(
    resource_group_name: str, registry_name: str, scope_map_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/scopeMaps/{scopeMapName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "scopeMapName": _SERIALIZER.url(
            "scope_map_name", scope_map_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9-_]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_tokens_list_request(
    resource_group_name: str, registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/tokens"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tokens_get_request(
    resource_group_name: str, registry_name: str, token_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/tokens/{tokenName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "tokenName": _SERIALIZER.url(
            "token_name", token_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9-]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tokens_create_request(
    resource_group_name: str, registry_name: str, token_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/tokens/{tokenName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "tokenName": _SERIALIZER.url(
            "token_name", token_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9-]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_tokens_delete_request(
    resource_group_name: str, registry_name: str, token_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/tokens/{tokenName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "tokenName": _SERIALIZER.url(
            "token_name", token_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9-]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_tokens_update_request(
    resource_group_name: str, registry_name: str, token_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/tokens/{tokenName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "tokenName": _SERIALIZER.url(
            "token_name", token_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9-]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_webhooks_list_request(
    resource_group_name: str, registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/webhooks"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_webhooks_get_request(
    resource_group_name: str, registry_name: str, webhook_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/webhooks/{webhookName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "webhookName": _SERIALIZER.url(
            "webhook_name", webhook_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_webhooks_create_request(
    resource_group_name: str, registry_name: str, webhook_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/webhooks/{webhookName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "webhookName": _SERIALIZER.url(
            "webhook_name", webhook_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_webhooks_delete_request(
    resource_group_name: str, registry_name: str, webhook_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/webhooks/{webhookName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "webhookName": _SERIALIZER.url(
            "webhook_name", webhook_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, **kwargs)


def build_webhooks_update_request(
    resource_group_name: str, registry_name: str, webhook_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/webhooks/{webhookName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "webhookName": _SERIALIZER.url(
            "webhook_name", webhook_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_webhooks_ping_request(
    resource_group_name: str, registry_name: str, webhook_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/webhooks/{webhookName}/ping"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "webhookName": _SERIALIZER.url(
            "webhook_name", webhook_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_webhooks_list_events_request(
    resource_group_name: str, registry_name: str, webhook_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/webhooks/{webhookName}/listEvents"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "webhookName": _SERIALIZER.url(
            "webhook_name", webhook_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_webhooks_get_callback_config_request(
    resource_group_name: str, registry_name: str, webhook_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: Literal["2023-01-01-preview"] = kwargs.pop(
        "api_version", _params.pop("api-version", "2023-01-01-preview")
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerRegistry/registries/{registryName}/webhooks/{webhookName}/getCallbackConfig"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "registryName": _SERIALIZER.url(
            "registry_name", registry_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
        "webhookName": _SERIALIZER.url(
            "webhook_name", webhook_name, "str", max_length=50, min_length=5, pattern=r"^[a-zA-Z0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


class CacheRulesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~container_registry_management_client.ContainerRegistryManagementClient`'s
        :attr:`cache_rules` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, resource_group_name: str, registry_name: str, **kwargs: Any) -> Iterable[JSON]:
        """Lists all cache rule resources for the specified container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of the cache rule.
                        "credentialSetResourceId": "str",  # Optional. The ARM resource ID of
                          the credential store which is associated with the cache rule.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "sourceRepository": "str",  # Optional. Source repository pulled from
                          upstream.
                        "targetRepository": "str"  # Optional. Target repository specified in
                          docker pull command."nEg: docker pull
                          myregistry.azurecr.io/{targetRepository}:{tag}.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_cache_rules_list_request(
                    resource_group_name=resource_group_name,
                    registry_name=registry_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = '2023-01-01-preview'
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, registry_name: str, cache_rule_name: str, **kwargs: Any) -> JSON:
        """Gets the properties of the specified cache rule resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param cache_rule_name: The name of the cache rule. Required.
        :type cache_rule_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of the cache rule.
                        "credentialSetResourceId": "str",  # Optional. The ARM resource ID of
                          the credential store which is associated with the cache rule.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "sourceRepository": "str",  # Optional. Source repository pulled from
                          upstream.
                        "targetRepository": "str"  # Optional. Target repository specified in
                          docker pull command."nEg: docker pull
                          myregistry.azurecr.io/{targetRepository}:{tag}.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)
        request = build_cache_rules_get_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            cache_rule_name=cache_rule_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )

        #print(vars(self._config.subscription_id._credential))
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response
        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_initial(
        self,
        resource_group_name: str,
        registry_name: str,
        cache_rule_name: str,
        cache_rule_create_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(cache_rule_create_parameters, (IO, bytes)):
            _content = cache_rule_create_parameters
        else:
            _json = cache_rule_create_parameters

        request = build_cache_rules_create_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            cache_rule_name=cache_rule_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        cache_rule_name: str,
        cache_rule_create_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a cache rule for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param cache_rule_name: The name of the cache rule. Required.
        :type cache_rule_name: str
        :param cache_rule_create_parameters: The parameters for creating a cache rule. Required.
        :type cache_rule_create_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                cache_rule_create_parameters = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of the cache rule.
                        "credentialSetResourceId": "str",  # Optional. The ARM resource ID of
                          the credential store which is associated with the cache rule.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "sourceRepository": "str",  # Optional. Source repository pulled from
                          upstream.
                        "targetRepository": "str"  # Optional. Target repository specified in
                          docker pull command."nEg: docker pull
                          myregistry.azurecr.io/{targetRepository}:{tag}.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of the cache rule.
                        "credentialSetResourceId": "str",  # Optional. The ARM resource ID of
                          the credential store which is associated with the cache rule.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "sourceRepository": "str",  # Optional. Source repository pulled from
                          upstream.
                        "targetRepository": "str"  # Optional. Target repository specified in
                          docker pull command."nEg: docker pull
                          myregistry.azurecr.io/{targetRepository}:{tag}.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        cache_rule_name: str,
        cache_rule_create_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a cache rule for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param cache_rule_name: The name of the cache rule. Required.
        :type cache_rule_name: str
        :param cache_rule_create_parameters: The parameters for creating a cache rule. Required.
        :type cache_rule_create_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of the cache rule.
                        "credentialSetResourceId": "str",  # Optional. The ARM resource ID of
                          the credential store which is associated with the cache rule.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "sourceRepository": "str",  # Optional. Source repository pulled from
                          upstream.
                        "targetRepository": "str"  # Optional. Target repository specified in
                          docker pull command."nEg: docker pull
                          myregistry.azurecr.io/{targetRepository}:{tag}.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        cache_rule_name: str,
        cache_rule_create_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a cache rule for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param cache_rule_name: The name of the cache rule. Required.
        :type cache_rule_name: str
        :param cache_rule_create_parameters: The parameters for creating a cache rule. Is either a
         model type or a IO type. Required.
        :type cache_rule_create_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of the cache rule.
                        "credentialSetResourceId": "str",  # Optional. The ARM resource ID of
                          the credential store which is associated with the cache rule.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "sourceRepository": "str",  # Optional. Source repository pulled from
                          upstream.
                        "targetRepository": "str"  # Optional. Target repository specified in
                          docker pull command."nEg: docker pull
                          myregistry.azurecr.io/{targetRepository}:{tag}.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_initial(
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                cache_rule_name=cache_rule_name,
                cache_rule_create_parameters=cache_rule_create_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, registry_name: str, cache_rule_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_cache_rules_delete_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            cache_rule_name=cache_rule_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, registry_name: str, cache_rule_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Deletes a cache rule resource from a container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param cache_rule_name: The name of the cache rule. Required.
        :type cache_rule_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                cache_rule_name=cache_rule_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _update_initial(
        self,
        resource_group_name: str,
        registry_name: str,
        cache_rule_name: str,
        cache_rule_update_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(cache_rule_update_parameters, (IO, bytes)):
            _content = cache_rule_update_parameters
        else:
            _json = cache_rule_update_parameters

        request = build_cache_rules_update_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            cache_rule_name=cache_rule_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201 or response.status_code == 202:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        registry_name: str,
        cache_rule_name: str,
        cache_rule_update_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a cache rule for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param cache_rule_name: The name of the cache rule. Required.
        :type cache_rule_name: str
        :param cache_rule_update_parameters: The parameters for updating a cache rule. Required.
        :type cache_rule_update_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                cache_rule_update_parameters = {
                    "properties": {
                        "credentialSetResourceId": "str"  # Optional. The ARM resource ID of
                          the credential store which is associated with the Cache rule.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of the cache rule.
                        "credentialSetResourceId": "str",  # Optional. The ARM resource ID of
                          the credential store which is associated with the cache rule.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "sourceRepository": "str",  # Optional. Source repository pulled from
                          upstream.
                        "targetRepository": "str"  # Optional. Target repository specified in
                          docker pull command."nEg: docker pull
                          myregistry.azurecr.io/{targetRepository}:{tag}.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        registry_name: str,
        cache_rule_name: str,
        cache_rule_update_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a cache rule for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param cache_rule_name: The name of the cache rule. Required.
        :type cache_rule_name: str
        :param cache_rule_update_parameters: The parameters for updating a cache rule. Required.
        :type cache_rule_update_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of the cache rule.
                        "credentialSetResourceId": "str",  # Optional. The ARM resource ID of
                          the credential store which is associated with the cache rule.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "sourceRepository": "str",  # Optional. Source repository pulled from
                          upstream.
                        "targetRepository": "str"  # Optional. Target repository specified in
                          docker pull command."nEg: docker pull
                          myregistry.azurecr.io/{targetRepository}:{tag}.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_update(
        self,
        resource_group_name: str,
        registry_name: str,
        cache_rule_name: str,
        cache_rule_update_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a cache rule for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param cache_rule_name: The name of the cache rule. Required.
        :type cache_rule_name: str
        :param cache_rule_update_parameters: The parameters for updating a cache rule. Is either a
         model type or a IO type. Required.
        :type cache_rule_update_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of the cache rule.
                        "credentialSetResourceId": "str",  # Optional. The ARM resource ID of
                          the credential store which is associated with the cache rule.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "sourceRepository": "str",  # Optional. Source repository pulled from
                          upstream.
                        "targetRepository": "str"  # Optional. Target repository specified in
                          docker pull command."nEg: docker pull
                          myregistry.azurecr.io/{targetRepository}:{tag}.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                cache_rule_name=cache_rule_name,
                cache_rule_update_parameters=cache_rule_update_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class ConnectedRegistriesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~container_registry_management_client.ContainerRegistryManagementClient`'s
        :attr:`connected_registries` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self, resource_group_name: str, registry_name: str, *, filter: Optional[str] = None, **kwargs: Any
    ) -> Iterable[JSON]:
        """Lists all connected registries for the specified container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :keyword filter: An OData filter expression that describes a subset of connectedRegistries to
         return. The parameters that can be filtered are parent.id (the resource id of the
         connectedRegistry parent), mode, and connectionState. The supported operator is eq. Default
         value is None.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "mode": "str",  # The mode of the connected registry resource that
                          indicates the permissions of the registry. Required. Known values are:
                          "ReadWrite", "ReadOnly", "Registry", and "Mirror".
                        "parent": {
                            "syncProperties": {
                                "messageTtl": "1 day, 0:00:00",  # The period of time
                                  for which a message is available to sync before it is expired.
                                  Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as
                                  per ISO8601. Required.
                                "tokenId": "str",  # The resource ID of the ACR token
                                  used to authenticate the connected registry to its parent during
                                  sync. Required.
                                "gatewayEndpoint": "str",  # Optional. The gateway
                                  endpoint used by the connected registry to communicate with its
                                  parent.
                                "lastSyncTime": "2020-02-20 00:00:00",  # Optional.
                                  The last time a sync occurred between the connected registry and its
                                  parent.
                                "schedule": "str",  # Optional. The cron expression
                                  indicating the schedule that the connected registry will sync with
                                  its parent.
                                "syncWindow": "1 day, 0:00:00"  # Optional. The time
                                  window during which sync is enabled for each schedule occurrence.
                                  Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as
                                  per ISO8601.
                            },
                            "id": "str"  # Optional. The resource ID of the parent to
                              which the connected registry will be associated.
                        },
                        "activation": {
                            "status": "str"  # Optional. The activation status of the
                              connected registry. Known values are: "Active" and "Inactive".
                        },
                        "clientTokenIds": [
                            "str"  # Optional. The list of the ACR token resource IDs
                              used to authenticate clients to the connected registry.
                        ],
                        "connectionState": "str",  # Optional. The current connection state
                          of the connected registry. Known values are: "Online", "Offline", "Syncing",
                          and "Unhealthy".
                        "lastActivityTime": "2020-02-20 00:00:00",  # Optional. The last
                          activity time of the connected registry.
                        "logging": {
                            "auditLogStatus": "Disabled",  # Optional. Default value is
                              "Disabled". Indicates whether audit logs are enabled on the connected
                              registry. Known values are: "Enabled" and "Disabled".
                            "logLevel": "Information"  # Optional. Default value is
                              "Information". The verbosity of logs persisted on the connected registry.
                              Known values are: "Debug", "Information", "Warning", "Error", and "None".
                        },
                        "loginServer": {
                            "host": "str",  # Optional. The host of the connected
                              registry. Can be FQDN or IP.
                            "tls": {
                                "certificate": {
                                    "location": "str",  # Optional. Indicates the
                                      location of the certificates.
                                    "type": "str"  # Optional. The type of
                                      certificate location. "LocalDirectory"
                                },
                                "status": "str"  # Optional. Indicates whether HTTPS
                                  is enabled for the login server. Known values are: "Enabled" and
                                  "Disabled".
                            }
                        },
                        "notificationsList": [
                            "str"  # Optional. The list of notifications subscription
                              information for the connected registry.
                        ],
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "statusDetails": [
                            {
                                "code": "str",  # Optional. The code of the status.
                                "correlationId": "str",  # Optional. The correlation
                                  ID of the status.
                                "description": "str",  # Optional. The description of
                                  the status.
                                "timestamp": "2020-02-20 00:00:00",  # Optional. The
                                  timestamp of the status.
                                "type": "str"  # Optional. The component of the
                                  connected registry corresponding to the status.
                            }
                        ],
                        "version": "str"  # Optional. The current version of ACR runtime on
                          the connected registry.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_connected_registries_list_request(
                    resource_group_name=resource_group_name,
                    registry_name=registry_name,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, registry_name: str, connected_registry_name: str, **kwargs: Any) -> JSON:
        """Gets the properties of the connected registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param connected_registry_name: The name of the connected registry. Required.
        :type connected_registry_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "mode": "str",  # The mode of the connected registry resource that
                          indicates the permissions of the registry. Required. Known values are:
                          "ReadWrite", "ReadOnly", "Registry", and "Mirror".
                        "parent": {
                            "syncProperties": {
                                "messageTtl": "1 day, 0:00:00",  # The period of time
                                  for which a message is available to sync before it is expired.
                                  Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as
                                  per ISO8601. Required.
                                "tokenId": "str",  # The resource ID of the ACR token
                                  used to authenticate the connected registry to its parent during
                                  sync. Required.
                                "gatewayEndpoint": "str",  # Optional. The gateway
                                  endpoint used by the connected registry to communicate with its
                                  parent.
                                "lastSyncTime": "2020-02-20 00:00:00",  # Optional.
                                  The last time a sync occurred between the connected registry and its
                                  parent.
                                "schedule": "str",  # Optional. The cron expression
                                  indicating the schedule that the connected registry will sync with
                                  its parent.
                                "syncWindow": "1 day, 0:00:00"  # Optional. The time
                                  window during which sync is enabled for each schedule occurrence.
                                  Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as
                                  per ISO8601.
                            },
                            "id": "str"  # Optional. The resource ID of the parent to
                              which the connected registry will be associated.
                        },
                        "activation": {
                            "status": "str"  # Optional. The activation status of the
                              connected registry. Known values are: "Active" and "Inactive".
                        },
                        "clientTokenIds": [
                            "str"  # Optional. The list of the ACR token resource IDs
                              used to authenticate clients to the connected registry.
                        ],
                        "connectionState": "str",  # Optional. The current connection state
                          of the connected registry. Known values are: "Online", "Offline", "Syncing",
                          and "Unhealthy".
                        "lastActivityTime": "2020-02-20 00:00:00",  # Optional. The last
                          activity time of the connected registry.
                        "logging": {
                            "auditLogStatus": "Disabled",  # Optional. Default value is
                              "Disabled". Indicates whether audit logs are enabled on the connected
                              registry. Known values are: "Enabled" and "Disabled".
                            "logLevel": "Information"  # Optional. Default value is
                              "Information". The verbosity of logs persisted on the connected registry.
                              Known values are: "Debug", "Information", "Warning", "Error", and "None".
                        },
                        "loginServer": {
                            "host": "str",  # Optional. The host of the connected
                              registry. Can be FQDN or IP.
                            "tls": {
                                "certificate": {
                                    "location": "str",  # Optional. Indicates the
                                      location of the certificates.
                                    "type": "str"  # Optional. The type of
                                      certificate location. "LocalDirectory"
                                },
                                "status": "str"  # Optional. Indicates whether HTTPS
                                  is enabled for the login server. Known values are: "Enabled" and
                                  "Disabled".
                            }
                        },
                        "notificationsList": [
                            "str"  # Optional. The list of notifications subscription
                              information for the connected registry.
                        ],
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "statusDetails": [
                            {
                                "code": "str",  # Optional. The code of the status.
                                "correlationId": "str",  # Optional. The correlation
                                  ID of the status.
                                "description": "str",  # Optional. The description of
                                  the status.
                                "timestamp": "2020-02-20 00:00:00",  # Optional. The
                                  timestamp of the status.
                                "type": "str"  # Optional. The component of the
                                  connected registry corresponding to the status.
                            }
                        ],
                        "version": "str"  # Optional. The current version of ACR runtime on
                          the connected registry.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_connected_registries_get_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            connected_registry_name=connected_registry_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_initial(
        self,
        resource_group_name: str,
        registry_name: str,
        connected_registry_name: str,
        connected_registry_create_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(connected_registry_create_parameters, (IO, bytes)):
            _content = connected_registry_create_parameters
        else:
            _json = connected_registry_create_parameters

        request = build_connected_registries_create_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            connected_registry_name=connected_registry_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        connected_registry_name: str,
        connected_registry_create_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a connected registry for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param connected_registry_name: The name of the connected registry. Required.
        :type connected_registry_name: str
        :param connected_registry_create_parameters: The parameters for creating a connectedRegistry.
         Required.
        :type connected_registry_create_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                connected_registry_create_parameters = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "mode": "str",  # The mode of the connected registry resource that
                          indicates the permissions of the registry. Required. Known values are:
                          "ReadWrite", "ReadOnly", "Registry", and "Mirror".
                        "parent": {
                            "syncProperties": {
                                "messageTtl": "1 day, 0:00:00",  # The period of time
                                  for which a message is available to sync before it is expired.
                                  Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as
                                  per ISO8601. Required.
                                "tokenId": "str",  # The resource ID of the ACR token
                                  used to authenticate the connected registry to its parent during
                                  sync. Required.
                                "gatewayEndpoint": "str",  # Optional. The gateway
                                  endpoint used by the connected registry to communicate with its
                                  parent.
                                "lastSyncTime": "2020-02-20 00:00:00",  # Optional.
                                  The last time a sync occurred between the connected registry and its
                                  parent.
                                "schedule": "str",  # Optional. The cron expression
                                  indicating the schedule that the connected registry will sync with
                                  its parent.
                                "syncWindow": "1 day, 0:00:00"  # Optional. The time
                                  window during which sync is enabled for each schedule occurrence.
                                  Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as
                                  per ISO8601.
                            },
                            "id": "str"  # Optional. The resource ID of the parent to
                              which the connected registry will be associated.
                        },
                        "activation": {
                            "status": "str"  # Optional. The activation status of the
                              connected registry. Known values are: "Active" and "Inactive".
                        },
                        "clientTokenIds": [
                            "str"  # Optional. The list of the ACR token resource IDs
                              used to authenticate clients to the connected registry.
                        ],
                        "connectionState": "str",  # Optional. The current connection state
                          of the connected registry. Known values are: "Online", "Offline", "Syncing",
                          and "Unhealthy".
                        "lastActivityTime": "2020-02-20 00:00:00",  # Optional. The last
                          activity time of the connected registry.
                        "logging": {
                            "auditLogStatus": "Disabled",  # Optional. Default value is
                              "Disabled". Indicates whether audit logs are enabled on the connected
                              registry. Known values are: "Enabled" and "Disabled".
                            "logLevel": "Information"  # Optional. Default value is
                              "Information". The verbosity of logs persisted on the connected registry.
                              Known values are: "Debug", "Information", "Warning", "Error", and "None".
                        },
                        "loginServer": {
                            "host": "str",  # Optional. The host of the connected
                              registry. Can be FQDN or IP.
                            "tls": {
                                "certificate": {
                                    "location": "str",  # Optional. Indicates the
                                      location of the certificates.
                                    "type": "str"  # Optional. The type of
                                      certificate location. "LocalDirectory"
                                },
                                "status": "str"  # Optional. Indicates whether HTTPS
                                  is enabled for the login server. Known values are: "Enabled" and
                                  "Disabled".
                            }
                        },
                        "notificationsList": [
                            "str"  # Optional. The list of notifications subscription
                              information for the connected registry.
                        ],
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "statusDetails": [
                            {
                                "code": "str",  # Optional. The code of the status.
                                "correlationId": "str",  # Optional. The correlation
                                  ID of the status.
                                "description": "str",  # Optional. The description of
                                  the status.
                                "timestamp": "2020-02-20 00:00:00",  # Optional. The
                                  timestamp of the status.
                                "type": "str"  # Optional. The component of the
                                  connected registry corresponding to the status.
                            }
                        ],
                        "version": "str"  # Optional. The current version of ACR runtime on
                          the connected registry.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "mode": "str",  # The mode of the connected registry resource that
                          indicates the permissions of the registry. Required. Known values are:
                          "ReadWrite", "ReadOnly", "Registry", and "Mirror".
                        "parent": {
                            "syncProperties": {
                                "messageTtl": "1 day, 0:00:00",  # The period of time
                                  for which a message is available to sync before it is expired.
                                  Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as
                                  per ISO8601. Required.
                                "tokenId": "str",  # The resource ID of the ACR token
                                  used to authenticate the connected registry to its parent during
                                  sync. Required.
                                "gatewayEndpoint": "str",  # Optional. The gateway
                                  endpoint used by the connected registry to communicate with its
                                  parent.
                                "lastSyncTime": "2020-02-20 00:00:00",  # Optional.
                                  The last time a sync occurred between the connected registry and its
                                  parent.
                                "schedule": "str",  # Optional. The cron expression
                                  indicating the schedule that the connected registry will sync with
                                  its parent.
                                "syncWindow": "1 day, 0:00:00"  # Optional. The time
                                  window during which sync is enabled for each schedule occurrence.
                                  Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as
                                  per ISO8601.
                            },
                            "id": "str"  # Optional. The resource ID of the parent to
                              which the connected registry will be associated.
                        },
                        "activation": {
                            "status": "str"  # Optional. The activation status of the
                              connected registry. Known values are: "Active" and "Inactive".
                        },
                        "clientTokenIds": [
                            "str"  # Optional. The list of the ACR token resource IDs
                              used to authenticate clients to the connected registry.
                        ],
                        "connectionState": "str",  # Optional. The current connection state
                          of the connected registry. Known values are: "Online", "Offline", "Syncing",
                          and "Unhealthy".
                        "lastActivityTime": "2020-02-20 00:00:00",  # Optional. The last
                          activity time of the connected registry.
                        "logging": {
                            "auditLogStatus": "Disabled",  # Optional. Default value is
                              "Disabled". Indicates whether audit logs are enabled on the connected
                              registry. Known values are: "Enabled" and "Disabled".
                            "logLevel": "Information"  # Optional. Default value is
                              "Information". The verbosity of logs persisted on the connected registry.
                              Known values are: "Debug", "Information", "Warning", "Error", and "None".
                        },
                        "loginServer": {
                            "host": "str",  # Optional. The host of the connected
                              registry. Can be FQDN or IP.
                            "tls": {
                                "certificate": {
                                    "location": "str",  # Optional. Indicates the
                                      location of the certificates.
                                    "type": "str"  # Optional. The type of
                                      certificate location. "LocalDirectory"
                                },
                                "status": "str"  # Optional. Indicates whether HTTPS
                                  is enabled for the login server. Known values are: "Enabled" and
                                  "Disabled".
                            }
                        },
                        "notificationsList": [
                            "str"  # Optional. The list of notifications subscription
                              information for the connected registry.
                        ],
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "statusDetails": [
                            {
                                "code": "str",  # Optional. The code of the status.
                                "correlationId": "str",  # Optional. The correlation
                                  ID of the status.
                                "description": "str",  # Optional. The description of
                                  the status.
                                "timestamp": "2020-02-20 00:00:00",  # Optional. The
                                  timestamp of the status.
                                "type": "str"  # Optional. The component of the
                                  connected registry corresponding to the status.
                            }
                        ],
                        "version": "str"  # Optional. The current version of ACR runtime on
                          the connected registry.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        connected_registry_name: str,
        connected_registry_create_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a connected registry for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param connected_registry_name: The name of the connected registry. Required.
        :type connected_registry_name: str
        :param connected_registry_create_parameters: The parameters for creating a connectedRegistry.
         Required.
        :type connected_registry_create_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "mode": "str",  # The mode of the connected registry resource that
                          indicates the permissions of the registry. Required. Known values are:
                          "ReadWrite", "ReadOnly", "Registry", and "Mirror".
                        "parent": {
                            "syncProperties": {
                                "messageTtl": "1 day, 0:00:00",  # The period of time
                                  for which a message is available to sync before it is expired.
                                  Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as
                                  per ISO8601. Required.
                                "tokenId": "str",  # The resource ID of the ACR token
                                  used to authenticate the connected registry to its parent during
                                  sync. Required.
                                "gatewayEndpoint": "str",  # Optional. The gateway
                                  endpoint used by the connected registry to communicate with its
                                  parent.
                                "lastSyncTime": "2020-02-20 00:00:00",  # Optional.
                                  The last time a sync occurred between the connected registry and its
                                  parent.
                                "schedule": "str",  # Optional. The cron expression
                                  indicating the schedule that the connected registry will sync with
                                  its parent.
                                "syncWindow": "1 day, 0:00:00"  # Optional. The time
                                  window during which sync is enabled for each schedule occurrence.
                                  Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as
                                  per ISO8601.
                            },
                            "id": "str"  # Optional. The resource ID of the parent to
                              which the connected registry will be associated.
                        },
                        "activation": {
                            "status": "str"  # Optional. The activation status of the
                              connected registry. Known values are: "Active" and "Inactive".
                        },
                        "clientTokenIds": [
                            "str"  # Optional. The list of the ACR token resource IDs
                              used to authenticate clients to the connected registry.
                        ],
                        "connectionState": "str",  # Optional. The current connection state
                          of the connected registry. Known values are: "Online", "Offline", "Syncing",
                          and "Unhealthy".
                        "lastActivityTime": "2020-02-20 00:00:00",  # Optional. The last
                          activity time of the connected registry.
                        "logging": {
                            "auditLogStatus": "Disabled",  # Optional. Default value is
                              "Disabled". Indicates whether audit logs are enabled on the connected
                              registry. Known values are: "Enabled" and "Disabled".
                            "logLevel": "Information"  # Optional. Default value is
                              "Information". The verbosity of logs persisted on the connected registry.
                              Known values are: "Debug", "Information", "Warning", "Error", and "None".
                        },
                        "loginServer": {
                            "host": "str",  # Optional. The host of the connected
                              registry. Can be FQDN or IP.
                            "tls": {
                                "certificate": {
                                    "location": "str",  # Optional. Indicates the
                                      location of the certificates.
                                    "type": "str"  # Optional. The type of
                                      certificate location. "LocalDirectory"
                                },
                                "status": "str"  # Optional. Indicates whether HTTPS
                                  is enabled for the login server. Known values are: "Enabled" and
                                  "Disabled".
                            }
                        },
                        "notificationsList": [
                            "str"  # Optional. The list of notifications subscription
                              information for the connected registry.
                        ],
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "statusDetails": [
                            {
                                "code": "str",  # Optional. The code of the status.
                                "correlationId": "str",  # Optional. The correlation
                                  ID of the status.
                                "description": "str",  # Optional. The description of
                                  the status.
                                "timestamp": "2020-02-20 00:00:00",  # Optional. The
                                  timestamp of the status.
                                "type": "str"  # Optional. The component of the
                                  connected registry corresponding to the status.
                            }
                        ],
                        "version": "str"  # Optional. The current version of ACR runtime on
                          the connected registry.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        connected_registry_name: str,
        connected_registry_create_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a connected registry for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param connected_registry_name: The name of the connected registry. Required.
        :type connected_registry_name: str
        :param connected_registry_create_parameters: The parameters for creating a connectedRegistry.
         Is either a model type or a IO type. Required.
        :type connected_registry_create_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "mode": "str",  # The mode of the connected registry resource that
                          indicates the permissions of the registry. Required. Known values are:
                          "ReadWrite", "ReadOnly", "Registry", and "Mirror".
                        "parent": {
                            "syncProperties": {
                                "messageTtl": "1 day, 0:00:00",  # The period of time
                                  for which a message is available to sync before it is expired.
                                  Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as
                                  per ISO8601. Required.
                                "tokenId": "str",  # The resource ID of the ACR token
                                  used to authenticate the connected registry to its parent during
                                  sync. Required.
                                "gatewayEndpoint": "str",  # Optional. The gateway
                                  endpoint used by the connected registry to communicate with its
                                  parent.
                                "lastSyncTime": "2020-02-20 00:00:00",  # Optional.
                                  The last time a sync occurred between the connected registry and its
                                  parent.
                                "schedule": "str",  # Optional. The cron expression
                                  indicating the schedule that the connected registry will sync with
                                  its parent.
                                "syncWindow": "1 day, 0:00:00"  # Optional. The time
                                  window during which sync is enabled for each schedule occurrence.
                                  Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as
                                  per ISO8601.
                            },
                            "id": "str"  # Optional. The resource ID of the parent to
                              which the connected registry will be associated.
                        },
                        "activation": {
                            "status": "str"  # Optional. The activation status of the
                              connected registry. Known values are: "Active" and "Inactive".
                        },
                        "clientTokenIds": [
                            "str"  # Optional. The list of the ACR token resource IDs
                              used to authenticate clients to the connected registry.
                        ],
                        "connectionState": "str",  # Optional. The current connection state
                          of the connected registry. Known values are: "Online", "Offline", "Syncing",
                          and "Unhealthy".
                        "lastActivityTime": "2020-02-20 00:00:00",  # Optional. The last
                          activity time of the connected registry.
                        "logging": {
                            "auditLogStatus": "Disabled",  # Optional. Default value is
                              "Disabled". Indicates whether audit logs are enabled on the connected
                              registry. Known values are: "Enabled" and "Disabled".
                            "logLevel": "Information"  # Optional. Default value is
                              "Information". The verbosity of logs persisted on the connected registry.
                              Known values are: "Debug", "Information", "Warning", "Error", and "None".
                        },
                        "loginServer": {
                            "host": "str",  # Optional. The host of the connected
                              registry. Can be FQDN or IP.
                            "tls": {
                                "certificate": {
                                    "location": "str",  # Optional. Indicates the
                                      location of the certificates.
                                    "type": "str"  # Optional. The type of
                                      certificate location. "LocalDirectory"
                                },
                                "status": "str"  # Optional. Indicates whether HTTPS
                                  is enabled for the login server. Known values are: "Enabled" and
                                  "Disabled".
                            }
                        },
                        "notificationsList": [
                            "str"  # Optional. The list of notifications subscription
                              information for the connected registry.
                        ],
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "statusDetails": [
                            {
                                "code": "str",  # Optional. The code of the status.
                                "correlationId": "str",  # Optional. The correlation
                                  ID of the status.
                                "description": "str",  # Optional. The description of
                                  the status.
                                "timestamp": "2020-02-20 00:00:00",  # Optional. The
                                  timestamp of the status.
                                "type": "str"  # Optional. The component of the
                                  connected registry corresponding to the status.
                            }
                        ],
                        "version": "str"  # Optional. The current version of ACR runtime on
                          the connected registry.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_initial(
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                connected_registry_name=connected_registry_name,
                connected_registry_create_parameters=connected_registry_create_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, registry_name: str, connected_registry_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_connected_registries_delete_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            connected_registry_name=connected_registry_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, registry_name: str, connected_registry_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Deletes a connected registry from a container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param connected_registry_name: The name of the connected registry. Required.
        :type connected_registry_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                connected_registry_name=connected_registry_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _update_initial(
        self,
        resource_group_name: str,
        registry_name: str,
        connected_registry_name: str,
        connected_registry_update_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(connected_registry_update_parameters, (IO, bytes)):
            _content = connected_registry_update_parameters
        else:
            _json = connected_registry_update_parameters

        request = build_connected_registries_update_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            connected_registry_name=connected_registry_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        registry_name: str,
        connected_registry_name: str,
        connected_registry_update_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a connected registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param connected_registry_name: The name of the connected registry. Required.
        :type connected_registry_name: str
        :param connected_registry_update_parameters: The parameters for updating a connectedRegistry.
         Required.
        :type connected_registry_update_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                connected_registry_update_parameters = {
                    "properties": {
                        "clientTokenIds": [
                            "str"  # Optional. The list of the ACR token resource IDs
                              used to authenticate clients to the connected registry.
                        ],
                        "logging": {
                            "auditLogStatus": "Disabled",  # Optional. Default value is
                              "Disabled". Indicates whether audit logs are enabled on the connected
                              registry. Known values are: "Enabled" and "Disabled".
                            "logLevel": "Information"  # Optional. Default value is
                              "Information". The verbosity of logs persisted on the connected registry.
                              Known values are: "Debug", "Information", "Warning", "Error", and "None".
                        },
                        "notificationsList": [
                            "str"  # Optional. The list of notifications subscription
                              information for the connected registry.
                        ],
                        "syncProperties": {
                            "messageTtl": "1 day, 0:00:00",  # Optional. The period of
                              time for which a message is available to sync before it is expired.
                              Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as per
                              ISO8601.
                            "schedule": "str",  # Optional. The cron expression
                              indicating the schedule that the connected registry will sync with its
                              parent.
                            "syncWindow": "1 day, 0:00:00"  # Optional. The time window
                              during which sync is enabled for each schedule occurrence. Specify the
                              duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as per ISO8601.
                        }
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "mode": "str",  # The mode of the connected registry resource that
                          indicates the permissions of the registry. Required. Known values are:
                          "ReadWrite", "ReadOnly", "Registry", and "Mirror".
                        "parent": {
                            "syncProperties": {
                                "messageTtl": "1 day, 0:00:00",  # The period of time
                                  for which a message is available to sync before it is expired.
                                  Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as
                                  per ISO8601. Required.
                                "tokenId": "str",  # The resource ID of the ACR token
                                  used to authenticate the connected registry to its parent during
                                  sync. Required.
                                "gatewayEndpoint": "str",  # Optional. The gateway
                                  endpoint used by the connected registry to communicate with its
                                  parent.
                                "lastSyncTime": "2020-02-20 00:00:00",  # Optional.
                                  The last time a sync occurred between the connected registry and its
                                  parent.
                                "schedule": "str",  # Optional. The cron expression
                                  indicating the schedule that the connected registry will sync with
                                  its parent.
                                "syncWindow": "1 day, 0:00:00"  # Optional. The time
                                  window during which sync is enabled for each schedule occurrence.
                                  Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as
                                  per ISO8601.
                            },
                            "id": "str"  # Optional. The resource ID of the parent to
                              which the connected registry will be associated.
                        },
                        "activation": {
                            "status": "str"  # Optional. The activation status of the
                              connected registry. Known values are: "Active" and "Inactive".
                        },
                        "clientTokenIds": [
                            "str"  # Optional. The list of the ACR token resource IDs
                              used to authenticate clients to the connected registry.
                        ],
                        "connectionState": "str",  # Optional. The current connection state
                          of the connected registry. Known values are: "Online", "Offline", "Syncing",
                          and "Unhealthy".
                        "lastActivityTime": "2020-02-20 00:00:00",  # Optional. The last
                          activity time of the connected registry.
                        "logging": {
                            "auditLogStatus": "Disabled",  # Optional. Default value is
                              "Disabled". Indicates whether audit logs are enabled on the connected
                              registry. Known values are: "Enabled" and "Disabled".
                            "logLevel": "Information"  # Optional. Default value is
                              "Information". The verbosity of logs persisted on the connected registry.
                              Known values are: "Debug", "Information", "Warning", "Error", and "None".
                        },
                        "loginServer": {
                            "host": "str",  # Optional. The host of the connected
                              registry. Can be FQDN or IP.
                            "tls": {
                                "certificate": {
                                    "location": "str",  # Optional. Indicates the
                                      location of the certificates.
                                    "type": "str"  # Optional. The type of
                                      certificate location. "LocalDirectory"
                                },
                                "status": "str"  # Optional. Indicates whether HTTPS
                                  is enabled for the login server. Known values are: "Enabled" and
                                  "Disabled".
                            }
                        },
                        "notificationsList": [
                            "str"  # Optional. The list of notifications subscription
                              information for the connected registry.
                        ],
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "statusDetails": [
                            {
                                "code": "str",  # Optional. The code of the status.
                                "correlationId": "str",  # Optional. The correlation
                                  ID of the status.
                                "description": "str",  # Optional. The description of
                                  the status.
                                "timestamp": "2020-02-20 00:00:00",  # Optional. The
                                  timestamp of the status.
                                "type": "str"  # Optional. The component of the
                                  connected registry corresponding to the status.
                            }
                        ],
                        "version": "str"  # Optional. The current version of ACR runtime on
                          the connected registry.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        registry_name: str,
        connected_registry_name: str,
        connected_registry_update_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a connected registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param connected_registry_name: The name of the connected registry. Required.
        :type connected_registry_name: str
        :param connected_registry_update_parameters: The parameters for updating a connectedRegistry.
         Required.
        :type connected_registry_update_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "mode": "str",  # The mode of the connected registry resource that
                          indicates the permissions of the registry. Required. Known values are:
                          "ReadWrite", "ReadOnly", "Registry", and "Mirror".
                        "parent": {
                            "syncProperties": {
                                "messageTtl": "1 day, 0:00:00",  # The period of time
                                  for which a message is available to sync before it is expired.
                                  Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as
                                  per ISO8601. Required.
                                "tokenId": "str",  # The resource ID of the ACR token
                                  used to authenticate the connected registry to its parent during
                                  sync. Required.
                                "gatewayEndpoint": "str",  # Optional. The gateway
                                  endpoint used by the connected registry to communicate with its
                                  parent.
                                "lastSyncTime": "2020-02-20 00:00:00",  # Optional.
                                  The last time a sync occurred between the connected registry and its
                                  parent.
                                "schedule": "str",  # Optional. The cron expression
                                  indicating the schedule that the connected registry will sync with
                                  its parent.
                                "syncWindow": "1 day, 0:00:00"  # Optional. The time
                                  window during which sync is enabled for each schedule occurrence.
                                  Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as
                                  per ISO8601.
                            },
                            "id": "str"  # Optional. The resource ID of the parent to
                              which the connected registry will be associated.
                        },
                        "activation": {
                            "status": "str"  # Optional. The activation status of the
                              connected registry. Known values are: "Active" and "Inactive".
                        },
                        "clientTokenIds": [
                            "str"  # Optional. The list of the ACR token resource IDs
                              used to authenticate clients to the connected registry.
                        ],
                        "connectionState": "str",  # Optional. The current connection state
                          of the connected registry. Known values are: "Online", "Offline", "Syncing",
                          and "Unhealthy".
                        "lastActivityTime": "2020-02-20 00:00:00",  # Optional. The last
                          activity time of the connected registry.
                        "logging": {
                            "auditLogStatus": "Disabled",  # Optional. Default value is
                              "Disabled". Indicates whether audit logs are enabled on the connected
                              registry. Known values are: "Enabled" and "Disabled".
                            "logLevel": "Information"  # Optional. Default value is
                              "Information". The verbosity of logs persisted on the connected registry.
                              Known values are: "Debug", "Information", "Warning", "Error", and "None".
                        },
                        "loginServer": {
                            "host": "str",  # Optional. The host of the connected
                              registry. Can be FQDN or IP.
                            "tls": {
                                "certificate": {
                                    "location": "str",  # Optional. Indicates the
                                      location of the certificates.
                                    "type": "str"  # Optional. The type of
                                      certificate location. "LocalDirectory"
                                },
                                "status": "str"  # Optional. Indicates whether HTTPS
                                  is enabled for the login server. Known values are: "Enabled" and
                                  "Disabled".
                            }
                        },
                        "notificationsList": [
                            "str"  # Optional. The list of notifications subscription
                              information for the connected registry.
                        ],
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "statusDetails": [
                            {
                                "code": "str",  # Optional. The code of the status.
                                "correlationId": "str",  # Optional. The correlation
                                  ID of the status.
                                "description": "str",  # Optional. The description of
                                  the status.
                                "timestamp": "2020-02-20 00:00:00",  # Optional. The
                                  timestamp of the status.
                                "type": "str"  # Optional. The component of the
                                  connected registry corresponding to the status.
                            }
                        ],
                        "version": "str"  # Optional. The current version of ACR runtime on
                          the connected registry.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_update(
        self,
        resource_group_name: str,
        registry_name: str,
        connected_registry_name: str,
        connected_registry_update_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a connected registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param connected_registry_name: The name of the connected registry. Required.
        :type connected_registry_name: str
        :param connected_registry_update_parameters: The parameters for updating a connectedRegistry.
         Is either a model type or a IO type. Required.
        :type connected_registry_update_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "mode": "str",  # The mode of the connected registry resource that
                          indicates the permissions of the registry. Required. Known values are:
                          "ReadWrite", "ReadOnly", "Registry", and "Mirror".
                        "parent": {
                            "syncProperties": {
                                "messageTtl": "1 day, 0:00:00",  # The period of time
                                  for which a message is available to sync before it is expired.
                                  Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as
                                  per ISO8601. Required.
                                "tokenId": "str",  # The resource ID of the ACR token
                                  used to authenticate the connected registry to its parent during
                                  sync. Required.
                                "gatewayEndpoint": "str",  # Optional. The gateway
                                  endpoint used by the connected registry to communicate with its
                                  parent.
                                "lastSyncTime": "2020-02-20 00:00:00",  # Optional.
                                  The last time a sync occurred between the connected registry and its
                                  parent.
                                "schedule": "str",  # Optional. The cron expression
                                  indicating the schedule that the connected registry will sync with
                                  its parent.
                                "syncWindow": "1 day, 0:00:00"  # Optional. The time
                                  window during which sync is enabled for each schedule occurrence.
                                  Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as
                                  per ISO8601.
                            },
                            "id": "str"  # Optional. The resource ID of the parent to
                              which the connected registry will be associated.
                        },
                        "activation": {
                            "status": "str"  # Optional. The activation status of the
                              connected registry. Known values are: "Active" and "Inactive".
                        },
                        "clientTokenIds": [
                            "str"  # Optional. The list of the ACR token resource IDs
                              used to authenticate clients to the connected registry.
                        ],
                        "connectionState": "str",  # Optional. The current connection state
                          of the connected registry. Known values are: "Online", "Offline", "Syncing",
                          and "Unhealthy".
                        "lastActivityTime": "2020-02-20 00:00:00",  # Optional. The last
                          activity time of the connected registry.
                        "logging": {
                            "auditLogStatus": "Disabled",  # Optional. Default value is
                              "Disabled". Indicates whether audit logs are enabled on the connected
                              registry. Known values are: "Enabled" and "Disabled".
                            "logLevel": "Information"  # Optional. Default value is
                              "Information". The verbosity of logs persisted on the connected registry.
                              Known values are: "Debug", "Information", "Warning", "Error", and "None".
                        },
                        "loginServer": {
                            "host": "str",  # Optional. The host of the connected
                              registry. Can be FQDN or IP.
                            "tls": {
                                "certificate": {
                                    "location": "str",  # Optional. Indicates the
                                      location of the certificates.
                                    "type": "str"  # Optional. The type of
                                      certificate location. "LocalDirectory"
                                },
                                "status": "str"  # Optional. Indicates whether HTTPS
                                  is enabled for the login server. Known values are: "Enabled" and
                                  "Disabled".
                            }
                        },
                        "notificationsList": [
                            "str"  # Optional. The list of notifications subscription
                              information for the connected registry.
                        ],
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "statusDetails": [
                            {
                                "code": "str",  # Optional. The code of the status.
                                "correlationId": "str",  # Optional. The correlation
                                  ID of the status.
                                "description": "str",  # Optional. The description of
                                  the status.
                                "timestamp": "2020-02-20 00:00:00",  # Optional. The
                                  timestamp of the status.
                                "type": "str"  # Optional. The component of the
                                  connected registry corresponding to the status.
                            }
                        ],
                        "version": "str"  # Optional. The current version of ACR runtime on
                          the connected registry.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                connected_registry_name=connected_registry_name,
                connected_registry_update_parameters=connected_registry_update_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _deactivate_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, registry_name: str, connected_registry_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_connected_registries_deactivate_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            connected_registry_name=connected_registry_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_deactivate(
        self, resource_group_name: str, registry_name: str, connected_registry_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Deactivates the connected registry instance.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param connected_registry_name: The name of the connected registry. Required.
        :type connected_registry_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._deactivate_initial(  # type: ignore
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                connected_registry_name=connected_registry_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class CredentialSetsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~container_registry_management_client.ContainerRegistryManagementClient`'s
        :attr:`credential_sets` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, resource_group_name: str, registry_name: str, **kwargs: Any) -> Iterable[JSON]:
        """Lists all credential set resources for the specified container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authCredentials": [
                            {
                                "credentialHealth": {
                                    "errorCode": "str",  # Optional. Error code
                                      representing the health check error.
                                    "errorMessage": "str",  # Optional.
                                      Descriptive message representing the health check error.
                                    "status": "str"  # Optional. The health
                                      status of credential. Known values are: "Healthy" and
                                      "Unhealthy".
                                },
                                "name": "str",  # Optional. The name of the
                                  credential. "Credential1"
                                "passwordSecretIdentifier": "str",  # Optional.
                                  KeyVault Secret URI for accessing the password.
                                "usernameSecretIdentifier": "str"  # Optional.
                                  KeyVault Secret URI for accessing the username.
                            }
                        ],
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of credential store resource.
                        "loginServer": "str",  # Optional. The credentials are stored for
                          this upstream or login server.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_credential_sets_list_request(
                    resource_group_name=resource_group_name,
                    registry_name=registry_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, registry_name: str, credential_set_name: str, **kwargs: Any) -> JSON:
        """Gets the properties of the specified credential set resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param credential_set_name: The name of the credential set. Required.
        :type credential_set_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authCredentials": [
                            {
                                "credentialHealth": {
                                    "errorCode": "str",  # Optional. Error code
                                      representing the health check error.
                                    "errorMessage": "str",  # Optional.
                                      Descriptive message representing the health check error.
                                    "status": "str"  # Optional. The health
                                      status of credential. Known values are: "Healthy" and
                                      "Unhealthy".
                                },
                                "name": "str",  # Optional. The name of the
                                  credential. "Credential1"
                                "passwordSecretIdentifier": "str",  # Optional.
                                  KeyVault Secret URI for accessing the password.
                                "usernameSecretIdentifier": "str"  # Optional.
                                  KeyVault Secret URI for accessing the username.
                            }
                        ],
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of credential store resource.
                        "loginServer": "str",  # Optional. The credentials are stored for
                          this upstream or login server.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_credential_sets_get_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            credential_set_name=credential_set_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_initial(
        self,
        resource_group_name: str,
        registry_name: str,
        credential_set_name: str,
        credential_set_create_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(credential_set_create_parameters, (IO, bytes)):
            _content = credential_set_create_parameters
        else:
            _json = credential_set_create_parameters

        request = build_credential_sets_create_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            credential_set_name=credential_set_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        credential_set_name: str,
        credential_set_create_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a credential set for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param credential_set_name: The name of the credential set. Required.
        :type credential_set_name: str
        :param credential_set_create_parameters: The parameters for creating a credential set.
         Required.
        :type credential_set_create_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                credential_set_create_parameters = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authCredentials": [
                            {
                                "credentialHealth": {
                                    "errorCode": "str",  # Optional. Error code
                                      representing the health check error.
                                    "errorMessage": "str",  # Optional.
                                      Descriptive message representing the health check error.
                                    "status": "str"  # Optional. The health
                                      status of credential. Known values are: "Healthy" and
                                      "Unhealthy".
                                },
                                "name": "str",  # Optional. The name of the
                                  credential. "Credential1"
                                "passwordSecretIdentifier": "str",  # Optional.
                                  KeyVault Secret URI for accessing the password.
                                "usernameSecretIdentifier": "str"  # Optional.
                                  KeyVault Secret URI for accessing the username.
                            }
                        ],
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of credential store resource.
                        "loginServer": "str",  # Optional. The credentials are stored for
                          this upstream or login server.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authCredentials": [
                            {
                                "credentialHealth": {
                                    "errorCode": "str",  # Optional. Error code
                                      representing the health check error.
                                    "errorMessage": "str",  # Optional.
                                      Descriptive message representing the health check error.
                                    "status": "str"  # Optional. The health
                                      status of credential. Known values are: "Healthy" and
                                      "Unhealthy".
                                },
                                "name": "str",  # Optional. The name of the
                                  credential. "Credential1"
                                "passwordSecretIdentifier": "str",  # Optional.
                                  KeyVault Secret URI for accessing the password.
                                "usernameSecretIdentifier": "str"  # Optional.
                                  KeyVault Secret URI for accessing the username.
                            }
                        ],
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of credential store resource.
                        "loginServer": "str",  # Optional. The credentials are stored for
                          this upstream or login server.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        credential_set_name: str,
        credential_set_create_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a credential set for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param credential_set_name: The name of the credential set. Required.
        :type credential_set_name: str
        :param credential_set_create_parameters: The parameters for creating a credential set.
         Required.
        :type credential_set_create_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authCredentials": [
                            {
                                "credentialHealth": {
                                    "errorCode": "str",  # Optional. Error code
                                      representing the health check error.
                                    "errorMessage": "str",  # Optional.
                                      Descriptive message representing the health check error.
                                    "status": "str"  # Optional. The health
                                      status of credential. Known values are: "Healthy" and
                                      "Unhealthy".
                                },
                                "name": "str",  # Optional. The name of the
                                  credential. "Credential1"
                                "passwordSecretIdentifier": "str",  # Optional.
                                  KeyVault Secret URI for accessing the password.
                                "usernameSecretIdentifier": "str"  # Optional.
                                  KeyVault Secret URI for accessing the username.
                            }
                        ],
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of credential store resource.
                        "loginServer": "str",  # Optional. The credentials are stored for
                          this upstream or login server.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        credential_set_name: str,
        credential_set_create_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a credential set for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param credential_set_name: The name of the credential set. Required.
        :type credential_set_name: str
        :param credential_set_create_parameters: The parameters for creating a credential set. Is
         either a model type or a IO type. Required.
        :type credential_set_create_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authCredentials": [
                            {
                                "credentialHealth": {
                                    "errorCode": "str",  # Optional. Error code
                                      representing the health check error.
                                    "errorMessage": "str",  # Optional.
                                      Descriptive message representing the health check error.
                                    "status": "str"  # Optional. The health
                                      status of credential. Known values are: "Healthy" and
                                      "Unhealthy".
                                },
                                "name": "str",  # Optional. The name of the
                                  credential. "Credential1"
                                "passwordSecretIdentifier": "str",  # Optional.
                                  KeyVault Secret URI for accessing the password.
                                "usernameSecretIdentifier": "str"  # Optional.
                                  KeyVault Secret URI for accessing the username.
                            }
                        ],
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of credential store resource.
                        "loginServer": "str",  # Optional. The credentials are stored for
                          this upstream or login server.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_initial(
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                credential_set_name=credential_set_name,
                credential_set_create_parameters=credential_set_create_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, registry_name: str, credential_set_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_credential_sets_delete_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            credential_set_name=credential_set_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, registry_name: str, credential_set_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Deletes a credential set from a container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param credential_set_name: The name of the credential set. Required.
        :type credential_set_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                credential_set_name=credential_set_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _update_initial(
        self,
        resource_group_name: str,
        registry_name: str,
        credential_set_name: str,
        credential_set_update_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(credential_set_update_parameters, (IO, bytes)):
            _content = credential_set_update_parameters
        else:
            _json = credential_set_update_parameters

        request = build_credential_sets_update_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            credential_set_name=credential_set_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201 or response.status_code == 202:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        registry_name: str,
        credential_set_name: str,
        credential_set_update_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a credential set for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param credential_set_name: The name of the credential set. Required.
        :type credential_set_name: str
        :param credential_set_update_parameters: The parameters for updating a credential set.
         Required.
        :type credential_set_update_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                credential_set_update_parameters = {
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "properties": {
                        "authCredentials": [
                            {
                                "credentialHealth": {
                                    "errorCode": "str",  # Optional. Error code
                                      representing the health check error.
                                    "errorMessage": "str",  # Optional.
                                      Descriptive message representing the health check error.
                                    "status": "str"  # Optional. The health
                                      status of credential. Known values are: "Healthy" and
                                      "Unhealthy".
                                },
                                "name": "str",  # Optional. The name of the
                                  credential. "Credential1"
                                "passwordSecretIdentifier": "str",  # Optional.
                                  KeyVault Secret URI for accessing the password.
                                "usernameSecretIdentifier": "str"  # Optional.
                                  KeyVault Secret URI for accessing the username.
                            }
                        ]
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authCredentials": [
                            {
                                "credentialHealth": {
                                    "errorCode": "str",  # Optional. Error code
                                      representing the health check error.
                                    "errorMessage": "str",  # Optional.
                                      Descriptive message representing the health check error.
                                    "status": "str"  # Optional. The health
                                      status of credential. Known values are: "Healthy" and
                                      "Unhealthy".
                                },
                                "name": "str",  # Optional. The name of the
                                  credential. "Credential1"
                                "passwordSecretIdentifier": "str",  # Optional.
                                  KeyVault Secret URI for accessing the password.
                                "usernameSecretIdentifier": "str"  # Optional.
                                  KeyVault Secret URI for accessing the username.
                            }
                        ],
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of credential store resource.
                        "loginServer": "str",  # Optional. The credentials are stored for
                          this upstream or login server.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        registry_name: str,
        credential_set_name: str,
        credential_set_update_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a credential set for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param credential_set_name: The name of the credential set. Required.
        :type credential_set_name: str
        :param credential_set_update_parameters: The parameters for updating a credential set.
         Required.
        :type credential_set_update_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authCredentials": [
                            {
                                "credentialHealth": {
                                    "errorCode": "str",  # Optional. Error code
                                      representing the health check error.
                                    "errorMessage": "str",  # Optional.
                                      Descriptive message representing the health check error.
                                    "status": "str"  # Optional. The health
                                      status of credential. Known values are: "Healthy" and
                                      "Unhealthy".
                                },
                                "name": "str",  # Optional. The name of the
                                  credential. "Credential1"
                                "passwordSecretIdentifier": "str",  # Optional.
                                  KeyVault Secret URI for accessing the password.
                                "usernameSecretIdentifier": "str"  # Optional.
                                  KeyVault Secret URI for accessing the username.
                            }
                        ],
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of credential store resource.
                        "loginServer": "str",  # Optional. The credentials are stored for
                          this upstream or login server.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_update(
        self,
        resource_group_name: str,
        registry_name: str,
        credential_set_name: str,
        credential_set_update_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a credential set for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param credential_set_name: The name of the credential set. Required.
        :type credential_set_name: str
        :param credential_set_update_parameters: The parameters for updating a credential set. Is
         either a model type or a IO type. Required.
        :type credential_set_update_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authCredentials": [
                            {
                                "credentialHealth": {
                                    "errorCode": "str",  # Optional. Error code
                                      representing the health check error.
                                    "errorMessage": "str",  # Optional.
                                      Descriptive message representing the health check error.
                                    "status": "str"  # Optional. The health
                                      status of credential. Known values are: "Healthy" and
                                      "Unhealthy".
                                },
                                "name": "str",  # Optional. The name of the
                                  credential. "Credential1"
                                "passwordSecretIdentifier": "str",  # Optional.
                                  KeyVault Secret URI for accessing the password.
                                "usernameSecretIdentifier": "str"  # Optional.
                                  KeyVault Secret URI for accessing the username.
                            }
                        ],
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of credential store resource.
                        "loginServer": "str",  # Optional. The credentials are stored for
                          this upstream or login server.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                credential_set_name=credential_set_name,
                credential_set_update_parameters=credential_set_update_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class ExportPipelinesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~container_registry_management_client.ContainerRegistryManagementClient`'s
        :attr:`export_pipelines` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, resource_group_name: str, registry_name: str, **kwargs: Any) -> Iterable[JSON]:
        """Lists all export pipelines for the specified container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the export pipeline.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "target": {
                            "keyVaultUri": "str",  # They key vault secret uri to obtain
                              the target storage SAS token. Required.
                            "type": "str",  # Optional. The type of target for the export
                              pipeline.
                            "uri": "str"  # Optional. The target uri of the export
                              pipeline."nWhen 'AzureStorageBlob':
                              "https://accountName.blob.core.windows.net/containerName/blobName""nWhen
                              'AzureStorageBlobContainer':
                              "https://accountName.blob.core.windows.net/containerName".
                        },
                        "options": [
                            "str"  # Optional. The list of all options configured for the
                              pipeline.
                        ],
                        "provisioningState": "str"  # Optional. The provisioning state of the
                          pipeline at the time the operation was called. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_export_pipelines_list_request(
                    resource_group_name=resource_group_name,
                    registry_name=registry_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, registry_name: str, export_pipeline_name: str, **kwargs: Any) -> JSON:
        """Gets the properties of the export pipeline.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param export_pipeline_name: The name of the export pipeline. Required.
        :type export_pipeline_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the export pipeline.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "target": {
                            "keyVaultUri": "str",  # They key vault secret uri to obtain
                              the target storage SAS token. Required.
                            "type": "str",  # Optional. The type of target for the export
                              pipeline.
                            "uri": "str"  # Optional. The target uri of the export
                              pipeline."nWhen 'AzureStorageBlob':
                              "https://accountName.blob.core.windows.net/containerName/blobName""nWhen
                              'AzureStorageBlobContainer':
                              "https://accountName.blob.core.windows.net/containerName".
                        },
                        "options": [
                            "str"  # Optional. The list of all options configured for the
                              pipeline.
                        ],
                        "provisioningState": "str"  # Optional. The provisioning state of the
                          pipeline at the time the operation was called. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_export_pipelines_get_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            export_pipeline_name=export_pipeline_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_initial(
        self,
        resource_group_name: str,
        registry_name: str,
        export_pipeline_name: str,
        export_pipeline_create_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(export_pipeline_create_parameters, (IO, bytes)):
            _content = export_pipeline_create_parameters
        else:
            _json = export_pipeline_create_parameters

        request = build_export_pipelines_create_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            export_pipeline_name=export_pipeline_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        export_pipeline_name: str,
        export_pipeline_create_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates an export pipeline for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param export_pipeline_name: The name of the export pipeline. Required.
        :type export_pipeline_name: str
        :param export_pipeline_create_parameters: The parameters for creating an export pipeline.
         Required.
        :type export_pipeline_create_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                export_pipeline_create_parameters = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the export pipeline.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "target": {
                            "keyVaultUri": "str",  # They key vault secret uri to obtain
                              the target storage SAS token. Required.
                            "type": "str",  # Optional. The type of target for the export
                              pipeline.
                            "uri": "str"  # Optional. The target uri of the export
                              pipeline."nWhen 'AzureStorageBlob':
                              "https://accountName.blob.core.windows.net/containerName/blobName""nWhen
                              'AzureStorageBlobContainer':
                              "https://accountName.blob.core.windows.net/containerName".
                        },
                        "options": [
                            "str"  # Optional. The list of all options configured for the
                              pipeline.
                        ],
                        "provisioningState": "str"  # Optional. The provisioning state of the
                          pipeline at the time the operation was called. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the export pipeline.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "target": {
                            "keyVaultUri": "str",  # They key vault secret uri to obtain
                              the target storage SAS token. Required.
                            "type": "str",  # Optional. The type of target for the export
                              pipeline.
                            "uri": "str"  # Optional. The target uri of the export
                              pipeline."nWhen 'AzureStorageBlob':
                              "https://accountName.blob.core.windows.net/containerName/blobName""nWhen
                              'AzureStorageBlobContainer':
                              "https://accountName.blob.core.windows.net/containerName".
                        },
                        "options": [
                            "str"  # Optional. The list of all options configured for the
                              pipeline.
                        ],
                        "provisioningState": "str"  # Optional. The provisioning state of the
                          pipeline at the time the operation was called. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        export_pipeline_name: str,
        export_pipeline_create_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates an export pipeline for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param export_pipeline_name: The name of the export pipeline. Required.
        :type export_pipeline_name: str
        :param export_pipeline_create_parameters: The parameters for creating an export pipeline.
         Required.
        :type export_pipeline_create_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the export pipeline.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "target": {
                            "keyVaultUri": "str",  # They key vault secret uri to obtain
                              the target storage SAS token. Required.
                            "type": "str",  # Optional. The type of target for the export
                              pipeline.
                            "uri": "str"  # Optional. The target uri of the export
                              pipeline."nWhen 'AzureStorageBlob':
                              "https://accountName.blob.core.windows.net/containerName/blobName""nWhen
                              'AzureStorageBlobContainer':
                              "https://accountName.blob.core.windows.net/containerName".
                        },
                        "options": [
                            "str"  # Optional. The list of all options configured for the
                              pipeline.
                        ],
                        "provisioningState": "str"  # Optional. The provisioning state of the
                          pipeline at the time the operation was called. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        export_pipeline_name: str,
        export_pipeline_create_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates an export pipeline for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param export_pipeline_name: The name of the export pipeline. Required.
        :type export_pipeline_name: str
        :param export_pipeline_create_parameters: The parameters for creating an export pipeline. Is
         either a model type or a IO type. Required.
        :type export_pipeline_create_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the export pipeline.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "target": {
                            "keyVaultUri": "str",  # They key vault secret uri to obtain
                              the target storage SAS token. Required.
                            "type": "str",  # Optional. The type of target for the export
                              pipeline.
                            "uri": "str"  # Optional. The target uri of the export
                              pipeline."nWhen 'AzureStorageBlob':
                              "https://accountName.blob.core.windows.net/containerName/blobName""nWhen
                              'AzureStorageBlobContainer':
                              "https://accountName.blob.core.windows.net/containerName".
                        },
                        "options": [
                            "str"  # Optional. The list of all options configured for the
                              pipeline.
                        ],
                        "provisioningState": "str"  # Optional. The provisioning state of the
                          pipeline at the time the operation was called. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_initial(
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                export_pipeline_name=export_pipeline_name,
                export_pipeline_create_parameters=export_pipeline_create_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, registry_name: str, export_pipeline_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_export_pipelines_delete_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            export_pipeline_name=export_pipeline_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, registry_name: str, export_pipeline_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Deletes an export pipeline from a container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param export_pipeline_name: The name of the export pipeline. Required.
        :type export_pipeline_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                export_pipeline_name=export_pipeline_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class RegistriesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~container_registry_management_client.ContainerRegistryManagementClient`'s
        :attr:`registries` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def _import_image_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, registry_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IO, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_registries_import_image_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @overload
    def begin_import_image(
        self,
        resource_group_name: str,
        registry_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[None]:
        """Copies an image to this container registry from the specified container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param parameters: The parameters specifying the image to copy and the source container
         registry. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "source": {
                        "sourceImage": "str",  # Repository name of the source
                          image."nSpecify an image by repository ('hello-world'). This will use the
                          'latest' tag."nSpecify an image by tag ('hello-world:latest')."nSpecify an
                          image by sha256-based manifest digest ('hello-world@sha256:abc123').
                          Required.
                        "credentials": {
                            "password": "str",  # The password used to authenticate with
                              the source registry. Required.
                            "username": "str"  # Optional. The username to authenticate
                              with the source registry.
                        },
                        "registryUri": "str",  # Optional. The address of the source registry
                          (e.g. 'mcr.microsoft.com').
                        "resourceId": "str"  # Optional. The resource identifier of the
                          source Azure Container Registry.
                    },
                    "mode": "NoForce",  # Optional. Default value is "NoForce". When Force, any
                      existing target tags will be overwritten. When NoForce, any existing target tags
                      will fail the operation before any copying begins. Known values are: "NoForce"
                      and "Force".
                    "targetTags": [
                        "str"  # Optional. List of strings of the form repo[:tag]. When tag
                          is omitted the source will be used (or 'latest' if source tag is also
                          omitted).
                    ],
                    "untaggedTargetRepositories": [
                        "str"  # Optional. List of strings of repository names to do a
                          manifest only copy. No tag will be created.
                    ]
                }
        """

    @overload
    def begin_import_image(
        self,
        resource_group_name: str,
        registry_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[None]:
        """Copies an image to this container registry from the specified container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param parameters: The parameters specifying the image to copy and the source container
         registry. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_import_image(
        self, resource_group_name: str, registry_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[None]:
        """Copies an image to this container registry from the specified container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param parameters: The parameters specifying the image to copy and the source container
         registry. Is either a model type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._import_image_initial(  # type: ignore
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @overload
    def check_name_availability(
        self, registry_name_check_request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Checks whether the container registry name is available for use. The name must contain only
        alphanumeric characters, be globally unique, and between 5 and 50 characters in length.

        :param registry_name_check_request: The object containing information for the availability
         request. Required.
        :type registry_name_check_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                registry_name_check_request = {
                    "name": "str",  # The name of the container registry. Required.
                    "type": "Microsoft.ContainerRegistry/registries"  # Default value is
                      "Microsoft.ContainerRegistry/registries". The resource type of the container
                      registry. This field must be set to 'Microsoft.ContainerRegistry/registries'.
                      Required.
                }

                # response body for status code(s): 200
                response == {
                    "message": "str",  # Optional. If any, the error message that provides more
                      detail for the reason that the name is not available.
                    "nameAvailable": bool,  # Optional. The value that indicates whether the name
                      is available.
                    "reason": "str"  # Optional. If any, the reason that the name is not
                      available.
                }
        """

    @overload
    def check_name_availability(
        self, registry_name_check_request: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Checks whether the container registry name is available for use. The name must contain only
        alphanumeric characters, be globally unique, and between 5 and 50 characters in length.

        :param registry_name_check_request: The object containing information for the availability
         request. Required.
        :type registry_name_check_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "message": "str",  # Optional. If any, the error message that provides more
                      detail for the reason that the name is not available.
                    "nameAvailable": bool,  # Optional. The value that indicates whether the name
                      is available.
                    "reason": "str"  # Optional. If any, the reason that the name is not
                      available.
                }
        """

    @distributed_trace
    def check_name_availability(self, registry_name_check_request: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Checks whether the container registry name is available for use. The name must contain only
        alphanumeric characters, be globally unique, and between 5 and 50 characters in length.

        :param registry_name_check_request: The object containing information for the availability
         request. Is either a model type or a IO type. Required.
        :type registry_name_check_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "message": "str",  # Optional. If any, the error message that provides more
                      detail for the reason that the name is not available.
                    "nameAvailable": bool,  # Optional. The value that indicates whether the name
                      is available.
                    "reason": "str"  # Optional. If any, the reason that the name is not
                      available.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(registry_name_check_request, (IO, bytes)):
            _content = registry_name_check_request
        else:
            _json = registry_name_check_request

        request = build_registries_check_name_availability_request(
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable[JSON]:
        """Lists all the container registries under the specified subscription.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "sku": {
                        "name": "str",  # The SKU name of the container registry. Required
                          for registry creation. Required. Known values are: "Classic", "Basic",
                          "Standard", and "Premium".
                        "tier": "str"  # Optional. The SKU tier based on the SKU name. Known
                          values are: "Classic", "Basic", "Standard", and "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "adminUserEnabled": False,  # Optional. Default value is False. The
                          value that indicates whether the admin user is enabled.
                        "anonymousPullEnabled": False,  # Optional. Default value is False.
                          Enables registry-wide pull from unauthenticated clients.
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of the container registry in ISO8601 format.
                        "dataEndpointEnabled": bool,  # Optional. Enable a single data
                          endpoint per region for serving data.
                        "dataEndpointHostNames": [
                            "str"  # Optional. List of host names that will serve data
                              when dataEndpointEnabled is true.
                        ],
                        "encryption": {
                            "keyVaultProperties": {
                                "identity": "str",  # Optional. The client id of the
                                  identity which will be used to access key vault.
                                "keyIdentifier": "str",  # Optional. Key vault uri to
                                  access the encryption key.
                                "keyRotationEnabled": bool,  # Optional. Auto key
                                  rotation status for a CMK enabled registry.
                                "lastKeyRotationTimestamp": "2020-02-20 00:00:00",  #
                                  Optional. Timestamp of the last successful key rotation.
                                "versionedKeyIdentifier": "str"  # Optional. The
                                  fully qualified key identifier that includes the version of the key
                                  that is actually used for encryption.
                            },
                            "status": "str"  # Optional. Indicates whether or not the
                              encryption is enabled for container registry. Known values are: "enabled"
                              and "disabled".
                        },
                        "loginServer": "str",  # Optional. The URL that can be used to log
                          into the container registry.
                        "networkRuleBypassOptions": "str",  # Optional. Whether to allow
                          trusted Azure services to access a network restricted registry. Known values
                          are: "AzureServices" and "None".
                        "networkRuleSet": {
                            "defaultAction": "Allow",  # Default value is "Allow". The
                              default action of allow or deny when no other rules match. Known values
                              are: "Allow" and "Deny".
                            "ipRules": [
                                {
                                    "value": "str",  # Specifies the IP or IP
                                      range in CIDR format. Only IPV4 address is allowed. Required.
                                    "action": "Allow"  # Optional. Default value
                                      is "Allow". The action of IP ACL rule. "Allow"
                                }
                            ]
                        },
                        "policies": {
                            "azureADAuthenticationAsArmPolicy": {
                                "status": "enabled"  # Optional. Default value is
                                  "enabled". The value that indicates whether the policy is enabled or
                                  not. Known values are: "enabled" and "disabled".
                            },
                            "exportPolicy": {
                                "status": "enabled"  # Optional. Default value is
                                  "enabled". The value that indicates whether the policy is enabled or
                                  not. Known values are: "enabled" and "disabled".
                            },
                            "quarantinePolicy": {
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "retentionPolicy": {
                                "days": 7,  # Optional. Default value is 7. The
                                  number of days to retain an untagged manifest after which it gets
                                  purged.
                                "lastUpdatedTime": "2020-02-20 00:00:00",  #
                                  Optional. The timestamp when the policy was last updated.
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "softDeletePolicy": {
                                "lastUpdatedTime": "2020-02-20 00:00:00",  #
                                  Optional. The timestamp when the policy was last updated.
                                "retentionDays": 7,  # Optional. Default value is 7.
                                  The number of days after which a soft-deleted item is permanently
                                  deleted.
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "trustPolicy": {
                                "status": "str",  # Optional. The value that
                                  indicates whether the policy is enabled or not. Known values are:
                                  "enabled" and "disabled".
                                "type": "Notary"  # Optional. Default value is
                                  "Notary". The type of trust policy. "Notary"
                            }
                        },
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. E.g.
                                  "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. This is
                                          private endpoint resource created with Microsoft.Network
                                          resource provider.
                                    },
                                    "privateLinkServiceConnectionState": {
                                        "actionsRequired": "str",  #
                                          Optional. A message indicating if changes on the service
                                          provider require any updates on the consumer. Known values
                                          are: "None" and "Recreate".
                                        "description": "str",  # Optional.
                                          The description for connection status. For example if
                                          connection is rejected it can indicate reason for rejection.
                                        "status": "str"  # Optional. The
                                          private link service connection status. Known values are:
                                          "Approved", "Pending", "Rejected", and "Disconnected".
                                    },
                                    "provisioningState": "str"  # Optional. The
                                      provisioning state of private endpoint connection resource. Known
                                      values are: "Creating", "Updating", "Deleting", "Succeeded",
                                      "Failed", and "Canceled".
                                },
                                "systemData": {
                                    "createdAt": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp of resource creation (UTC).
                                    "createdBy": "str",  # Optional. The identity
                                      that created the resource.
                                    "createdByType": "str",  # Optional. The type
                                      of identity that created the resource. Known values are: "User",
                                      "Application", "ManagedIdentity", and "Key".
                                    "lastModifiedAt": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp of resource last modification (UTC).
                                    "lastModifiedBy": "str",  # Optional. The
                                      identity that last modified the resource.
                                    "lastModifiedByType": "str"  # Optional. The
                                      type of identity that last modified the resource. Known values
                                      are: "User", "Application", "ManagedIdentity", and "Key".
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the container registry at the time the operation was called. Known values
                          are: "Creating", "Updating", "Deleting", "Succeeded", "Failed", and
                          "Canceled".
                        "publicNetworkAccess": "str",  # Optional. Whether or not public
                          network access is allowed for the container registry. Known values are:
                          "Enabled" and "Disabled".
                        "status": {
                            "displayStatus": "str",  # Optional. The short label for the
                              status.
                            "message": "str",  # Optional. The detailed message for the
                              status, including alerts and error messages.
                            "timestamp": "2020-02-20 00:00:00"  # Optional. The timestamp
                              when the status was changed to the current value.
                        },
                        "zoneRedundancy": "str"  # Optional. Whether or not zone redundancy
                          is enabled for this container registry. Known values are: "Enabled" and
                          "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_registries_list_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable[JSON]:
        """Lists all the container registries under the specified resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "sku": {
                        "name": "str",  # The SKU name of the container registry. Required
                          for registry creation. Required. Known values are: "Classic", "Basic",
                          "Standard", and "Premium".
                        "tier": "str"  # Optional. The SKU tier based on the SKU name. Known
                          values are: "Classic", "Basic", "Standard", and "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "adminUserEnabled": False,  # Optional. Default value is False. The
                          value that indicates whether the admin user is enabled.
                        "anonymousPullEnabled": False,  # Optional. Default value is False.
                          Enables registry-wide pull from unauthenticated clients.
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of the container registry in ISO8601 format.
                        "dataEndpointEnabled": bool,  # Optional. Enable a single data
                          endpoint per region for serving data.
                        "dataEndpointHostNames": [
                            "str"  # Optional. List of host names that will serve data
                              when dataEndpointEnabled is true.
                        ],
                        "encryption": {
                            "keyVaultProperties": {
                                "identity": "str",  # Optional. The client id of the
                                  identity which will be used to access key vault.
                                "keyIdentifier": "str",  # Optional. Key vault uri to
                                  access the encryption key.
                                "keyRotationEnabled": bool,  # Optional. Auto key
                                  rotation status for a CMK enabled registry.
                                "lastKeyRotationTimestamp": "2020-02-20 00:00:00",  #
                                  Optional. Timestamp of the last successful key rotation.
                                "versionedKeyIdentifier": "str"  # Optional. The
                                  fully qualified key identifier that includes the version of the key
                                  that is actually used for encryption.
                            },
                            "status": "str"  # Optional. Indicates whether or not the
                              encryption is enabled for container registry. Known values are: "enabled"
                              and "disabled".
                        },
                        "loginServer": "str",  # Optional. The URL that can be used to log
                          into the container registry.
                        "networkRuleBypassOptions": "str",  # Optional. Whether to allow
                          trusted Azure services to access a network restricted registry. Known values
                          are: "AzureServices" and "None".
                        "networkRuleSet": {
                            "defaultAction": "Allow",  # Default value is "Allow". The
                              default action of allow or deny when no other rules match. Known values
                              are: "Allow" and "Deny".
                            "ipRules": [
                                {
                                    "value": "str",  # Specifies the IP or IP
                                      range in CIDR format. Only IPV4 address is allowed. Required.
                                    "action": "Allow"  # Optional. Default value
                                      is "Allow". The action of IP ACL rule. "Allow"
                                }
                            ]
                        },
                        "policies": {
                            "azureADAuthenticationAsArmPolicy": {
                                "status": "enabled"  # Optional. Default value is
                                  "enabled". The value that indicates whether the policy is enabled or
                                  not. Known values are: "enabled" and "disabled".
                            },
                            "exportPolicy": {
                                "status": "enabled"  # Optional. Default value is
                                  "enabled". The value that indicates whether the policy is enabled or
                                  not. Known values are: "enabled" and "disabled".
                            },
                            "quarantinePolicy": {
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "retentionPolicy": {
                                "days": 7,  # Optional. Default value is 7. The
                                  number of days to retain an untagged manifest after which it gets
                                  purged.
                                "lastUpdatedTime": "2020-02-20 00:00:00",  #
                                  Optional. The timestamp when the policy was last updated.
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "softDeletePolicy": {
                                "lastUpdatedTime": "2020-02-20 00:00:00",  #
                                  Optional. The timestamp when the policy was last updated.
                                "retentionDays": 7,  # Optional. Default value is 7.
                                  The number of days after which a soft-deleted item is permanently
                                  deleted.
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "trustPolicy": {
                                "status": "str",  # Optional. The value that
                                  indicates whether the policy is enabled or not. Known values are:
                                  "enabled" and "disabled".
                                "type": "Notary"  # Optional. Default value is
                                  "Notary". The type of trust policy. "Notary"
                            }
                        },
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. E.g.
                                  "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. This is
                                          private endpoint resource created with Microsoft.Network
                                          resource provider.
                                    },
                                    "privateLinkServiceConnectionState": {
                                        "actionsRequired": "str",  #
                                          Optional. A message indicating if changes on the service
                                          provider require any updates on the consumer. Known values
                                          are: "None" and "Recreate".
                                        "description": "str",  # Optional.
                                          The description for connection status. For example if
                                          connection is rejected it can indicate reason for rejection.
                                        "status": "str"  # Optional. The
                                          private link service connection status. Known values are:
                                          "Approved", "Pending", "Rejected", and "Disconnected".
                                    },
                                    "provisioningState": "str"  # Optional. The
                                      provisioning state of private endpoint connection resource. Known
                                      values are: "Creating", "Updating", "Deleting", "Succeeded",
                                      "Failed", and "Canceled".
                                },
                                "systemData": {
                                    "createdAt": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp of resource creation (UTC).
                                    "createdBy": "str",  # Optional. The identity
                                      that created the resource.
                                    "createdByType": "str",  # Optional. The type
                                      of identity that created the resource. Known values are: "User",
                                      "Application", "ManagedIdentity", and "Key".
                                    "lastModifiedAt": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp of resource last modification (UTC).
                                    "lastModifiedBy": "str",  # Optional. The
                                      identity that last modified the resource.
                                    "lastModifiedByType": "str"  # Optional. The
                                      type of identity that last modified the resource. Known values
                                      are: "User", "Application", "ManagedIdentity", and "Key".
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the container registry at the time the operation was called. Known values
                          are: "Creating", "Updating", "Deleting", "Succeeded", "Failed", and
                          "Canceled".
                        "publicNetworkAccess": "str",  # Optional. Whether or not public
                          network access is allowed for the container registry. Known values are:
                          "Enabled" and "Disabled".
                        "status": {
                            "displayStatus": "str",  # Optional. The short label for the
                              status.
                            "message": "str",  # Optional. The detailed message for the
                              status, including alerts and error messages.
                            "timestamp": "2020-02-20 00:00:00"  # Optional. The timestamp
                              when the status was changed to the current value.
                        },
                        "zoneRedundancy": "str"  # Optional. Whether or not zone redundancy
                          is enabled for this container registry. Known values are: "Enabled" and
                          "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_registries_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, registry_name: str, **kwargs: Any) -> JSON:
        """Gets the properties of the specified container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "sku": {
                        "name": "str",  # The SKU name of the container registry. Required
                          for registry creation. Required. Known values are: "Classic", "Basic",
                          "Standard", and "Premium".
                        "tier": "str"  # Optional. The SKU tier based on the SKU name. Known
                          values are: "Classic", "Basic", "Standard", and "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "adminUserEnabled": False,  # Optional. Default value is False. The
                          value that indicates whether the admin user is enabled.
                        "anonymousPullEnabled": False,  # Optional. Default value is False.
                          Enables registry-wide pull from unauthenticated clients.
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of the container registry in ISO8601 format.
                        "dataEndpointEnabled": bool,  # Optional. Enable a single data
                          endpoint per region for serving data.
                        "dataEndpointHostNames": [
                            "str"  # Optional. List of host names that will serve data
                              when dataEndpointEnabled is true.
                        ],
                        "encryption": {
                            "keyVaultProperties": {
                                "identity": "str",  # Optional. The client id of the
                                  identity which will be used to access key vault.
                                "keyIdentifier": "str",  # Optional. Key vault uri to
                                  access the encryption key.
                                "keyRotationEnabled": bool,  # Optional. Auto key
                                  rotation status for a CMK enabled registry.
                                "lastKeyRotationTimestamp": "2020-02-20 00:00:00",  #
                                  Optional. Timestamp of the last successful key rotation.
                                "versionedKeyIdentifier": "str"  # Optional. The
                                  fully qualified key identifier that includes the version of the key
                                  that is actually used for encryption.
                            },
                            "status": "str"  # Optional. Indicates whether or not the
                              encryption is enabled for container registry. Known values are: "enabled"
                              and "disabled".
                        },
                        "loginServer": "str",  # Optional. The URL that can be used to log
                          into the container registry.
                        "networkRuleBypassOptions": "str",  # Optional. Whether to allow
                          trusted Azure services to access a network restricted registry. Known values
                          are: "AzureServices" and "None".
                        "networkRuleSet": {
                            "defaultAction": "Allow",  # Default value is "Allow". The
                              default action of allow or deny when no other rules match. Known values
                              are: "Allow" and "Deny".
                            "ipRules": [
                                {
                                    "value": "str",  # Specifies the IP or IP
                                      range in CIDR format. Only IPV4 address is allowed. Required.
                                    "action": "Allow"  # Optional. Default value
                                      is "Allow". The action of IP ACL rule. "Allow"
                                }
                            ]
                        },
                        "policies": {
                            "azureADAuthenticationAsArmPolicy": {
                                "status": "enabled"  # Optional. Default value is
                                  "enabled". The value that indicates whether the policy is enabled or
                                  not. Known values are: "enabled" and "disabled".
                            },
                            "exportPolicy": {
                                "status": "enabled"  # Optional. Default value is
                                  "enabled". The value that indicates whether the policy is enabled or
                                  not. Known values are: "enabled" and "disabled".
                            },
                            "quarantinePolicy": {
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "retentionPolicy": {
                                "days": 7,  # Optional. Default value is 7. The
                                  number of days to retain an untagged manifest after which it gets
                                  purged.
                                "lastUpdatedTime": "2020-02-20 00:00:00",  #
                                  Optional. The timestamp when the policy was last updated.
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "softDeletePolicy": {
                                "lastUpdatedTime": "2020-02-20 00:00:00",  #
                                  Optional. The timestamp when the policy was last updated.
                                "retentionDays": 7,  # Optional. Default value is 7.
                                  The number of days after which a soft-deleted item is permanently
                                  deleted.
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "trustPolicy": {
                                "status": "str",  # Optional. The value that
                                  indicates whether the policy is enabled or not. Known values are:
                                  "enabled" and "disabled".
                                "type": "Notary"  # Optional. Default value is
                                  "Notary". The type of trust policy. "Notary"
                            }
                        },
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. E.g.
                                  "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. This is
                                          private endpoint resource created with Microsoft.Network
                                          resource provider.
                                    },
                                    "privateLinkServiceConnectionState": {
                                        "actionsRequired": "str",  #
                                          Optional. A message indicating if changes on the service
                                          provider require any updates on the consumer. Known values
                                          are: "None" and "Recreate".
                                        "description": "str",  # Optional.
                                          The description for connection status. For example if
                                          connection is rejected it can indicate reason for rejection.
                                        "status": "str"  # Optional. The
                                          private link service connection status. Known values are:
                                          "Approved", "Pending", "Rejected", and "Disconnected".
                                    },
                                    "provisioningState": "str"  # Optional. The
                                      provisioning state of private endpoint connection resource. Known
                                      values are: "Creating", "Updating", "Deleting", "Succeeded",
                                      "Failed", and "Canceled".
                                },
                                "systemData": {
                                    "createdAt": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp of resource creation (UTC).
                                    "createdBy": "str",  # Optional. The identity
                                      that created the resource.
                                    "createdByType": "str",  # Optional. The type
                                      of identity that created the resource. Known values are: "User",
                                      "Application", "ManagedIdentity", and "Key".
                                    "lastModifiedAt": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp of resource last modification (UTC).
                                    "lastModifiedBy": "str",  # Optional. The
                                      identity that last modified the resource.
                                    "lastModifiedByType": "str"  # Optional. The
                                      type of identity that last modified the resource. Known values
                                      are: "User", "Application", "ManagedIdentity", and "Key".
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the container registry at the time the operation was called. Known values
                          are: "Creating", "Updating", "Deleting", "Succeeded", "Failed", and
                          "Canceled".
                        "publicNetworkAccess": "str",  # Optional. Whether or not public
                          network access is allowed for the container registry. Known values are:
                          "Enabled" and "Disabled".
                        "status": {
                            "displayStatus": "str",  # Optional. The short label for the
                              status.
                            "message": "str",  # Optional. The detailed message for the
                              status, including alerts and error messages.
                            "timestamp": "2020-02-20 00:00:00"  # Optional. The timestamp
                              when the status was changed to the current value.
                        },
                        "zoneRedundancy": "str"  # Optional. Whether or not zone redundancy
                          is enabled for this container registry. Known values are: "Enabled" and
                          "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_registries_get_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_initial(
        self, resource_group_name: str, registry_name: str, registry: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(registry, (IO, bytes)):
            _content = registry
        else:
            _json = registry

        request = build_registries_create_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        registry: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param registry: The parameters for creating a container registry. Required.
        :type registry: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                registry = {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "sku": {
                        "name": "str",  # The SKU name of the container registry. Required
                          for registry creation. Required. Known values are: "Classic", "Basic",
                          "Standard", and "Premium".
                        "tier": "str"  # Optional. The SKU tier based on the SKU name. Known
                          values are: "Classic", "Basic", "Standard", and "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "adminUserEnabled": False,  # Optional. Default value is False. The
                          value that indicates whether the admin user is enabled.
                        "anonymousPullEnabled": False,  # Optional. Default value is False.
                          Enables registry-wide pull from unauthenticated clients.
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of the container registry in ISO8601 format.
                        "dataEndpointEnabled": bool,  # Optional. Enable a single data
                          endpoint per region for serving data.
                        "dataEndpointHostNames": [
                            "str"  # Optional. List of host names that will serve data
                              when dataEndpointEnabled is true.
                        ],
                        "encryption": {
                            "keyVaultProperties": {
                                "identity": "str",  # Optional. The client id of the
                                  identity which will be used to access key vault.
                                "keyIdentifier": "str",  # Optional. Key vault uri to
                                  access the encryption key.
                                "keyRotationEnabled": bool,  # Optional. Auto key
                                  rotation status for a CMK enabled registry.
                                "lastKeyRotationTimestamp": "2020-02-20 00:00:00",  #
                                  Optional. Timestamp of the last successful key rotation.
                                "versionedKeyIdentifier": "str"  # Optional. The
                                  fully qualified key identifier that includes the version of the key
                                  that is actually used for encryption.
                            },
                            "status": "str"  # Optional. Indicates whether or not the
                              encryption is enabled for container registry. Known values are: "enabled"
                              and "disabled".
                        },
                        "loginServer": "str",  # Optional. The URL that can be used to log
                          into the container registry.
                        "networkRuleBypassOptions": "str",  # Optional. Whether to allow
                          trusted Azure services to access a network restricted registry. Known values
                          are: "AzureServices" and "None".
                        "networkRuleSet": {
                            "defaultAction": "Allow",  # Default value is "Allow". The
                              default action of allow or deny when no other rules match. Known values
                              are: "Allow" and "Deny".
                            "ipRules": [
                                {
                                    "value": "str",  # Specifies the IP or IP
                                      range in CIDR format. Only IPV4 address is allowed. Required.
                                    "action": "Allow"  # Optional. Default value
                                      is "Allow". The action of IP ACL rule. "Allow"
                                }
                            ]
                        },
                        "policies": {
                            "azureADAuthenticationAsArmPolicy": {
                                "status": "enabled"  # Optional. Default value is
                                  "enabled". The value that indicates whether the policy is enabled or
                                  not. Known values are: "enabled" and "disabled".
                            },
                            "exportPolicy": {
                                "status": "enabled"  # Optional. Default value is
                                  "enabled". The value that indicates whether the policy is enabled or
                                  not. Known values are: "enabled" and "disabled".
                            },
                            "quarantinePolicy": {
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "retentionPolicy": {
                                "days": 7,  # Optional. Default value is 7. The
                                  number of days to retain an untagged manifest after which it gets
                                  purged.
                                "lastUpdatedTime": "2020-02-20 00:00:00",  #
                                  Optional. The timestamp when the policy was last updated.
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "softDeletePolicy": {
                                "lastUpdatedTime": "2020-02-20 00:00:00",  #
                                  Optional. The timestamp when the policy was last updated.
                                "retentionDays": 7,  # Optional. Default value is 7.
                                  The number of days after which a soft-deleted item is permanently
                                  deleted.
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "trustPolicy": {
                                "status": "str",  # Optional. The value that
                                  indicates whether the policy is enabled or not. Known values are:
                                  "enabled" and "disabled".
                                "type": "Notary"  # Optional. Default value is
                                  "Notary". The type of trust policy. "Notary"
                            }
                        },
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. E.g.
                                  "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. This is
                                          private endpoint resource created with Microsoft.Network
                                          resource provider.
                                    },
                                    "privateLinkServiceConnectionState": {
                                        "actionsRequired": "str",  #
                                          Optional. A message indicating if changes on the service
                                          provider require any updates on the consumer. Known values
                                          are: "None" and "Recreate".
                                        "description": "str",  # Optional.
                                          The description for connection status. For example if
                                          connection is rejected it can indicate reason for rejection.
                                        "status": "str"  # Optional. The
                                          private link service connection status. Known values are:
                                          "Approved", "Pending", "Rejected", and "Disconnected".
                                    },
                                    "provisioningState": "str"  # Optional. The
                                      provisioning state of private endpoint connection resource. Known
                                      values are: "Creating", "Updating", "Deleting", "Succeeded",
                                      "Failed", and "Canceled".
                                },
                                "systemData": {
                                    "createdAt": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp of resource creation (UTC).
                                    "createdBy": "str",  # Optional. The identity
                                      that created the resource.
                                    "createdByType": "str",  # Optional. The type
                                      of identity that created the resource. Known values are: "User",
                                      "Application", "ManagedIdentity", and "Key".
                                    "lastModifiedAt": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp of resource last modification (UTC).
                                    "lastModifiedBy": "str",  # Optional. The
                                      identity that last modified the resource.
                                    "lastModifiedByType": "str"  # Optional. The
                                      type of identity that last modified the resource. Known values
                                      are: "User", "Application", "ManagedIdentity", and "Key".
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the container registry at the time the operation was called. Known values
                          are: "Creating", "Updating", "Deleting", "Succeeded", "Failed", and
                          "Canceled".
                        "publicNetworkAccess": "str",  # Optional. Whether or not public
                          network access is allowed for the container registry. Known values are:
                          "Enabled" and "Disabled".
                        "status": {
                            "displayStatus": "str",  # Optional. The short label for the
                              status.
                            "message": "str",  # Optional. The detailed message for the
                              status, including alerts and error messages.
                            "timestamp": "2020-02-20 00:00:00"  # Optional. The timestamp
                              when the status was changed to the current value.
                        },
                        "zoneRedundancy": "str"  # Optional. Whether or not zone redundancy
                          is enabled for this container registry. Known values are: "Enabled" and
                          "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "sku": {
                        "name": "str",  # The SKU name of the container registry. Required
                          for registry creation. Required. Known values are: "Classic", "Basic",
                          "Standard", and "Premium".
                        "tier": "str"  # Optional. The SKU tier based on the SKU name. Known
                          values are: "Classic", "Basic", "Standard", and "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "adminUserEnabled": False,  # Optional. Default value is False. The
                          value that indicates whether the admin user is enabled.
                        "anonymousPullEnabled": False,  # Optional. Default value is False.
                          Enables registry-wide pull from unauthenticated clients.
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of the container registry in ISO8601 format.
                        "dataEndpointEnabled": bool,  # Optional. Enable a single data
                          endpoint per region for serving data.
                        "dataEndpointHostNames": [
                            "str"  # Optional. List of host names that will serve data
                              when dataEndpointEnabled is true.
                        ],
                        "encryption": {
                            "keyVaultProperties": {
                                "identity": "str",  # Optional. The client id of the
                                  identity which will be used to access key vault.
                                "keyIdentifier": "str",  # Optional. Key vault uri to
                                  access the encryption key.
                                "keyRotationEnabled": bool,  # Optional. Auto key
                                  rotation status for a CMK enabled registry.
                                "lastKeyRotationTimestamp": "2020-02-20 00:00:00",  #
                                  Optional. Timestamp of the last successful key rotation.
                                "versionedKeyIdentifier": "str"  # Optional. The
                                  fully qualified key identifier that includes the version of the key
                                  that is actually used for encryption.
                            },
                            "status": "str"  # Optional. Indicates whether or not the
                              encryption is enabled for container registry. Known values are: "enabled"
                              and "disabled".
                        },
                        "loginServer": "str",  # Optional. The URL that can be used to log
                          into the container registry.
                        "networkRuleBypassOptions": "str",  # Optional. Whether to allow
                          trusted Azure services to access a network restricted registry. Known values
                          are: "AzureServices" and "None".
                        "networkRuleSet": {
                            "defaultAction": "Allow",  # Default value is "Allow". The
                              default action of allow or deny when no other rules match. Known values
                              are: "Allow" and "Deny".
                            "ipRules": [
                                {
                                    "value": "str",  # Specifies the IP or IP
                                      range in CIDR format. Only IPV4 address is allowed. Required.
                                    "action": "Allow"  # Optional. Default value
                                      is "Allow". The action of IP ACL rule. "Allow"
                                }
                            ]
                        },
                        "policies": {
                            "azureADAuthenticationAsArmPolicy": {
                                "status": "enabled"  # Optional. Default value is
                                  "enabled". The value that indicates whether the policy is enabled or
                                  not. Known values are: "enabled" and "disabled".
                            },
                            "exportPolicy": {
                                "status": "enabled"  # Optional. Default value is
                                  "enabled". The value that indicates whether the policy is enabled or
                                  not. Known values are: "enabled" and "disabled".
                            },
                            "quarantinePolicy": {
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "retentionPolicy": {
                                "days": 7,  # Optional. Default value is 7. The
                                  number of days to retain an untagged manifest after which it gets
                                  purged.
                                "lastUpdatedTime": "2020-02-20 00:00:00",  #
                                  Optional. The timestamp when the policy was last updated.
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "softDeletePolicy": {
                                "lastUpdatedTime": "2020-02-20 00:00:00",  #
                                  Optional. The timestamp when the policy was last updated.
                                "retentionDays": 7,  # Optional. Default value is 7.
                                  The number of days after which a soft-deleted item is permanently
                                  deleted.
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "trustPolicy": {
                                "status": "str",  # Optional. The value that
                                  indicates whether the policy is enabled or not. Known values are:
                                  "enabled" and "disabled".
                                "type": "Notary"  # Optional. Default value is
                                  "Notary". The type of trust policy. "Notary"
                            }
                        },
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. E.g.
                                  "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. This is
                                          private endpoint resource created with Microsoft.Network
                                          resource provider.
                                    },
                                    "privateLinkServiceConnectionState": {
                                        "actionsRequired": "str",  #
                                          Optional. A message indicating if changes on the service
                                          provider require any updates on the consumer. Known values
                                          are: "None" and "Recreate".
                                        "description": "str",  # Optional.
                                          The description for connection status. For example if
                                          connection is rejected it can indicate reason for rejection.
                                        "status": "str"  # Optional. The
                                          private link service connection status. Known values are:
                                          "Approved", "Pending", "Rejected", and "Disconnected".
                                    },
                                    "provisioningState": "str"  # Optional. The
                                      provisioning state of private endpoint connection resource. Known
                                      values are: "Creating", "Updating", "Deleting", "Succeeded",
                                      "Failed", and "Canceled".
                                },
                                "systemData": {
                                    "createdAt": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp of resource creation (UTC).
                                    "createdBy": "str",  # Optional. The identity
                                      that created the resource.
                                    "createdByType": "str",  # Optional. The type
                                      of identity that created the resource. Known values are: "User",
                                      "Application", "ManagedIdentity", and "Key".
                                    "lastModifiedAt": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp of resource last modification (UTC).
                                    "lastModifiedBy": "str",  # Optional. The
                                      identity that last modified the resource.
                                    "lastModifiedByType": "str"  # Optional. The
                                      type of identity that last modified the resource. Known values
                                      are: "User", "Application", "ManagedIdentity", and "Key".
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the container registry at the time the operation was called. Known values
                          are: "Creating", "Updating", "Deleting", "Succeeded", "Failed", and
                          "Canceled".
                        "publicNetworkAccess": "str",  # Optional. Whether or not public
                          network access is allowed for the container registry. Known values are:
                          "Enabled" and "Disabled".
                        "status": {
                            "displayStatus": "str",  # Optional. The short label for the
                              status.
                            "message": "str",  # Optional. The detailed message for the
                              status, including alerts and error messages.
                            "timestamp": "2020-02-20 00:00:00"  # Optional. The timestamp
                              when the status was changed to the current value.
                        },
                        "zoneRedundancy": "str"  # Optional. Whether or not zone redundancy
                          is enabled for this container registry. Known values are: "Enabled" and
                          "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        registry: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param registry: The parameters for creating a container registry. Required.
        :type registry: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "sku": {
                        "name": "str",  # The SKU name of the container registry. Required
                          for registry creation. Required. Known values are: "Classic", "Basic",
                          "Standard", and "Premium".
                        "tier": "str"  # Optional. The SKU tier based on the SKU name. Known
                          values are: "Classic", "Basic", "Standard", and "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "adminUserEnabled": False,  # Optional. Default value is False. The
                          value that indicates whether the admin user is enabled.
                        "anonymousPullEnabled": False,  # Optional. Default value is False.
                          Enables registry-wide pull from unauthenticated clients.
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of the container registry in ISO8601 format.
                        "dataEndpointEnabled": bool,  # Optional. Enable a single data
                          endpoint per region for serving data.
                        "dataEndpointHostNames": [
                            "str"  # Optional. List of host names that will serve data
                              when dataEndpointEnabled is true.
                        ],
                        "encryption": {
                            "keyVaultProperties": {
                                "identity": "str",  # Optional. The client id of the
                                  identity which will be used to access key vault.
                                "keyIdentifier": "str",  # Optional. Key vault uri to
                                  access the encryption key.
                                "keyRotationEnabled": bool,  # Optional. Auto key
                                  rotation status for a CMK enabled registry.
                                "lastKeyRotationTimestamp": "2020-02-20 00:00:00",  #
                                  Optional. Timestamp of the last successful key rotation.
                                "versionedKeyIdentifier": "str"  # Optional. The
                                  fully qualified key identifier that includes the version of the key
                                  that is actually used for encryption.
                            },
                            "status": "str"  # Optional. Indicates whether or not the
                              encryption is enabled for container registry. Known values are: "enabled"
                              and "disabled".
                        },
                        "loginServer": "str",  # Optional. The URL that can be used to log
                          into the container registry.
                        "networkRuleBypassOptions": "str",  # Optional. Whether to allow
                          trusted Azure services to access a network restricted registry. Known values
                          are: "AzureServices" and "None".
                        "networkRuleSet": {
                            "defaultAction": "Allow",  # Default value is "Allow". The
                              default action of allow or deny when no other rules match. Known values
                              are: "Allow" and "Deny".
                            "ipRules": [
                                {
                                    "value": "str",  # Specifies the IP or IP
                                      range in CIDR format. Only IPV4 address is allowed. Required.
                                    "action": "Allow"  # Optional. Default value
                                      is "Allow". The action of IP ACL rule. "Allow"
                                }
                            ]
                        },
                        "policies": {
                            "azureADAuthenticationAsArmPolicy": {
                                "status": "enabled"  # Optional. Default value is
                                  "enabled". The value that indicates whether the policy is enabled or
                                  not. Known values are: "enabled" and "disabled".
                            },
                            "exportPolicy": {
                                "status": "enabled"  # Optional. Default value is
                                  "enabled". The value that indicates whether the policy is enabled or
                                  not. Known values are: "enabled" and "disabled".
                            },
                            "quarantinePolicy": {
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "retentionPolicy": {
                                "days": 7,  # Optional. Default value is 7. The
                                  number of days to retain an untagged manifest after which it gets
                                  purged.
                                "lastUpdatedTime": "2020-02-20 00:00:00",  #
                                  Optional. The timestamp when the policy was last updated.
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "softDeletePolicy": {
                                "lastUpdatedTime": "2020-02-20 00:00:00",  #
                                  Optional. The timestamp when the policy was last updated.
                                "retentionDays": 7,  # Optional. Default value is 7.
                                  The number of days after which a soft-deleted item is permanently
                                  deleted.
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "trustPolicy": {
                                "status": "str",  # Optional. The value that
                                  indicates whether the policy is enabled or not. Known values are:
                                  "enabled" and "disabled".
                                "type": "Notary"  # Optional. Default value is
                                  "Notary". The type of trust policy. "Notary"
                            }
                        },
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. E.g.
                                  "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. This is
                                          private endpoint resource created with Microsoft.Network
                                          resource provider.
                                    },
                                    "privateLinkServiceConnectionState": {
                                        "actionsRequired": "str",  #
                                          Optional. A message indicating if changes on the service
                                          provider require any updates on the consumer. Known values
                                          are: "None" and "Recreate".
                                        "description": "str",  # Optional.
                                          The description for connection status. For example if
                                          connection is rejected it can indicate reason for rejection.
                                        "status": "str"  # Optional. The
                                          private link service connection status. Known values are:
                                          "Approved", "Pending", "Rejected", and "Disconnected".
                                    },
                                    "provisioningState": "str"  # Optional. The
                                      provisioning state of private endpoint connection resource. Known
                                      values are: "Creating", "Updating", "Deleting", "Succeeded",
                                      "Failed", and "Canceled".
                                },
                                "systemData": {
                                    "createdAt": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp of resource creation (UTC).
                                    "createdBy": "str",  # Optional. The identity
                                      that created the resource.
                                    "createdByType": "str",  # Optional. The type
                                      of identity that created the resource. Known values are: "User",
                                      "Application", "ManagedIdentity", and "Key".
                                    "lastModifiedAt": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp of resource last modification (UTC).
                                    "lastModifiedBy": "str",  # Optional. The
                                      identity that last modified the resource.
                                    "lastModifiedByType": "str"  # Optional. The
                                      type of identity that last modified the resource. Known values
                                      are: "User", "Application", "ManagedIdentity", and "Key".
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the container registry at the time the operation was called. Known values
                          are: "Creating", "Updating", "Deleting", "Succeeded", "Failed", and
                          "Canceled".
                        "publicNetworkAccess": "str",  # Optional. Whether or not public
                          network access is allowed for the container registry. Known values are:
                          "Enabled" and "Disabled".
                        "status": {
                            "displayStatus": "str",  # Optional. The short label for the
                              status.
                            "message": "str",  # Optional. The detailed message for the
                              status, including alerts and error messages.
                            "timestamp": "2020-02-20 00:00:00"  # Optional. The timestamp
                              when the status was changed to the current value.
                        },
                        "zoneRedundancy": "str"  # Optional. Whether or not zone redundancy
                          is enabled for this container registry. Known values are: "Enabled" and
                          "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create(
        self, resource_group_name: str, registry_name: str, registry: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param registry: The parameters for creating a container registry. Is either a model type or a
         IO type. Required.
        :type registry: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "sku": {
                        "name": "str",  # The SKU name of the container registry. Required
                          for registry creation. Required. Known values are: "Classic", "Basic",
                          "Standard", and "Premium".
                        "tier": "str"  # Optional. The SKU tier based on the SKU name. Known
                          values are: "Classic", "Basic", "Standard", and "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "adminUserEnabled": False,  # Optional. Default value is False. The
                          value that indicates whether the admin user is enabled.
                        "anonymousPullEnabled": False,  # Optional. Default value is False.
                          Enables registry-wide pull from unauthenticated clients.
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of the container registry in ISO8601 format.
                        "dataEndpointEnabled": bool,  # Optional. Enable a single data
                          endpoint per region for serving data.
                        "dataEndpointHostNames": [
                            "str"  # Optional. List of host names that will serve data
                              when dataEndpointEnabled is true.
                        ],
                        "encryption": {
                            "keyVaultProperties": {
                                "identity": "str",  # Optional. The client id of the
                                  identity which will be used to access key vault.
                                "keyIdentifier": "str",  # Optional. Key vault uri to
                                  access the encryption key.
                                "keyRotationEnabled": bool,  # Optional. Auto key
                                  rotation status for a CMK enabled registry.
                                "lastKeyRotationTimestamp": "2020-02-20 00:00:00",  #
                                  Optional. Timestamp of the last successful key rotation.
                                "versionedKeyIdentifier": "str"  # Optional. The
                                  fully qualified key identifier that includes the version of the key
                                  that is actually used for encryption.
                            },
                            "status": "str"  # Optional. Indicates whether or not the
                              encryption is enabled for container registry. Known values are: "enabled"
                              and "disabled".
                        },
                        "loginServer": "str",  # Optional. The URL that can be used to log
                          into the container registry.
                        "networkRuleBypassOptions": "str",  # Optional. Whether to allow
                          trusted Azure services to access a network restricted registry. Known values
                          are: "AzureServices" and "None".
                        "networkRuleSet": {
                            "defaultAction": "Allow",  # Default value is "Allow". The
                              default action of allow or deny when no other rules match. Known values
                              are: "Allow" and "Deny".
                            "ipRules": [
                                {
                                    "value": "str",  # Specifies the IP or IP
                                      range in CIDR format. Only IPV4 address is allowed. Required.
                                    "action": "Allow"  # Optional. Default value
                                      is "Allow". The action of IP ACL rule. "Allow"
                                }
                            ]
                        },
                        "policies": {
                            "azureADAuthenticationAsArmPolicy": {
                                "status": "enabled"  # Optional. Default value is
                                  "enabled". The value that indicates whether the policy is enabled or
                                  not. Known values are: "enabled" and "disabled".
                            },
                            "exportPolicy": {
                                "status": "enabled"  # Optional. Default value is
                                  "enabled". The value that indicates whether the policy is enabled or
                                  not. Known values are: "enabled" and "disabled".
                            },
                            "quarantinePolicy": {
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "retentionPolicy": {
                                "days": 7,  # Optional. Default value is 7. The
                                  number of days to retain an untagged manifest after which it gets
                                  purged.
                                "lastUpdatedTime": "2020-02-20 00:00:00",  #
                                  Optional. The timestamp when the policy was last updated.
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "softDeletePolicy": {
                                "lastUpdatedTime": "2020-02-20 00:00:00",  #
                                  Optional. The timestamp when the policy was last updated.
                                "retentionDays": 7,  # Optional. Default value is 7.
                                  The number of days after which a soft-deleted item is permanently
                                  deleted.
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "trustPolicy": {
                                "status": "str",  # Optional. The value that
                                  indicates whether the policy is enabled or not. Known values are:
                                  "enabled" and "disabled".
                                "type": "Notary"  # Optional. Default value is
                                  "Notary". The type of trust policy. "Notary"
                            }
                        },
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. E.g.
                                  "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. This is
                                          private endpoint resource created with Microsoft.Network
                                          resource provider.
                                    },
                                    "privateLinkServiceConnectionState": {
                                        "actionsRequired": "str",  #
                                          Optional. A message indicating if changes on the service
                                          provider require any updates on the consumer. Known values
                                          are: "None" and "Recreate".
                                        "description": "str",  # Optional.
                                          The description for connection status. For example if
                                          connection is rejected it can indicate reason for rejection.
                                        "status": "str"  # Optional. The
                                          private link service connection status. Known values are:
                                          "Approved", "Pending", "Rejected", and "Disconnected".
                                    },
                                    "provisioningState": "str"  # Optional. The
                                      provisioning state of private endpoint connection resource. Known
                                      values are: "Creating", "Updating", "Deleting", "Succeeded",
                                      "Failed", and "Canceled".
                                },
                                "systemData": {
                                    "createdAt": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp of resource creation (UTC).
                                    "createdBy": "str",  # Optional. The identity
                                      that created the resource.
                                    "createdByType": "str",  # Optional. The type
                                      of identity that created the resource. Known values are: "User",
                                      "Application", "ManagedIdentity", and "Key".
                                    "lastModifiedAt": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp of resource last modification (UTC).
                                    "lastModifiedBy": "str",  # Optional. The
                                      identity that last modified the resource.
                                    "lastModifiedByType": "str"  # Optional. The
                                      type of identity that last modified the resource. Known values
                                      are: "User", "Application", "ManagedIdentity", and "Key".
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the container registry at the time the operation was called. Known values
                          are: "Creating", "Updating", "Deleting", "Succeeded", "Failed", and
                          "Canceled".
                        "publicNetworkAccess": "str",  # Optional. Whether or not public
                          network access is allowed for the container registry. Known values are:
                          "Enabled" and "Disabled".
                        "status": {
                            "displayStatus": "str",  # Optional. The short label for the
                              status.
                            "message": "str",  # Optional. The detailed message for the
                              status, including alerts and error messages.
                            "timestamp": "2020-02-20 00:00:00"  # Optional. The timestamp
                              when the status was changed to the current value.
                        },
                        "zoneRedundancy": "str"  # Optional. Whether or not zone redundancy
                          is enabled for this container registry. Known values are: "Enabled" and
                          "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_initial(
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                registry=registry,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, registry_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_registries_delete_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(self, resource_group_name: str, registry_name: str, **kwargs: Any) -> LROPoller[None]:
        """Deletes a container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _update_initial(
        self, resource_group_name: str, registry_name: str, registry_update_parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(registry_update_parameters, (IO, bytes)):
            _content = registry_update_parameters
        else:
            _json = registry_update_parameters

        request = build_registries_update_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        registry_name: str,
        registry_update_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param registry_update_parameters: The parameters for updating a container registry. Required.
        :type registry_update_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                registry_update_parameters = {
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "properties": {
                        "adminUserEnabled": bool,  # Optional. The value that indicates
                          whether the admin user is enabled.
                        "anonymousPullEnabled": bool,  # Optional. Enables registry-wide pull
                          from unauthenticated clients.
                        "dataEndpointEnabled": bool,  # Optional. Enable a single data
                          endpoint per region for serving data.
                        "encryption": {
                            "keyVaultProperties": {
                                "identity": "str",  # Optional. The client id of the
                                  identity which will be used to access key vault.
                                "keyIdentifier": "str",  # Optional. Key vault uri to
                                  access the encryption key.
                                "keyRotationEnabled": bool,  # Optional. Auto key
                                  rotation status for a CMK enabled registry.
                                "lastKeyRotationTimestamp": "2020-02-20 00:00:00",  #
                                  Optional. Timestamp of the last successful key rotation.
                                "versionedKeyIdentifier": "str"  # Optional. The
                                  fully qualified key identifier that includes the version of the key
                                  that is actually used for encryption.
                            },
                            "status": "str"  # Optional. Indicates whether or not the
                              encryption is enabled for container registry. Known values are: "enabled"
                              and "disabled".
                        },
                        "networkRuleBypassOptions": "str",  # Optional. Whether to allow
                          trusted Azure services to access a network restricted registry. Known values
                          are: "AzureServices" and "None".
                        "networkRuleSet": {
                            "defaultAction": "Allow",  # Default value is "Allow". The
                              default action of allow or deny when no other rules match. Known values
                              are: "Allow" and "Deny".
                            "ipRules": [
                                {
                                    "value": "str",  # Specifies the IP or IP
                                      range in CIDR format. Only IPV4 address is allowed. Required.
                                    "action": "Allow"  # Optional. Default value
                                      is "Allow". The action of IP ACL rule. "Allow"
                                }
                            ]
                        },
                        "policies": {
                            "azureADAuthenticationAsArmPolicy": {
                                "status": "enabled"  # Optional. Default value is
                                  "enabled". The value that indicates whether the policy is enabled or
                                  not. Known values are: "enabled" and "disabled".
                            },
                            "exportPolicy": {
                                "status": "enabled"  # Optional. Default value is
                                  "enabled". The value that indicates whether the policy is enabled or
                                  not. Known values are: "enabled" and "disabled".
                            },
                            "quarantinePolicy": {
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "retentionPolicy": {
                                "days": 7,  # Optional. Default value is 7. The
                                  number of days to retain an untagged manifest after which it gets
                                  purged.
                                "lastUpdatedTime": "2020-02-20 00:00:00",  #
                                  Optional. The timestamp when the policy was last updated.
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "softDeletePolicy": {
                                "lastUpdatedTime": "2020-02-20 00:00:00",  #
                                  Optional. The timestamp when the policy was last updated.
                                "retentionDays": 7,  # Optional. Default value is 7.
                                  The number of days after which a soft-deleted item is permanently
                                  deleted.
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "trustPolicy": {
                                "status": "str",  # Optional. The value that
                                  indicates whether the policy is enabled or not. Known values are:
                                  "enabled" and "disabled".
                                "type": "Notary"  # Optional. Default value is
                                  "Notary". The type of trust policy. "Notary"
                            }
                        },
                        "publicNetworkAccess": "str"  # Optional. Whether or not public
                          network access is allowed for the container registry. Known values are:
                          "Enabled" and "Disabled".
                    },
                    "sku": {
                        "name": "str",  # The SKU name of the container registry. Required
                          for registry creation. Required. Known values are: "Classic", "Basic",
                          "Standard", and "Premium".
                        "tier": "str"  # Optional. The SKU tier based on the SKU name. Known
                          values are: "Classic", "Basic", "Standard", and "Premium".
                    },
                    "tags": {
                        "str": "str"  # Optional. The tags for the container registry.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "sku": {
                        "name": "str",  # The SKU name of the container registry. Required
                          for registry creation. Required. Known values are: "Classic", "Basic",
                          "Standard", and "Premium".
                        "tier": "str"  # Optional. The SKU tier based on the SKU name. Known
                          values are: "Classic", "Basic", "Standard", and "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "adminUserEnabled": False,  # Optional. Default value is False. The
                          value that indicates whether the admin user is enabled.
                        "anonymousPullEnabled": False,  # Optional. Default value is False.
                          Enables registry-wide pull from unauthenticated clients.
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of the container registry in ISO8601 format.
                        "dataEndpointEnabled": bool,  # Optional. Enable a single data
                          endpoint per region for serving data.
                        "dataEndpointHostNames": [
                            "str"  # Optional. List of host names that will serve data
                              when dataEndpointEnabled is true.
                        ],
                        "encryption": {
                            "keyVaultProperties": {
                                "identity": "str",  # Optional. The client id of the
                                  identity which will be used to access key vault.
                                "keyIdentifier": "str",  # Optional. Key vault uri to
                                  access the encryption key.
                                "keyRotationEnabled": bool,  # Optional. Auto key
                                  rotation status for a CMK enabled registry.
                                "lastKeyRotationTimestamp": "2020-02-20 00:00:00",  #
                                  Optional. Timestamp of the last successful key rotation.
                                "versionedKeyIdentifier": "str"  # Optional. The
                                  fully qualified key identifier that includes the version of the key
                                  that is actually used for encryption.
                            },
                            "status": "str"  # Optional. Indicates whether or not the
                              encryption is enabled for container registry. Known values are: "enabled"
                              and "disabled".
                        },
                        "loginServer": "str",  # Optional. The URL that can be used to log
                          into the container registry.
                        "networkRuleBypassOptions": "str",  # Optional. Whether to allow
                          trusted Azure services to access a network restricted registry. Known values
                          are: "AzureServices" and "None".
                        "networkRuleSet": {
                            "defaultAction": "Allow",  # Default value is "Allow". The
                              default action of allow or deny when no other rules match. Known values
                              are: "Allow" and "Deny".
                            "ipRules": [
                                {
                                    "value": "str",  # Specifies the IP or IP
                                      range in CIDR format. Only IPV4 address is allowed. Required.
                                    "action": "Allow"  # Optional. Default value
                                      is "Allow". The action of IP ACL rule. "Allow"
                                }
                            ]
                        },
                        "policies": {
                            "azureADAuthenticationAsArmPolicy": {
                                "status": "enabled"  # Optional. Default value is
                                  "enabled". The value that indicates whether the policy is enabled or
                                  not. Known values are: "enabled" and "disabled".
                            },
                            "exportPolicy": {
                                "status": "enabled"  # Optional. Default value is
                                  "enabled". The value that indicates whether the policy is enabled or
                                  not. Known values are: "enabled" and "disabled".
                            },
                            "quarantinePolicy": {
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "retentionPolicy": {
                                "days": 7,  # Optional. Default value is 7. The
                                  number of days to retain an untagged manifest after which it gets
                                  purged.
                                "lastUpdatedTime": "2020-02-20 00:00:00",  #
                                  Optional. The timestamp when the policy was last updated.
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "softDeletePolicy": {
                                "lastUpdatedTime": "2020-02-20 00:00:00",  #
                                  Optional. The timestamp when the policy was last updated.
                                "retentionDays": 7,  # Optional. Default value is 7.
                                  The number of days after which a soft-deleted item is permanently
                                  deleted.
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "trustPolicy": {
                                "status": "str",  # Optional. The value that
                                  indicates whether the policy is enabled or not. Known values are:
                                  "enabled" and "disabled".
                                "type": "Notary"  # Optional. Default value is
                                  "Notary". The type of trust policy. "Notary"
                            }
                        },
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. E.g.
                                  "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. This is
                                          private endpoint resource created with Microsoft.Network
                                          resource provider.
                                    },
                                    "privateLinkServiceConnectionState": {
                                        "actionsRequired": "str",  #
                                          Optional. A message indicating if changes on the service
                                          provider require any updates on the consumer. Known values
                                          are: "None" and "Recreate".
                                        "description": "str",  # Optional.
                                          The description for connection status. For example if
                                          connection is rejected it can indicate reason for rejection.
                                        "status": "str"  # Optional. The
                                          private link service connection status. Known values are:
                                          "Approved", "Pending", "Rejected", and "Disconnected".
                                    },
                                    "provisioningState": "str"  # Optional. The
                                      provisioning state of private endpoint connection resource. Known
                                      values are: "Creating", "Updating", "Deleting", "Succeeded",
                                      "Failed", and "Canceled".
                                },
                                "systemData": {
                                    "createdAt": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp of resource creation (UTC).
                                    "createdBy": "str",  # Optional. The identity
                                      that created the resource.
                                    "createdByType": "str",  # Optional. The type
                                      of identity that created the resource. Known values are: "User",
                                      "Application", "ManagedIdentity", and "Key".
                                    "lastModifiedAt": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp of resource last modification (UTC).
                                    "lastModifiedBy": "str",  # Optional. The
                                      identity that last modified the resource.
                                    "lastModifiedByType": "str"  # Optional. The
                                      type of identity that last modified the resource. Known values
                                      are: "User", "Application", "ManagedIdentity", and "Key".
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the container registry at the time the operation was called. Known values
                          are: "Creating", "Updating", "Deleting", "Succeeded", "Failed", and
                          "Canceled".
                        "publicNetworkAccess": "str",  # Optional. Whether or not public
                          network access is allowed for the container registry. Known values are:
                          "Enabled" and "Disabled".
                        "status": {
                            "displayStatus": "str",  # Optional. The short label for the
                              status.
                            "message": "str",  # Optional. The detailed message for the
                              status, including alerts and error messages.
                            "timestamp": "2020-02-20 00:00:00"  # Optional. The timestamp
                              when the status was changed to the current value.
                        },
                        "zoneRedundancy": "str"  # Optional. Whether or not zone redundancy
                          is enabled for this container registry. Known values are: "Enabled" and
                          "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        registry_name: str,
        registry_update_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param registry_update_parameters: The parameters for updating a container registry. Required.
        :type registry_update_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "sku": {
                        "name": "str",  # The SKU name of the container registry. Required
                          for registry creation. Required. Known values are: "Classic", "Basic",
                          "Standard", and "Premium".
                        "tier": "str"  # Optional. The SKU tier based on the SKU name. Known
                          values are: "Classic", "Basic", "Standard", and "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "adminUserEnabled": False,  # Optional. Default value is False. The
                          value that indicates whether the admin user is enabled.
                        "anonymousPullEnabled": False,  # Optional. Default value is False.
                          Enables registry-wide pull from unauthenticated clients.
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of the container registry in ISO8601 format.
                        "dataEndpointEnabled": bool,  # Optional. Enable a single data
                          endpoint per region for serving data.
                        "dataEndpointHostNames": [
                            "str"  # Optional. List of host names that will serve data
                              when dataEndpointEnabled is true.
                        ],
                        "encryption": {
                            "keyVaultProperties": {
                                "identity": "str",  # Optional. The client id of the
                                  identity which will be used to access key vault.
                                "keyIdentifier": "str",  # Optional. Key vault uri to
                                  access the encryption key.
                                "keyRotationEnabled": bool,  # Optional. Auto key
                                  rotation status for a CMK enabled registry.
                                "lastKeyRotationTimestamp": "2020-02-20 00:00:00",  #
                                  Optional. Timestamp of the last successful key rotation.
                                "versionedKeyIdentifier": "str"  # Optional. The
                                  fully qualified key identifier that includes the version of the key
                                  that is actually used for encryption.
                            },
                            "status": "str"  # Optional. Indicates whether or not the
                              encryption is enabled for container registry. Known values are: "enabled"
                              and "disabled".
                        },
                        "loginServer": "str",  # Optional. The URL that can be used to log
                          into the container registry.
                        "networkRuleBypassOptions": "str",  # Optional. Whether to allow
                          trusted Azure services to access a network restricted registry. Known values
                          are: "AzureServices" and "None".
                        "networkRuleSet": {
                            "defaultAction": "Allow",  # Default value is "Allow". The
                              default action of allow or deny when no other rules match. Known values
                              are: "Allow" and "Deny".
                            "ipRules": [
                                {
                                    "value": "str",  # Specifies the IP or IP
                                      range in CIDR format. Only IPV4 address is allowed. Required.
                                    "action": "Allow"  # Optional. Default value
                                      is "Allow". The action of IP ACL rule. "Allow"
                                }
                            ]
                        },
                        "policies": {
                            "azureADAuthenticationAsArmPolicy": {
                                "status": "enabled"  # Optional. Default value is
                                  "enabled". The value that indicates whether the policy is enabled or
                                  not. Known values are: "enabled" and "disabled".
                            },
                            "exportPolicy": {
                                "status": "enabled"  # Optional. Default value is
                                  "enabled". The value that indicates whether the policy is enabled or
                                  not. Known values are: "enabled" and "disabled".
                            },
                            "quarantinePolicy": {
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "retentionPolicy": {
                                "days": 7,  # Optional. Default value is 7. The
                                  number of days to retain an untagged manifest after which it gets
                                  purged.
                                "lastUpdatedTime": "2020-02-20 00:00:00",  #
                                  Optional. The timestamp when the policy was last updated.
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "softDeletePolicy": {
                                "lastUpdatedTime": "2020-02-20 00:00:00",  #
                                  Optional. The timestamp when the policy was last updated.
                                "retentionDays": 7,  # Optional. Default value is 7.
                                  The number of days after which a soft-deleted item is permanently
                                  deleted.
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "trustPolicy": {
                                "status": "str",  # Optional. The value that
                                  indicates whether the policy is enabled or not. Known values are:
                                  "enabled" and "disabled".
                                "type": "Notary"  # Optional. Default value is
                                  "Notary". The type of trust policy. "Notary"
                            }
                        },
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. E.g.
                                  "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. This is
                                          private endpoint resource created with Microsoft.Network
                                          resource provider.
                                    },
                                    "privateLinkServiceConnectionState": {
                                        "actionsRequired": "str",  #
                                          Optional. A message indicating if changes on the service
                                          provider require any updates on the consumer. Known values
                                          are: "None" and "Recreate".
                                        "description": "str",  # Optional.
                                          The description for connection status. For example if
                                          connection is rejected it can indicate reason for rejection.
                                        "status": "str"  # Optional. The
                                          private link service connection status. Known values are:
                                          "Approved", "Pending", "Rejected", and "Disconnected".
                                    },
                                    "provisioningState": "str"  # Optional. The
                                      provisioning state of private endpoint connection resource. Known
                                      values are: "Creating", "Updating", "Deleting", "Succeeded",
                                      "Failed", and "Canceled".
                                },
                                "systemData": {
                                    "createdAt": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp of resource creation (UTC).
                                    "createdBy": "str",  # Optional. The identity
                                      that created the resource.
                                    "createdByType": "str",  # Optional. The type
                                      of identity that created the resource. Known values are: "User",
                                      "Application", "ManagedIdentity", and "Key".
                                    "lastModifiedAt": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp of resource last modification (UTC).
                                    "lastModifiedBy": "str",  # Optional. The
                                      identity that last modified the resource.
                                    "lastModifiedByType": "str"  # Optional. The
                                      type of identity that last modified the resource. Known values
                                      are: "User", "Application", "ManagedIdentity", and "Key".
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the container registry at the time the operation was called. Known values
                          are: "Creating", "Updating", "Deleting", "Succeeded", "Failed", and
                          "Canceled".
                        "publicNetworkAccess": "str",  # Optional. Whether or not public
                          network access is allowed for the container registry. Known values are:
                          "Enabled" and "Disabled".
                        "status": {
                            "displayStatus": "str",  # Optional. The short label for the
                              status.
                            "message": "str",  # Optional. The detailed message for the
                              status, including alerts and error messages.
                            "timestamp": "2020-02-20 00:00:00"  # Optional. The timestamp
                              when the status was changed to the current value.
                        },
                        "zoneRedundancy": "str"  # Optional. Whether or not zone redundancy
                          is enabled for this container registry. Known values are: "Enabled" and
                          "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_update(
        self, resource_group_name: str, registry_name: str, registry_update_parameters: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param registry_update_parameters: The parameters for updating a container registry. Is either
         a model type or a IO type. Required.
        :type registry_update_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "sku": {
                        "name": "str",  # The SKU name of the container registry. Required
                          for registry creation. Required. Known values are: "Classic", "Basic",
                          "Standard", and "Premium".
                        "tier": "str"  # Optional. The SKU tier based on the SKU name. Known
                          values are: "Classic", "Basic", "Standard", and "Premium".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "adminUserEnabled": False,  # Optional. Default value is False. The
                          value that indicates whether the admin user is enabled.
                        "anonymousPullEnabled": False,  # Optional. Default value is False.
                          Enables registry-wide pull from unauthenticated clients.
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of the container registry in ISO8601 format.
                        "dataEndpointEnabled": bool,  # Optional. Enable a single data
                          endpoint per region for serving data.
                        "dataEndpointHostNames": [
                            "str"  # Optional. List of host names that will serve data
                              when dataEndpointEnabled is true.
                        ],
                        "encryption": {
                            "keyVaultProperties": {
                                "identity": "str",  # Optional. The client id of the
                                  identity which will be used to access key vault.
                                "keyIdentifier": "str",  # Optional. Key vault uri to
                                  access the encryption key.
                                "keyRotationEnabled": bool,  # Optional. Auto key
                                  rotation status for a CMK enabled registry.
                                "lastKeyRotationTimestamp": "2020-02-20 00:00:00",  #
                                  Optional. Timestamp of the last successful key rotation.
                                "versionedKeyIdentifier": "str"  # Optional. The
                                  fully qualified key identifier that includes the version of the key
                                  that is actually used for encryption.
                            },
                            "status": "str"  # Optional. Indicates whether or not the
                              encryption is enabled for container registry. Known values are: "enabled"
                              and "disabled".
                        },
                        "loginServer": "str",  # Optional. The URL that can be used to log
                          into the container registry.
                        "networkRuleBypassOptions": "str",  # Optional. Whether to allow
                          trusted Azure services to access a network restricted registry. Known values
                          are: "AzureServices" and "None".
                        "networkRuleSet": {
                            "defaultAction": "Allow",  # Default value is "Allow". The
                              default action of allow or deny when no other rules match. Known values
                              are: "Allow" and "Deny".
                            "ipRules": [
                                {
                                    "value": "str",  # Specifies the IP or IP
                                      range in CIDR format. Only IPV4 address is allowed. Required.
                                    "action": "Allow"  # Optional. Default value
                                      is "Allow". The action of IP ACL rule. "Allow"
                                }
                            ]
                        },
                        "policies": {
                            "azureADAuthenticationAsArmPolicy": {
                                "status": "enabled"  # Optional. Default value is
                                  "enabled". The value that indicates whether the policy is enabled or
                                  not. Known values are: "enabled" and "disabled".
                            },
                            "exportPolicy": {
                                "status": "enabled"  # Optional. Default value is
                                  "enabled". The value that indicates whether the policy is enabled or
                                  not. Known values are: "enabled" and "disabled".
                            },
                            "quarantinePolicy": {
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "retentionPolicy": {
                                "days": 7,  # Optional. Default value is 7. The
                                  number of days to retain an untagged manifest after which it gets
                                  purged.
                                "lastUpdatedTime": "2020-02-20 00:00:00",  #
                                  Optional. The timestamp when the policy was last updated.
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "softDeletePolicy": {
                                "lastUpdatedTime": "2020-02-20 00:00:00",  #
                                  Optional. The timestamp when the policy was last updated.
                                "retentionDays": 7,  # Optional. Default value is 7.
                                  The number of days after which a soft-deleted item is permanently
                                  deleted.
                                "status": "str"  # Optional. The value that indicates
                                  whether the policy is enabled or not. Known values are: "enabled" and
                                  "disabled".
                            },
                            "trustPolicy": {
                                "status": "str",  # Optional. The value that
                                  indicates whether the policy is enabled or not. Known values are:
                                  "enabled" and "disabled".
                                "type": "Notary"  # Optional. Default value is
                                  "Notary". The type of trust policy. "Notary"
                            }
                        },
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. E.g.
                                  "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. This is
                                          private endpoint resource created with Microsoft.Network
                                          resource provider.
                                    },
                                    "privateLinkServiceConnectionState": {
                                        "actionsRequired": "str",  #
                                          Optional. A message indicating if changes on the service
                                          provider require any updates on the consumer. Known values
                                          are: "None" and "Recreate".
                                        "description": "str",  # Optional.
                                          The description for connection status. For example if
                                          connection is rejected it can indicate reason for rejection.
                                        "status": "str"  # Optional. The
                                          private link service connection status. Known values are:
                                          "Approved", "Pending", "Rejected", and "Disconnected".
                                    },
                                    "provisioningState": "str"  # Optional. The
                                      provisioning state of private endpoint connection resource. Known
                                      values are: "Creating", "Updating", "Deleting", "Succeeded",
                                      "Failed", and "Canceled".
                                },
                                "systemData": {
                                    "createdAt": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp of resource creation (UTC).
                                    "createdBy": "str",  # Optional. The identity
                                      that created the resource.
                                    "createdByType": "str",  # Optional. The type
                                      of identity that created the resource. Known values are: "User",
                                      "Application", "ManagedIdentity", and "Key".
                                    "lastModifiedAt": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp of resource last modification (UTC).
                                    "lastModifiedBy": "str",  # Optional. The
                                      identity that last modified the resource.
                                    "lastModifiedByType": "str"  # Optional. The
                                      type of identity that last modified the resource. Known values
                                      are: "User", "Application", "ManagedIdentity", and "Key".
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the container registry at the time the operation was called. Known values
                          are: "Creating", "Updating", "Deleting", "Succeeded", "Failed", and
                          "Canceled".
                        "publicNetworkAccess": "str",  # Optional. Whether or not public
                          network access is allowed for the container registry. Known values are:
                          "Enabled" and "Disabled".
                        "status": {
                            "displayStatus": "str",  # Optional. The short label for the
                              status.
                            "message": "str",  # Optional. The detailed message for the
                              status, including alerts and error messages.
                            "timestamp": "2020-02-20 00:00:00"  # Optional. The timestamp
                              when the status was changed to the current value.
                        },
                        "zoneRedundancy": "str"  # Optional. Whether or not zone redundancy
                          is enabled for this container registry. Known values are: "Enabled" and
                          "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                registry_update_parameters=registry_update_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list_usages(self, resource_group_name: str, registry_name: str, **kwargs: Any) -> JSON:
        """Gets the quota usages for the specified container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "currentValue": 0,  # Optional. The current value of the
                              usage.
                            "limit": 0,  # Optional. The limit of the usage.
                            "name": "str",  # Optional. The name of the usage.
                            "unit": "str"  # Optional. The unit of measurement. Known
                              values are: "Count" and "Bytes".
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_registries_list_usages_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list_private_link_resources(
        self, resource_group_name: str, registry_name: str, **kwargs: Any
    ) -> Iterable[JSON]:
        """Lists the private link resources for a container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The resource ID.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "groupId": "str",  # Optional. The private link resource group id.
                        "requiredMembers": [
                            "str"  # Optional. The private link resource required member
                              names.
                        ],
                        "requiredZoneNames": [
                            "str"  # Optional. The private link resource Private link DNS
                              zone name.
                        ]
                    },
                    "type": "str"  # Optional. The resource type is private link resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_registries_list_private_link_resources_request(
                    resource_group_name=resource_group_name,
                    registry_name=registry_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_private_link_resource(
        self, resource_group_name: str, registry_name: str, group_name: str, **kwargs: Any
    ) -> JSON:
        """Gets a private link resource by a specified group name for a container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param group_name: The name of the private link resource. Required.
        :type group_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The resource ID.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "groupId": "str",  # Optional. The private link resource group id.
                        "requiredMembers": [
                            "str"  # Optional. The private link resource required member
                              names.
                        ],
                        "requiredZoneNames": [
                            "str"  # Optional. The private link resource Private link DNS
                              zone name.
                        ]
                    },
                    "type": "str"  # Optional. The resource type is private link resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_registries_get_private_link_resource_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            group_name=group_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list_credentials(self, resource_group_name: str, registry_name: str, **kwargs: Any) -> JSON:
        """Lists the login credentials for the specified container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "passwords": [
                        {
                            "name": "str",  # Optional. The password name. Known values
                              are: "password" and "password2".
                            "value": "str"  # Optional. The password value.
                        }
                    ],
                    "username": "str"  # Optional. The username for a container registry.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_registries_list_credentials_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def regenerate_credential(
        self,
        resource_group_name: str,
        registry_name: str,
        regenerate_credential_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Regenerates one of the login credentials for the specified container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param regenerate_credential_parameters: Specifies name of the password which should be
         regenerated -- password or password2. Required.
        :type regenerate_credential_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                regenerate_credential_parameters = {
                    "name": "str"  # Specifies name of the password which should be regenerated
                      -- password or password2. Required. Known values are: "password" and "password2".
                }

                # response body for status code(s): 200
                response == {
                    "passwords": [
                        {
                            "name": "str",  # Optional. The password name. Known values
                              are: "password" and "password2".
                            "value": "str"  # Optional. The password value.
                        }
                    ],
                    "username": "str"  # Optional. The username for a container registry.
                }
        """

    @overload
    def regenerate_credential(
        self,
        resource_group_name: str,
        registry_name: str,
        regenerate_credential_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Regenerates one of the login credentials for the specified container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param regenerate_credential_parameters: Specifies name of the password which should be
         regenerated -- password or password2. Required.
        :type regenerate_credential_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "passwords": [
                        {
                            "name": "str",  # Optional. The password name. Known values
                              are: "password" and "password2".
                            "value": "str"  # Optional. The password value.
                        }
                    ],
                    "username": "str"  # Optional. The username for a container registry.
                }
        """

    @distributed_trace
    def regenerate_credential(
        self,
        resource_group_name: str,
        registry_name: str,
        regenerate_credential_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Regenerates one of the login credentials for the specified container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param regenerate_credential_parameters: Specifies name of the password which should be
         regenerated -- password or password2. Is either a model type or a IO type. Required.
        :type regenerate_credential_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "passwords": [
                        {
                            "name": "str",  # Optional. The password name. Known values
                              are: "password" and "password2".
                            "value": "str"  # Optional. The password value.
                        }
                    ],
                    "username": "str"  # Optional. The username for a container registry.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(regenerate_credential_parameters, (IO, bytes)):
            _content = regenerate_credential_parameters
        else:
            _json = regenerate_credential_parameters

        request = build_registries_regenerate_credential_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _generate_credentials_initial(
        self,
        resource_group_name: str,
        registry_name: str,
        generate_credentials_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(generate_credentials_parameters, (IO, bytes)):
            _content = generate_credentials_parameters
        else:
            _json = generate_credentials_parameters

        request = build_registries_generate_credentials_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    @overload
    def begin_generate_credentials(
        self,
        resource_group_name: str,
        registry_name: str,
        generate_credentials_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Generate keys for a token of a specified container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param generate_credentials_parameters: The parameters for generating credentials. Required.
        :type generate_credentials_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                generate_credentials_parameters = {
                    "expiry": "2020-02-20 00:00:00",  # Optional. The expiry date of the
                      generated credentials after which the credentials become invalid.
                    "name": "str",  # Optional. Specifies name of the password which should be
                      regenerated if any -- password1 or password2. Known values are: "password1" and
                      "password2".
                    "tokenId": "str"  # Optional. The resource ID of the token for which
                      credentials have to be generated.
                }

                # response body for status code(s): 200
                response == {
                    "passwords": [
                        {
                            "creationTime": "2020-02-20 00:00:00",  # Optional. The
                              creation datetime of the password.
                            "expiry": "2020-02-20 00:00:00",  # Optional. The expiry
                              datetime of the password.
                            "name": "str",  # Optional. The password name "password1" or
                              "password2". Known values are: "password1" and "password2".
                            "value": "str"  # Optional. The password value.
                        }
                    ],
                    "username": "str"  # Optional. The username for a container registry.
                }
        """

    @overload
    def begin_generate_credentials(
        self,
        resource_group_name: str,
        registry_name: str,
        generate_credentials_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Generate keys for a token of a specified container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param generate_credentials_parameters: The parameters for generating credentials. Required.
        :type generate_credentials_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "passwords": [
                        {
                            "creationTime": "2020-02-20 00:00:00",  # Optional. The
                              creation datetime of the password.
                            "expiry": "2020-02-20 00:00:00",  # Optional. The expiry
                              datetime of the password.
                            "name": "str",  # Optional. The password name "password1" or
                              "password2". Known values are: "password1" and "password2".
                            "value": "str"  # Optional. The password value.
                        }
                    ],
                    "username": "str"  # Optional. The username for a container registry.
                }
        """

    @distributed_trace
    def begin_generate_credentials(
        self,
        resource_group_name: str,
        registry_name: str,
        generate_credentials_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Generate keys for a token of a specified container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param generate_credentials_parameters: The parameters for generating credentials. Is either a
         model type or a IO type. Required.
        :type generate_credentials_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "passwords": [
                        {
                            "creationTime": "2020-02-20 00:00:00",  # Optional. The
                              creation datetime of the password.
                            "expiry": "2020-02-20 00:00:00",  # Optional. The expiry
                              datetime of the password.
                            "name": "str",  # Optional. The password name "password1" or
                              "password2". Known values are: "password1" and "password2".
                            "value": "str"  # Optional. The password value.
                        }
                    ],
                    "username": "str"  # Optional. The username for a container registry.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._generate_credentials_initial(
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                generate_credentials_parameters=generate_credentials_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class ImportPipelinesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~container_registry_management_client.ContainerRegistryManagementClient`'s
        :attr:`import_pipelines` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, resource_group_name: str, registry_name: str, **kwargs: Any) -> Iterable[JSON]:
        """Lists all import pipelines for the specified container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the import pipeline.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "source": {
                            "keyVaultUri": "str",  # They key vault secret uri to obtain
                              the source storage SAS token. Required.
                            "type": "AzureStorageBlobContainer",  # Optional. Default
                              value is "AzureStorageBlobContainer". The type of source for the import
                              pipeline. "AzureStorageBlobContainer"
                            "uri": "str"  # Optional. The source uri of the import
                              pipeline."nWhen 'AzureStorageBlob':
                              "https://accountName.blob.core.windows.net/containerName/blobName""nWhen
                              'AzureStorageBlobContainer':
                              "https://accountName.blob.core.windows.net/containerName".
                        },
                        "options": [
                            "str"  # Optional. The list of all options configured for the
                              pipeline.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the pipeline at the time the operation was called. Known values are:
                          "Creating", "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "trigger": {
                            "sourceTrigger": {
                                "status": "Enabled"  # Default value is "Enabled".
                                  The current status of the source trigger. Known values are: "Enabled"
                                  and "Disabled".
                            }
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_import_pipelines_list_request(
                    resource_group_name=resource_group_name,
                    registry_name=registry_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, registry_name: str, import_pipeline_name: str, **kwargs: Any) -> JSON:
        """Gets the properties of the import pipeline.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param import_pipeline_name: The name of the import pipeline. Required.
        :type import_pipeline_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the import pipeline.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "source": {
                            "keyVaultUri": "str",  # They key vault secret uri to obtain
                              the source storage SAS token. Required.
                            "type": "AzureStorageBlobContainer",  # Optional. Default
                              value is "AzureStorageBlobContainer". The type of source for the import
                              pipeline. "AzureStorageBlobContainer"
                            "uri": "str"  # Optional. The source uri of the import
                              pipeline."nWhen 'AzureStorageBlob':
                              "https://accountName.blob.core.windows.net/containerName/blobName""nWhen
                              'AzureStorageBlobContainer':
                              "https://accountName.blob.core.windows.net/containerName".
                        },
                        "options": [
                            "str"  # Optional. The list of all options configured for the
                              pipeline.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the pipeline at the time the operation was called. Known values are:
                          "Creating", "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "trigger": {
                            "sourceTrigger": {
                                "status": "Enabled"  # Default value is "Enabled".
                                  The current status of the source trigger. Known values are: "Enabled"
                                  and "Disabled".
                            }
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_import_pipelines_get_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            import_pipeline_name=import_pipeline_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_initial(
        self,
        resource_group_name: str,
        registry_name: str,
        import_pipeline_name: str,
        import_pipeline_create_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(import_pipeline_create_parameters, (IO, bytes)):
            _content = import_pipeline_create_parameters
        else:
            _json = import_pipeline_create_parameters

        request = build_import_pipelines_create_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            import_pipeline_name=import_pipeline_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        import_pipeline_name: str,
        import_pipeline_create_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates an import pipeline for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param import_pipeline_name: The name of the import pipeline. Required.
        :type import_pipeline_name: str
        :param import_pipeline_create_parameters: The parameters for creating an import pipeline.
         Required.
        :type import_pipeline_create_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                import_pipeline_create_parameters = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the import pipeline.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "source": {
                            "keyVaultUri": "str",  # They key vault secret uri to obtain
                              the source storage SAS token. Required.
                            "type": "AzureStorageBlobContainer",  # Optional. Default
                              value is "AzureStorageBlobContainer". The type of source for the import
                              pipeline. "AzureStorageBlobContainer"
                            "uri": "str"  # Optional. The source uri of the import
                              pipeline."nWhen 'AzureStorageBlob':
                              "https://accountName.blob.core.windows.net/containerName/blobName""nWhen
                              'AzureStorageBlobContainer':
                              "https://accountName.blob.core.windows.net/containerName".
                        },
                        "options": [
                            "str"  # Optional. The list of all options configured for the
                              pipeline.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the pipeline at the time the operation was called. Known values are:
                          "Creating", "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "trigger": {
                            "sourceTrigger": {
                                "status": "Enabled"  # Default value is "Enabled".
                                  The current status of the source trigger. Known values are: "Enabled"
                                  and "Disabled".
                            }
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the import pipeline.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "source": {
                            "keyVaultUri": "str",  # They key vault secret uri to obtain
                              the source storage SAS token. Required.
                            "type": "AzureStorageBlobContainer",  # Optional. Default
                              value is "AzureStorageBlobContainer". The type of source for the import
                              pipeline. "AzureStorageBlobContainer"
                            "uri": "str"  # Optional. The source uri of the import
                              pipeline."nWhen 'AzureStorageBlob':
                              "https://accountName.blob.core.windows.net/containerName/blobName""nWhen
                              'AzureStorageBlobContainer':
                              "https://accountName.blob.core.windows.net/containerName".
                        },
                        "options": [
                            "str"  # Optional. The list of all options configured for the
                              pipeline.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the pipeline at the time the operation was called. Known values are:
                          "Creating", "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "trigger": {
                            "sourceTrigger": {
                                "status": "Enabled"  # Default value is "Enabled".
                                  The current status of the source trigger. Known values are: "Enabled"
                                  and "Disabled".
                            }
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        import_pipeline_name: str,
        import_pipeline_create_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates an import pipeline for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param import_pipeline_name: The name of the import pipeline. Required.
        :type import_pipeline_name: str
        :param import_pipeline_create_parameters: The parameters for creating an import pipeline.
         Required.
        :type import_pipeline_create_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the import pipeline.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "source": {
                            "keyVaultUri": "str",  # They key vault secret uri to obtain
                              the source storage SAS token. Required.
                            "type": "AzureStorageBlobContainer",  # Optional. Default
                              value is "AzureStorageBlobContainer". The type of source for the import
                              pipeline. "AzureStorageBlobContainer"
                            "uri": "str"  # Optional. The source uri of the import
                              pipeline."nWhen 'AzureStorageBlob':
                              "https://accountName.blob.core.windows.net/containerName/blobName""nWhen
                              'AzureStorageBlobContainer':
                              "https://accountName.blob.core.windows.net/containerName".
                        },
                        "options": [
                            "str"  # Optional. The list of all options configured for the
                              pipeline.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the pipeline at the time the operation was called. Known values are:
                          "Creating", "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "trigger": {
                            "sourceTrigger": {
                                "status": "Enabled"  # Default value is "Enabled".
                                  The current status of the source trigger. Known values are: "Enabled"
                                  and "Disabled".
                            }
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        import_pipeline_name: str,
        import_pipeline_create_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates an import pipeline for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param import_pipeline_name: The name of the import pipeline. Required.
        :type import_pipeline_name: str
        :param import_pipeline_create_parameters: The parameters for creating an import pipeline. Is
         either a model type or a IO type. Required.
        :type import_pipeline_create_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "location": "str",  # Optional. The location of the import pipeline.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "source": {
                            "keyVaultUri": "str",  # They key vault secret uri to obtain
                              the source storage SAS token. Required.
                            "type": "AzureStorageBlobContainer",  # Optional. Default
                              value is "AzureStorageBlobContainer". The type of source for the import
                              pipeline. "AzureStorageBlobContainer"
                            "uri": "str"  # Optional. The source uri of the import
                              pipeline."nWhen 'AzureStorageBlob':
                              "https://accountName.blob.core.windows.net/containerName/blobName""nWhen
                              'AzureStorageBlobContainer':
                              "https://accountName.blob.core.windows.net/containerName".
                        },
                        "options": [
                            "str"  # Optional. The list of all options configured for the
                              pipeline.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the pipeline at the time the operation was called. Known values are:
                          "Creating", "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "trigger": {
                            "sourceTrigger": {
                                "status": "Enabled"  # Default value is "Enabled".
                                  The current status of the source trigger. Known values are: "Enabled"
                                  and "Disabled".
                            }
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_initial(
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                import_pipeline_name=import_pipeline_name,
                import_pipeline_create_parameters=import_pipeline_create_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, registry_name: str, import_pipeline_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_import_pipelines_delete_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            import_pipeline_name=import_pipeline_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, registry_name: str, import_pipeline_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Deletes an import pipeline from a container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param import_pipeline_name: The name of the import pipeline. Required.
        :type import_pipeline_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                import_pipeline_name=import_pipeline_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class Operations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~container_registry_management_client.ContainerRegistryManagementClient`'s
        :attr:`operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable[JSON]:
        """Lists all of the available Azure Container Registry REST API operations.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "display": {
                        "description": "str",  # Optional. The description for the operation.
                        "operation": "str",  # Optional. The operation that users can
                          perform.
                        "provider": "str",  # Optional. The resource provider name:
                          Microsoft.ContainerRegistry.
                        "resource": "str"  # Optional. The resource on which the operation is
                          performed.
                    },
                    "isDataAction": bool,  # Optional. This property indicates if the operation
                      is an action or a data action"nref:
                      https://docs.microsoft.com/en-us/azure/role-based-access-control/role-definitions#management-and-data-operations.
                    "name": "str",  # Optional. Operation name:
                      {provider}/{resource}/{operation}.
                    "origin": "str",  # Optional. The origin information of the container
                      registry operation.
                    "properties": {
                        "serviceSpecification": {
                            "logSpecifications": [
                                {
                                    "blobDuration": "str",  # Optional. Log blob
                                      duration.
                                    "displayName": "str",  # Optional. Log
                                      display name.
                                    "name": "str"  # Optional. Log name.
                                }
                            ],
                            "metricSpecifications": [
                                {
                                    "aggregationType": "str",  # Optional. Metric
                                      aggregation type.
                                    "displayDescription": "str",  # Optional.
                                      Metric description.
                                    "displayName": "str",  # Optional. Metric
                                      display name.
                                    "internalMetricName": "str",  # Optional.
                                      Internal metric name.
                                    "name": "str",  # Optional. Metric name.
                                    "unit": "str"  # Optional. Metric unit.
                                }
                            ]
                        }
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_operations_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class PipelineRunsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~container_registry_management_client.ContainerRegistryManagementClient`'s
        :attr:`pipeline_runs` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, resource_group_name: str, registry_name: str, **kwargs: Any) -> Iterable[JSON]:
        """Lists all the pipeline runs for the specified container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "forceUpdateTag": "str",  # Optional. How the pipeline run should be
                          forced to recreate even if the pipeline run configuration has not changed.
                        "provisioningState": "str",  # Optional. The provisioning state of a
                          pipeline run. Known values are: "Creating", "Updating", "Deleting",
                          "Succeeded", "Failed", and "Canceled".
                        "request": {
                            "artifacts": [
                                "str"  # Optional. List of source artifacts to be
                                  transferred by the pipeline. "nSpecify an image by repository
                                  ('hello-world'). This will use the 'latest' tag."nSpecify an image by
                                  tag ('hello-world:latest')."nSpecify an image by sha256-based
                                  manifest digest ('hello-world@sha256:abc123').
                            ],
                            "catalogDigest": "str",  # Optional. The digest of the tar
                              used to transfer the artifacts.
                            "pipelineResourceId": "str",  # Optional. The resource ID of
                              the pipeline to run.
                            "source": {
                                "name": "str",  # Optional. The name of the source.
                                "type": "AzureStorageBlob"  # Optional. Default value
                                  is "AzureStorageBlob". The type of the source. "AzureStorageBlob"
                            },
                            "target": {
                                "name": "str",  # Optional. The name of the target.
                                "type": "AzureStorageBlob"  # Optional. Default value
                                  is "AzureStorageBlob". The type of the target. "AzureStorageBlob"
                            }
                        },
                        "response": {
                            "catalogDigest": "str",  # Optional. The digest of the tar
                              used to transfer the artifacts.
                            "finishTime": "2020-02-20 00:00:00",  # Optional. The time
                              the pipeline run finished.
                            "importedArtifacts": [
                                "str"  # Optional. The artifacts imported in the
                                  pipeline run.
                            ],
                            "pipelineRunErrorMessage": "str",  # Optional. The detailed
                              error message for the pipeline run in the case of failure.
                            "progress": {
                                "percentage": "str"  # Optional. The percentage
                                  complete of the copy operation.
                            },
                            "source": {
                                "keyVaultUri": "str",  # They key vault secret uri to
                                  obtain the source storage SAS token. Required.
                                "type": "AzureStorageBlobContainer",  # Optional.
                                  Default value is "AzureStorageBlobContainer". The type of source for
                                  the import pipeline. "AzureStorageBlobContainer"
                                "uri": "str"  # Optional. The source uri of the
                                  import pipeline."nWhen 'AzureStorageBlob':
                                  "https://accountName.blob.core.windows.net/containerName/blobName""nWhen
                                  'AzureStorageBlobContainer':
                                  "https://accountName.blob.core.windows.net/containerName".
                            },
                            "startTime": "2020-02-20 00:00:00",  # Optional. The time the
                              pipeline run started.
                            "status": "str",  # Optional. The current status of the
                              pipeline run.
                            "target": {
                                "keyVaultUri": "str",  # They key vault secret uri to
                                  obtain the target storage SAS token. Required.
                                "type": "str",  # Optional. The type of target for
                                  the export pipeline.
                                "uri": "str"  # Optional. The target uri of the
                                  export pipeline."nWhen 'AzureStorageBlob':
                                  "https://accountName.blob.core.windows.net/containerName/blobName""nWhen
                                  'AzureStorageBlobContainer':
                                  "https://accountName.blob.core.windows.net/containerName".
                            },
                            "trigger": {
                                "sourceTrigger": {
                                    "timestamp": "2020-02-20 00:00:00"  #
                                      Optional. The timestamp when the source update happened.
                                }
                            }
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_pipeline_runs_list_request(
                    resource_group_name=resource_group_name,
                    registry_name=registry_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, registry_name: str, pipeline_run_name: str, **kwargs: Any) -> JSON:
        """Gets the detailed information for a given pipeline run.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param pipeline_run_name: The name of the pipeline run. Required.
        :type pipeline_run_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "forceUpdateTag": "str",  # Optional. How the pipeline run should be
                          forced to recreate even if the pipeline run configuration has not changed.
                        "provisioningState": "str",  # Optional. The provisioning state of a
                          pipeline run. Known values are: "Creating", "Updating", "Deleting",
                          "Succeeded", "Failed", and "Canceled".
                        "request": {
                            "artifacts": [
                                "str"  # Optional. List of source artifacts to be
                                  transferred by the pipeline. "nSpecify an image by repository
                                  ('hello-world'). This will use the 'latest' tag."nSpecify an image by
                                  tag ('hello-world:latest')."nSpecify an image by sha256-based
                                  manifest digest ('hello-world@sha256:abc123').
                            ],
                            "catalogDigest": "str",  # Optional. The digest of the tar
                              used to transfer the artifacts.
                            "pipelineResourceId": "str",  # Optional. The resource ID of
                              the pipeline to run.
                            "source": {
                                "name": "str",  # Optional. The name of the source.
                                "type": "AzureStorageBlob"  # Optional. Default value
                                  is "AzureStorageBlob". The type of the source. "AzureStorageBlob"
                            },
                            "target": {
                                "name": "str",  # Optional. The name of the target.
                                "type": "AzureStorageBlob"  # Optional. Default value
                                  is "AzureStorageBlob". The type of the target. "AzureStorageBlob"
                            }
                        },
                        "response": {
                            "catalogDigest": "str",  # Optional. The digest of the tar
                              used to transfer the artifacts.
                            "finishTime": "2020-02-20 00:00:00",  # Optional. The time
                              the pipeline run finished.
                            "importedArtifacts": [
                                "str"  # Optional. The artifacts imported in the
                                  pipeline run.
                            ],
                            "pipelineRunErrorMessage": "str",  # Optional. The detailed
                              error message for the pipeline run in the case of failure.
                            "progress": {
                                "percentage": "str"  # Optional. The percentage
                                  complete of the copy operation.
                            },
                            "source": {
                                "keyVaultUri": "str",  # They key vault secret uri to
                                  obtain the source storage SAS token. Required.
                                "type": "AzureStorageBlobContainer",  # Optional.
                                  Default value is "AzureStorageBlobContainer". The type of source for
                                  the import pipeline. "AzureStorageBlobContainer"
                                "uri": "str"  # Optional. The source uri of the
                                  import pipeline."nWhen 'AzureStorageBlob':
                                  "https://accountName.blob.core.windows.net/containerName/blobName""nWhen
                                  'AzureStorageBlobContainer':
                                  "https://accountName.blob.core.windows.net/containerName".
                            },
                            "startTime": "2020-02-20 00:00:00",  # Optional. The time the
                              pipeline run started.
                            "status": "str",  # Optional. The current status of the
                              pipeline run.
                            "target": {
                                "keyVaultUri": "str",  # They key vault secret uri to
                                  obtain the target storage SAS token. Required.
                                "type": "str",  # Optional. The type of target for
                                  the export pipeline.
                                "uri": "str"  # Optional. The target uri of the
                                  export pipeline."nWhen 'AzureStorageBlob':
                                  "https://accountName.blob.core.windows.net/containerName/blobName""nWhen
                                  'AzureStorageBlobContainer':
                                  "https://accountName.blob.core.windows.net/containerName".
                            },
                            "trigger": {
                                "sourceTrigger": {
                                    "timestamp": "2020-02-20 00:00:00"  #
                                      Optional. The timestamp when the source update happened.
                                }
                            }
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_pipeline_runs_get_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            pipeline_run_name=pipeline_run_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_initial(
        self,
        resource_group_name: str,
        registry_name: str,
        pipeline_run_name: str,
        pipeline_run_create_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(pipeline_run_create_parameters, (IO, bytes)):
            _content = pipeline_run_create_parameters
        else:
            _json = pipeline_run_create_parameters

        request = build_pipeline_runs_create_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            pipeline_run_name=pipeline_run_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        pipeline_run_name: str,
        pipeline_run_create_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a pipeline run for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param pipeline_run_name: The name of the pipeline run. Required.
        :type pipeline_run_name: str
        :param pipeline_run_create_parameters: The parameters for creating a pipeline run. Required.
        :type pipeline_run_create_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                pipeline_run_create_parameters = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "forceUpdateTag": "str",  # Optional. How the pipeline run should be
                          forced to recreate even if the pipeline run configuration has not changed.
                        "provisioningState": "str",  # Optional. The provisioning state of a
                          pipeline run. Known values are: "Creating", "Updating", "Deleting",
                          "Succeeded", "Failed", and "Canceled".
                        "request": {
                            "artifacts": [
                                "str"  # Optional. List of source artifacts to be
                                  transferred by the pipeline. "nSpecify an image by repository
                                  ('hello-world'). This will use the 'latest' tag."nSpecify an image by
                                  tag ('hello-world:latest')."nSpecify an image by sha256-based
                                  manifest digest ('hello-world@sha256:abc123').
                            ],
                            "catalogDigest": "str",  # Optional. The digest of the tar
                              used to transfer the artifacts.
                            "pipelineResourceId": "str",  # Optional. The resource ID of
                              the pipeline to run.
                            "source": {
                                "name": "str",  # Optional. The name of the source.
                                "type": "AzureStorageBlob"  # Optional. Default value
                                  is "AzureStorageBlob". The type of the source. "AzureStorageBlob"
                            },
                            "target": {
                                "name": "str",  # Optional. The name of the target.
                                "type": "AzureStorageBlob"  # Optional. Default value
                                  is "AzureStorageBlob". The type of the target. "AzureStorageBlob"
                            }
                        },
                        "response": {
                            "catalogDigest": "str",  # Optional. The digest of the tar
                              used to transfer the artifacts.
                            "finishTime": "2020-02-20 00:00:00",  # Optional. The time
                              the pipeline run finished.
                            "importedArtifacts": [
                                "str"  # Optional. The artifacts imported in the
                                  pipeline run.
                            ],
                            "pipelineRunErrorMessage": "str",  # Optional. The detailed
                              error message for the pipeline run in the case of failure.
                            "progress": {
                                "percentage": "str"  # Optional. The percentage
                                  complete of the copy operation.
                            },
                            "source": {
                                "keyVaultUri": "str",  # They key vault secret uri to
                                  obtain the source storage SAS token. Required.
                                "type": "AzureStorageBlobContainer",  # Optional.
                                  Default value is "AzureStorageBlobContainer". The type of source for
                                  the import pipeline. "AzureStorageBlobContainer"
                                "uri": "str"  # Optional. The source uri of the
                                  import pipeline."nWhen 'AzureStorageBlob':
                                  "https://accountName.blob.core.windows.net/containerName/blobName""nWhen
                                  'AzureStorageBlobContainer':
                                  "https://accountName.blob.core.windows.net/containerName".
                            },
                            "startTime": "2020-02-20 00:00:00",  # Optional. The time the
                              pipeline run started.
                            "status": "str",  # Optional. The current status of the
                              pipeline run.
                            "target": {
                                "keyVaultUri": "str",  # They key vault secret uri to
                                  obtain the target storage SAS token. Required.
                                "type": "str",  # Optional. The type of target for
                                  the export pipeline.
                                "uri": "str"  # Optional. The target uri of the
                                  export pipeline."nWhen 'AzureStorageBlob':
                                  "https://accountName.blob.core.windows.net/containerName/blobName""nWhen
                                  'AzureStorageBlobContainer':
                                  "https://accountName.blob.core.windows.net/containerName".
                            },
                            "trigger": {
                                "sourceTrigger": {
                                    "timestamp": "2020-02-20 00:00:00"  #
                                      Optional. The timestamp when the source update happened.
                                }
                            }
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "forceUpdateTag": "str",  # Optional. How the pipeline run should be
                          forced to recreate even if the pipeline run configuration has not changed.
                        "provisioningState": "str",  # Optional. The provisioning state of a
                          pipeline run. Known values are: "Creating", "Updating", "Deleting",
                          "Succeeded", "Failed", and "Canceled".
                        "request": {
                            "artifacts": [
                                "str"  # Optional. List of source artifacts to be
                                  transferred by the pipeline. "nSpecify an image by repository
                                  ('hello-world'). This will use the 'latest' tag."nSpecify an image by
                                  tag ('hello-world:latest')."nSpecify an image by sha256-based
                                  manifest digest ('hello-world@sha256:abc123').
                            ],
                            "catalogDigest": "str",  # Optional. The digest of the tar
                              used to transfer the artifacts.
                            "pipelineResourceId": "str",  # Optional. The resource ID of
                              the pipeline to run.
                            "source": {
                                "name": "str",  # Optional. The name of the source.
                                "type": "AzureStorageBlob"  # Optional. Default value
                                  is "AzureStorageBlob". The type of the source. "AzureStorageBlob"
                            },
                            "target": {
                                "name": "str",  # Optional. The name of the target.
                                "type": "AzureStorageBlob"  # Optional. Default value
                                  is "AzureStorageBlob". The type of the target. "AzureStorageBlob"
                            }
                        },
                        "response": {
                            "catalogDigest": "str",  # Optional. The digest of the tar
                              used to transfer the artifacts.
                            "finishTime": "2020-02-20 00:00:00",  # Optional. The time
                              the pipeline run finished.
                            "importedArtifacts": [
                                "str"  # Optional. The artifacts imported in the
                                  pipeline run.
                            ],
                            "pipelineRunErrorMessage": "str",  # Optional. The detailed
                              error message for the pipeline run in the case of failure.
                            "progress": {
                                "percentage": "str"  # Optional. The percentage
                                  complete of the copy operation.
                            },
                            "source": {
                                "keyVaultUri": "str",  # They key vault secret uri to
                                  obtain the source storage SAS token. Required.
                                "type": "AzureStorageBlobContainer",  # Optional.
                                  Default value is "AzureStorageBlobContainer". The type of source for
                                  the import pipeline. "AzureStorageBlobContainer"
                                "uri": "str"  # Optional. The source uri of the
                                  import pipeline."nWhen 'AzureStorageBlob':
                                  "https://accountName.blob.core.windows.net/containerName/blobName""nWhen
                                  'AzureStorageBlobContainer':
                                  "https://accountName.blob.core.windows.net/containerName".
                            },
                            "startTime": "2020-02-20 00:00:00",  # Optional. The time the
                              pipeline run started.
                            "status": "str",  # Optional. The current status of the
                              pipeline run.
                            "target": {
                                "keyVaultUri": "str",  # They key vault secret uri to
                                  obtain the target storage SAS token. Required.
                                "type": "str",  # Optional. The type of target for
                                  the export pipeline.
                                "uri": "str"  # Optional. The target uri of the
                                  export pipeline."nWhen 'AzureStorageBlob':
                                  "https://accountName.blob.core.windows.net/containerName/blobName""nWhen
                                  'AzureStorageBlobContainer':
                                  "https://accountName.blob.core.windows.net/containerName".
                            },
                            "trigger": {
                                "sourceTrigger": {
                                    "timestamp": "2020-02-20 00:00:00"  #
                                      Optional. The timestamp when the source update happened.
                                }
                            }
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        pipeline_run_name: str,
        pipeline_run_create_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a pipeline run for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param pipeline_run_name: The name of the pipeline run. Required.
        :type pipeline_run_name: str
        :param pipeline_run_create_parameters: The parameters for creating a pipeline run. Required.
        :type pipeline_run_create_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "forceUpdateTag": "str",  # Optional. How the pipeline run should be
                          forced to recreate even if the pipeline run configuration has not changed.
                        "provisioningState": "str",  # Optional. The provisioning state of a
                          pipeline run. Known values are: "Creating", "Updating", "Deleting",
                          "Succeeded", "Failed", and "Canceled".
                        "request": {
                            "artifacts": [
                                "str"  # Optional. List of source artifacts to be
                                  transferred by the pipeline. "nSpecify an image by repository
                                  ('hello-world'). This will use the 'latest' tag."nSpecify an image by
                                  tag ('hello-world:latest')."nSpecify an image by sha256-based
                                  manifest digest ('hello-world@sha256:abc123').
                            ],
                            "catalogDigest": "str",  # Optional. The digest of the tar
                              used to transfer the artifacts.
                            "pipelineResourceId": "str",  # Optional. The resource ID of
                              the pipeline to run.
                            "source": {
                                "name": "str",  # Optional. The name of the source.
                                "type": "AzureStorageBlob"  # Optional. Default value
                                  is "AzureStorageBlob". The type of the source. "AzureStorageBlob"
                            },
                            "target": {
                                "name": "str",  # Optional. The name of the target.
                                "type": "AzureStorageBlob"  # Optional. Default value
                                  is "AzureStorageBlob". The type of the target. "AzureStorageBlob"
                            }
                        },
                        "response": {
                            "catalogDigest": "str",  # Optional. The digest of the tar
                              used to transfer the artifacts.
                            "finishTime": "2020-02-20 00:00:00",  # Optional. The time
                              the pipeline run finished.
                            "importedArtifacts": [
                                "str"  # Optional. The artifacts imported in the
                                  pipeline run.
                            ],
                            "pipelineRunErrorMessage": "str",  # Optional. The detailed
                              error message for the pipeline run in the case of failure.
                            "progress": {
                                "percentage": "str"  # Optional. The percentage
                                  complete of the copy operation.
                            },
                            "source": {
                                "keyVaultUri": "str",  # They key vault secret uri to
                                  obtain the source storage SAS token. Required.
                                "type": "AzureStorageBlobContainer",  # Optional.
                                  Default value is "AzureStorageBlobContainer". The type of source for
                                  the import pipeline. "AzureStorageBlobContainer"
                                "uri": "str"  # Optional. The source uri of the
                                  import pipeline."nWhen 'AzureStorageBlob':
                                  "https://accountName.blob.core.windows.net/containerName/blobName""nWhen
                                  'AzureStorageBlobContainer':
                                  "https://accountName.blob.core.windows.net/containerName".
                            },
                            "startTime": "2020-02-20 00:00:00",  # Optional. The time the
                              pipeline run started.
                            "status": "str",  # Optional. The current status of the
                              pipeline run.
                            "target": {
                                "keyVaultUri": "str",  # They key vault secret uri to
                                  obtain the target storage SAS token. Required.
                                "type": "str",  # Optional. The type of target for
                                  the export pipeline.
                                "uri": "str"  # Optional. The target uri of the
                                  export pipeline."nWhen 'AzureStorageBlob':
                                  "https://accountName.blob.core.windows.net/containerName/blobName""nWhen
                                  'AzureStorageBlobContainer':
                                  "https://accountName.blob.core.windows.net/containerName".
                            },
                            "trigger": {
                                "sourceTrigger": {
                                    "timestamp": "2020-02-20 00:00:00"  #
                                      Optional. The timestamp when the source update happened.
                                }
                            }
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        pipeline_run_name: str,
        pipeline_run_create_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a pipeline run for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param pipeline_run_name: The name of the pipeline run. Required.
        :type pipeline_run_name: str
        :param pipeline_run_create_parameters: The parameters for creating a pipeline run. Is either a
         model type or a IO type. Required.
        :type pipeline_run_create_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "forceUpdateTag": "str",  # Optional. How the pipeline run should be
                          forced to recreate even if the pipeline run configuration has not changed.
                        "provisioningState": "str",  # Optional. The provisioning state of a
                          pipeline run. Known values are: "Creating", "Updating", "Deleting",
                          "Succeeded", "Failed", and "Canceled".
                        "request": {
                            "artifacts": [
                                "str"  # Optional. List of source artifacts to be
                                  transferred by the pipeline. "nSpecify an image by repository
                                  ('hello-world'). This will use the 'latest' tag."nSpecify an image by
                                  tag ('hello-world:latest')."nSpecify an image by sha256-based
                                  manifest digest ('hello-world@sha256:abc123').
                            ],
                            "catalogDigest": "str",  # Optional. The digest of the tar
                              used to transfer the artifacts.
                            "pipelineResourceId": "str",  # Optional. The resource ID of
                              the pipeline to run.
                            "source": {
                                "name": "str",  # Optional. The name of the source.
                                "type": "AzureStorageBlob"  # Optional. Default value
                                  is "AzureStorageBlob". The type of the source. "AzureStorageBlob"
                            },
                            "target": {
                                "name": "str",  # Optional. The name of the target.
                                "type": "AzureStorageBlob"  # Optional. Default value
                                  is "AzureStorageBlob". The type of the target. "AzureStorageBlob"
                            }
                        },
                        "response": {
                            "catalogDigest": "str",  # Optional. The digest of the tar
                              used to transfer the artifacts.
                            "finishTime": "2020-02-20 00:00:00",  # Optional. The time
                              the pipeline run finished.
                            "importedArtifacts": [
                                "str"  # Optional. The artifacts imported in the
                                  pipeline run.
                            ],
                            "pipelineRunErrorMessage": "str",  # Optional. The detailed
                              error message for the pipeline run in the case of failure.
                            "progress": {
                                "percentage": "str"  # Optional. The percentage
                                  complete of the copy operation.
                            },
                            "source": {
                                "keyVaultUri": "str",  # They key vault secret uri to
                                  obtain the source storage SAS token. Required.
                                "type": "AzureStorageBlobContainer",  # Optional.
                                  Default value is "AzureStorageBlobContainer". The type of source for
                                  the import pipeline. "AzureStorageBlobContainer"
                                "uri": "str"  # Optional. The source uri of the
                                  import pipeline."nWhen 'AzureStorageBlob':
                                  "https://accountName.blob.core.windows.net/containerName/blobName""nWhen
                                  'AzureStorageBlobContainer':
                                  "https://accountName.blob.core.windows.net/containerName".
                            },
                            "startTime": "2020-02-20 00:00:00",  # Optional. The time the
                              pipeline run started.
                            "status": "str",  # Optional. The current status of the
                              pipeline run.
                            "target": {
                                "keyVaultUri": "str",  # They key vault secret uri to
                                  obtain the target storage SAS token. Required.
                                "type": "str",  # Optional. The type of target for
                                  the export pipeline.
                                "uri": "str"  # Optional. The target uri of the
                                  export pipeline."nWhen 'AzureStorageBlob':
                                  "https://accountName.blob.core.windows.net/containerName/blobName""nWhen
                                  'AzureStorageBlobContainer':
                                  "https://accountName.blob.core.windows.net/containerName".
                            },
                            "trigger": {
                                "sourceTrigger": {
                                    "timestamp": "2020-02-20 00:00:00"  #
                                      Optional. The timestamp when the source update happened.
                                }
                            }
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_initial(
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                pipeline_run_name=pipeline_run_name,
                pipeline_run_create_parameters=pipeline_run_create_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, registry_name: str, pipeline_run_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_pipeline_runs_delete_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            pipeline_run_name=pipeline_run_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, registry_name: str, pipeline_run_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Deletes a pipeline run from a container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param pipeline_run_name: The name of the pipeline run. Required.
        :type pipeline_run_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                pipeline_run_name=pipeline_run_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class PrivateEndpointConnectionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~container_registry_management_client.ContainerRegistryManagementClient`'s
        :attr:`private_endpoint_connections` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, resource_group_name: str, registry_name: str, **kwargs: Any) -> Iterable[JSON]:
        """List all private endpoint connections in a container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "privateEndpoint": {
                            "id": "str"  # Optional. This is private endpoint resource
                              created with Microsoft.Network resource provider.
                        },
                        "privateLinkServiceConnectionState": {
                            "actionsRequired": "str",  # Optional. A message indicating
                              if changes on the service provider require any updates on the consumer.
                              Known values are: "None" and "Recreate".
                            "description": "str",  # Optional. The description for
                              connection status. For example if connection is rejected it can indicate
                              reason for rejection.
                            "status": "str"  # Optional. The private link service
                              connection status. Known values are: "Approved", "Pending", "Rejected",
                              and "Disconnected".
                        },
                        "provisioningState": "str"  # Optional. The provisioning state of
                          private endpoint connection resource. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_private_endpoint_connections_list_request(
                    resource_group_name=resource_group_name,
                    registry_name=registry_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(
        self, resource_group_name: str, registry_name: str, private_endpoint_connection_name: str, **kwargs: Any
    ) -> JSON:
        """Get the specified private endpoint connection associated with the container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "privateEndpoint": {
                            "id": "str"  # Optional. This is private endpoint resource
                              created with Microsoft.Network resource provider.
                        },
                        "privateLinkServiceConnectionState": {
                            "actionsRequired": "str",  # Optional. A message indicating
                              if changes on the service provider require any updates on the consumer.
                              Known values are: "None" and "Recreate".
                            "description": "str",  # Optional. The description for
                              connection status. For example if connection is rejected it can indicate
                              reason for rejection.
                            "status": "str"  # Optional. The private link service
                              connection status. Known values are: "Approved", "Pending", "Rejected",
                              and "Disconnected".
                        },
                        "provisioningState": "str"  # Optional. The provisioning state of
                          private endpoint connection resource. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_private_endpoint_connections_get_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            private_endpoint_connection_name=private_endpoint_connection_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_or_update_initial(
        self,
        resource_group_name: str,
        registry_name: str,
        private_endpoint_connection_name: str,
        private_endpoint_connection: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(private_endpoint_connection, (IO, bytes)):
            _content = private_endpoint_connection
        else:
            _json = private_endpoint_connection

        request = build_private_endpoint_connections_create_or_update_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            private_endpoint_connection_name=private_endpoint_connection_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        registry_name: str,
        private_endpoint_connection_name: str,
        private_endpoint_connection: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update the state of specified private endpoint connection associated with the container
        registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :param private_endpoint_connection: The parameters for creating a private endpoint connection.
         Required.
        :type private_endpoint_connection: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                private_endpoint_connection = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "privateEndpoint": {
                            "id": "str"  # Optional. This is private endpoint resource
                              created with Microsoft.Network resource provider.
                        },
                        "privateLinkServiceConnectionState": {
                            "actionsRequired": "str",  # Optional. A message indicating
                              if changes on the service provider require any updates on the consumer.
                              Known values are: "None" and "Recreate".
                            "description": "str",  # Optional. The description for
                              connection status. For example if connection is rejected it can indicate
                              reason for rejection.
                            "status": "str"  # Optional. The private link service
                              connection status. Known values are: "Approved", "Pending", "Rejected",
                              and "Disconnected".
                        },
                        "provisioningState": "str"  # Optional. The provisioning state of
                          private endpoint connection resource. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "privateEndpoint": {
                            "id": "str"  # Optional. This is private endpoint resource
                              created with Microsoft.Network resource provider.
                        },
                        "privateLinkServiceConnectionState": {
                            "actionsRequired": "str",  # Optional. A message indicating
                              if changes on the service provider require any updates on the consumer.
                              Known values are: "None" and "Recreate".
                            "description": "str",  # Optional. The description for
                              connection status. For example if connection is rejected it can indicate
                              reason for rejection.
                            "status": "str"  # Optional. The private link service
                              connection status. Known values are: "Approved", "Pending", "Rejected",
                              and "Disconnected".
                        },
                        "provisioningState": "str"  # Optional. The provisioning state of
                          private endpoint connection resource. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        registry_name: str,
        private_endpoint_connection_name: str,
        private_endpoint_connection: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update the state of specified private endpoint connection associated with the container
        registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :param private_endpoint_connection: The parameters for creating a private endpoint connection.
         Required.
        :type private_endpoint_connection: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "privateEndpoint": {
                            "id": "str"  # Optional. This is private endpoint resource
                              created with Microsoft.Network resource provider.
                        },
                        "privateLinkServiceConnectionState": {
                            "actionsRequired": "str",  # Optional. A message indicating
                              if changes on the service provider require any updates on the consumer.
                              Known values are: "None" and "Recreate".
                            "description": "str",  # Optional. The description for
                              connection status. For example if connection is rejected it can indicate
                              reason for rejection.
                            "status": "str"  # Optional. The private link service
                              connection status. Known values are: "Approved", "Pending", "Rejected",
                              and "Disconnected".
                        },
                        "provisioningState": "str"  # Optional. The provisioning state of
                          private endpoint connection resource. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self,
        resource_group_name: str,
        registry_name: str,
        private_endpoint_connection_name: str,
        private_endpoint_connection: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update the state of specified private endpoint connection associated with the container
        registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :param private_endpoint_connection: The parameters for creating a private endpoint connection.
         Is either a model type or a IO type. Required.
        :type private_endpoint_connection: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "privateEndpoint": {
                            "id": "str"  # Optional. This is private endpoint resource
                              created with Microsoft.Network resource provider.
                        },
                        "privateLinkServiceConnectionState": {
                            "actionsRequired": "str",  # Optional. A message indicating
                              if changes on the service provider require any updates on the consumer.
                              Known values are: "None" and "Recreate".
                            "description": "str",  # Optional. The description for
                              connection status. For example if connection is rejected it can indicate
                              reason for rejection.
                            "status": "str"  # Optional. The private link service
                              connection status. Known values are: "Approved", "Pending", "Rejected",
                              and "Disconnected".
                        },
                        "provisioningState": "str"  # Optional. The provisioning state of
                          private endpoint connection resource. Known values are: "Creating",
                          "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                private_endpoint_connection_name=private_endpoint_connection_name,
                private_endpoint_connection=private_endpoint_connection,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, registry_name: str, private_endpoint_connection_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_private_endpoint_connections_delete_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            private_endpoint_connection_name=private_endpoint_connection_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, registry_name: str, private_endpoint_connection_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Deletes the specified private endpoint connection associated with the container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
        :type private_endpoint_connection_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                private_endpoint_connection_name=private_endpoint_connection_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class ReplicationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~container_registry_management_client.ContainerRegistryManagementClient`'s
        :attr:`replications` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, resource_group_name: str, registry_name: str, **kwargs: Any) -> Iterable[JSON]:
        """Lists all the replications for the specified container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the replication at the time the operation was called. Known values are:
                          "Creating", "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "regionEndpointEnabled": True,  # Optional. Default value is True.
                          Specifies whether the replication's regional endpoint is enabled. Requests
                          will not be routed to a replication whose regional endpoint is disabled,
                          however its data will continue to be synced with other replications.
                        "status": {
                            "displayStatus": "str",  # Optional. The short label for the
                              status.
                            "message": "str",  # Optional. The detailed message for the
                              status, including alerts and error messages.
                            "timestamp": "2020-02-20 00:00:00"  # Optional. The timestamp
                              when the status was changed to the current value.
                        },
                        "zoneRedundancy": "str"  # Optional. Whether or not zone redundancy
                          is enabled for this container registry replication. Known values are:
                          "Enabled" and "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_replications_list_request(
                    resource_group_name=resource_group_name,
                    registry_name=registry_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, registry_name: str, replication_name: str, **kwargs: Any) -> JSON:
        """Gets the properties of the specified replication.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param replication_name: The name of the replication. Required.
        :type replication_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the replication at the time the operation was called. Known values are:
                          "Creating", "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "regionEndpointEnabled": True,  # Optional. Default value is True.
                          Specifies whether the replication's regional endpoint is enabled. Requests
                          will not be routed to a replication whose regional endpoint is disabled,
                          however its data will continue to be synced with other replications.
                        "status": {
                            "displayStatus": "str",  # Optional. The short label for the
                              status.
                            "message": "str",  # Optional. The detailed message for the
                              status, including alerts and error messages.
                            "timestamp": "2020-02-20 00:00:00"  # Optional. The timestamp
                              when the status was changed to the current value.
                        },
                        "zoneRedundancy": "str"  # Optional. Whether or not zone redundancy
                          is enabled for this container registry replication. Known values are:
                          "Enabled" and "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_replications_get_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            replication_name=replication_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_initial(
        self,
        resource_group_name: str,
        registry_name: str,
        replication_name: str,
        replication: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(replication, (IO, bytes)):
            _content = replication
        else:
            _json = replication

        request = build_replications_create_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            replication_name=replication_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        replication_name: str,
        replication: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a replication for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param replication_name: The name of the replication. Required.
        :type replication_name: str
        :param replication: The parameters for creating a replication. Required.
        :type replication: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                replication = {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the replication at the time the operation was called. Known values are:
                          "Creating", "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "regionEndpointEnabled": True,  # Optional. Default value is True.
                          Specifies whether the replication's regional endpoint is enabled. Requests
                          will not be routed to a replication whose regional endpoint is disabled,
                          however its data will continue to be synced with other replications.
                        "status": {
                            "displayStatus": "str",  # Optional. The short label for the
                              status.
                            "message": "str",  # Optional. The detailed message for the
                              status, including alerts and error messages.
                            "timestamp": "2020-02-20 00:00:00"  # Optional. The timestamp
                              when the status was changed to the current value.
                        },
                        "zoneRedundancy": "str"  # Optional. Whether or not zone redundancy
                          is enabled for this container registry replication. Known values are:
                          "Enabled" and "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the replication at the time the operation was called. Known values are:
                          "Creating", "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "regionEndpointEnabled": True,  # Optional. Default value is True.
                          Specifies whether the replication's regional endpoint is enabled. Requests
                          will not be routed to a replication whose regional endpoint is disabled,
                          however its data will continue to be synced with other replications.
                        "status": {
                            "displayStatus": "str",  # Optional. The short label for the
                              status.
                            "message": "str",  # Optional. The detailed message for the
                              status, including alerts and error messages.
                            "timestamp": "2020-02-20 00:00:00"  # Optional. The timestamp
                              when the status was changed to the current value.
                        },
                        "zoneRedundancy": "str"  # Optional. Whether or not zone redundancy
                          is enabled for this container registry replication. Known values are:
                          "Enabled" and "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        replication_name: str,
        replication: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a replication for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param replication_name: The name of the replication. Required.
        :type replication_name: str
        :param replication: The parameters for creating a replication. Required.
        :type replication: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the replication at the time the operation was called. Known values are:
                          "Creating", "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "regionEndpointEnabled": True,  # Optional. Default value is True.
                          Specifies whether the replication's regional endpoint is enabled. Requests
                          will not be routed to a replication whose regional endpoint is disabled,
                          however its data will continue to be synced with other replications.
                        "status": {
                            "displayStatus": "str",  # Optional. The short label for the
                              status.
                            "message": "str",  # Optional. The detailed message for the
                              status, including alerts and error messages.
                            "timestamp": "2020-02-20 00:00:00"  # Optional. The timestamp
                              when the status was changed to the current value.
                        },
                        "zoneRedundancy": "str"  # Optional. Whether or not zone redundancy
                          is enabled for this container registry replication. Known values are:
                          "Enabled" and "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        replication_name: str,
        replication: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a replication for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param replication_name: The name of the replication. Required.
        :type replication_name: str
        :param replication: The parameters for creating a replication. Is either a model type or a IO
         type. Required.
        :type replication: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the replication at the time the operation was called. Known values are:
                          "Creating", "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "regionEndpointEnabled": True,  # Optional. Default value is True.
                          Specifies whether the replication's regional endpoint is enabled. Requests
                          will not be routed to a replication whose regional endpoint is disabled,
                          however its data will continue to be synced with other replications.
                        "status": {
                            "displayStatus": "str",  # Optional. The short label for the
                              status.
                            "message": "str",  # Optional. The detailed message for the
                              status, including alerts and error messages.
                            "timestamp": "2020-02-20 00:00:00"  # Optional. The timestamp
                              when the status was changed to the current value.
                        },
                        "zoneRedundancy": "str"  # Optional. Whether or not zone redundancy
                          is enabled for this container registry replication. Known values are:
                          "Enabled" and "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_initial(
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                replication_name=replication_name,
                replication=replication,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, registry_name: str, replication_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_replications_delete_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            replication_name=replication_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, registry_name: str, replication_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Deletes a replication from a container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param replication_name: The name of the replication. Required.
        :type replication_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                replication_name=replication_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _update_initial(
        self,
        resource_group_name: str,
        registry_name: str,
        replication_name: str,
        replication_update_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(replication_update_parameters, (IO, bytes)):
            _content = replication_update_parameters
        else:
            _json = replication_update_parameters

        request = build_replications_update_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            replication_name=replication_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        registry_name: str,
        replication_name: str,
        replication_update_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a replication for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param replication_name: The name of the replication. Required.
        :type replication_name: str
        :param replication_update_parameters: The parameters for updating a replication. Required.
        :type replication_update_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                replication_update_parameters = {
                    "properties": {
                        "regionEndpointEnabled": bool  # Optional. Specifies whether the
                          replication's regional endpoint is enabled. Requests will not be routed to a
                          replication whose regional endpoint is disabled, however its data will
                          continue to be synced with other replications.
                    },
                    "tags": {
                        "str": "str"  # Optional. The tags for the replication.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the replication at the time the operation was called. Known values are:
                          "Creating", "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "regionEndpointEnabled": True,  # Optional. Default value is True.
                          Specifies whether the replication's regional endpoint is enabled. Requests
                          will not be routed to a replication whose regional endpoint is disabled,
                          however its data will continue to be synced with other replications.
                        "status": {
                            "displayStatus": "str",  # Optional. The short label for the
                              status.
                            "message": "str",  # Optional. The detailed message for the
                              status, including alerts and error messages.
                            "timestamp": "2020-02-20 00:00:00"  # Optional. The timestamp
                              when the status was changed to the current value.
                        },
                        "zoneRedundancy": "str"  # Optional. Whether or not zone redundancy
                          is enabled for this container registry replication. Known values are:
                          "Enabled" and "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        registry_name: str,
        replication_name: str,
        replication_update_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a replication for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param replication_name: The name of the replication. Required.
        :type replication_name: str
        :param replication_update_parameters: The parameters for updating a replication. Required.
        :type replication_update_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the replication at the time the operation was called. Known values are:
                          "Creating", "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "regionEndpointEnabled": True,  # Optional. Default value is True.
                          Specifies whether the replication's regional endpoint is enabled. Requests
                          will not be routed to a replication whose regional endpoint is disabled,
                          however its data will continue to be synced with other replications.
                        "status": {
                            "displayStatus": "str",  # Optional. The short label for the
                              status.
                            "message": "str",  # Optional. The detailed message for the
                              status, including alerts and error messages.
                            "timestamp": "2020-02-20 00:00:00"  # Optional. The timestamp
                              when the status was changed to the current value.
                        },
                        "zoneRedundancy": "str"  # Optional. Whether or not zone redundancy
                          is enabled for this container registry replication. Known values are:
                          "Enabled" and "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_update(
        self,
        resource_group_name: str,
        registry_name: str,
        replication_name: str,
        replication_update_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a replication for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param replication_name: The name of the replication. Required.
        :type replication_name: str
        :param replication_update_parameters: The parameters for updating a replication. Is either a
         model type or a IO type. Required.
        :type replication_update_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the replication at the time the operation was called. Known values are:
                          "Creating", "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "regionEndpointEnabled": True,  # Optional. Default value is True.
                          Specifies whether the replication's regional endpoint is enabled. Requests
                          will not be routed to a replication whose regional endpoint is disabled,
                          however its data will continue to be synced with other replications.
                        "status": {
                            "displayStatus": "str",  # Optional. The short label for the
                              status.
                            "message": "str",  # Optional. The detailed message for the
                              status, including alerts and error messages.
                            "timestamp": "2020-02-20 00:00:00"  # Optional. The timestamp
                              when the status was changed to the current value.
                        },
                        "zoneRedundancy": "str"  # Optional. Whether or not zone redundancy
                          is enabled for this container registry replication. Known values are:
                          "Enabled" and "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                replication_name=replication_name,
                replication_update_parameters=replication_update_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class ScopeMapsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~container_registry_management_client.ContainerRegistryManagementClient`'s
        :attr:`scope_maps` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, resource_group_name: str, registry_name: str, **kwargs: Any) -> Iterable[JSON]:
        """Lists all the scope maps for the specified container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "actions": [
                            "str"  # The list of scoped permissions for registry
                              artifacts."nE.g.
                              repositories/repository-name/content/read,"nrepositories/repository-name/metadata/write.
                              Required.
                        ],
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of scope map.
                        "description": "str",  # Optional. The user friendly description of
                          the scope map.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "type": "str"  # Optional. The type of the scope map. E.g. BuildIn
                          scope map.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_scope_maps_list_request(
                    resource_group_name=resource_group_name,
                    registry_name=registry_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, registry_name: str, scope_map_name: str, **kwargs: Any) -> JSON:
        """Gets the properties of the specified scope map.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param scope_map_name: The name of the scope map. Required.
        :type scope_map_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "actions": [
                            "str"  # The list of scoped permissions for registry
                              artifacts."nE.g.
                              repositories/repository-name/content/read,"nrepositories/repository-name/metadata/write.
                              Required.
                        ],
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of scope map.
                        "description": "str",  # Optional. The user friendly description of
                          the scope map.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "type": "str"  # Optional. The type of the scope map. E.g. BuildIn
                          scope map.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_scope_maps_get_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            scope_map_name=scope_map_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_initial(
        self,
        resource_group_name: str,
        registry_name: str,
        scope_map_name: str,
        scope_map_create_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(scope_map_create_parameters, (IO, bytes)):
            _content = scope_map_create_parameters
        else:
            _json = scope_map_create_parameters

        request = build_scope_maps_create_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            scope_map_name=scope_map_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        scope_map_name: str,
        scope_map_create_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a scope map for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param scope_map_name: The name of the scope map. Required.
        :type scope_map_name: str
        :param scope_map_create_parameters: The parameters for creating a scope map. Required.
        :type scope_map_create_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                scope_map_create_parameters = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "actions": [
                            "str"  # The list of scoped permissions for registry
                              artifacts."nE.g.
                              repositories/repository-name/content/read,"nrepositories/repository-name/metadata/write.
                              Required.
                        ],
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of scope map.
                        "description": "str",  # Optional. The user friendly description of
                          the scope map.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "type": "str"  # Optional. The type of the scope map. E.g. BuildIn
                          scope map.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "actions": [
                            "str"  # The list of scoped permissions for registry
                              artifacts."nE.g.
                              repositories/repository-name/content/read,"nrepositories/repository-name/metadata/write.
                              Required.
                        ],
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of scope map.
                        "description": "str",  # Optional. The user friendly description of
                          the scope map.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "type": "str"  # Optional. The type of the scope map. E.g. BuildIn
                          scope map.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        scope_map_name: str,
        scope_map_create_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a scope map for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param scope_map_name: The name of the scope map. Required.
        :type scope_map_name: str
        :param scope_map_create_parameters: The parameters for creating a scope map. Required.
        :type scope_map_create_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "actions": [
                            "str"  # The list of scoped permissions for registry
                              artifacts."nE.g.
                              repositories/repository-name/content/read,"nrepositories/repository-name/metadata/write.
                              Required.
                        ],
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of scope map.
                        "description": "str",  # Optional. The user friendly description of
                          the scope map.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "type": "str"  # Optional. The type of the scope map. E.g. BuildIn
                          scope map.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        scope_map_name: str,
        scope_map_create_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a scope map for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param scope_map_name: The name of the scope map. Required.
        :type scope_map_name: str
        :param scope_map_create_parameters: The parameters for creating a scope map. Is either a model
         type or a IO type. Required.
        :type scope_map_create_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "actions": [
                            "str"  # The list of scoped permissions for registry
                              artifacts."nE.g.
                              repositories/repository-name/content/read,"nrepositories/repository-name/metadata/write.
                              Required.
                        ],
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of scope map.
                        "description": "str",  # Optional. The user friendly description of
                          the scope map.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "type": "str"  # Optional. The type of the scope map. E.g. BuildIn
                          scope map.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_initial(
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                scope_map_name=scope_map_name,
                scope_map_create_parameters=scope_map_create_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, registry_name: str, scope_map_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_scope_maps_delete_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            scope_map_name=scope_map_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, registry_name: str, scope_map_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Deletes a scope map from a container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param scope_map_name: The name of the scope map. Required.
        :type scope_map_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                scope_map_name=scope_map_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _update_initial(
        self,
        resource_group_name: str,
        registry_name: str,
        scope_map_name: str,
        scope_map_update_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(scope_map_update_parameters, (IO, bytes)):
            _content = scope_map_update_parameters
        else:
            _json = scope_map_update_parameters

        request = build_scope_maps_update_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            scope_map_name=scope_map_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        registry_name: str,
        scope_map_name: str,
        scope_map_update_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a scope map with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param scope_map_name: The name of the scope map. Required.
        :type scope_map_name: str
        :param scope_map_update_parameters: The parameters for updating a scope map. Required.
        :type scope_map_update_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                scope_map_update_parameters = {
                    "properties": {
                        "actions": [
                            "str"  # Optional. The list of scope permissions for registry
                              artifacts."nE.g. repositories/repository-name/pull,
                              "nrepositories/repository-name/delete.
                        ],
                        "description": "str"  # Optional. The user friendly description of
                          the scope map.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "actions": [
                            "str"  # The list of scoped permissions for registry
                              artifacts."nE.g.
                              repositories/repository-name/content/read,"nrepositories/repository-name/metadata/write.
                              Required.
                        ],
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of scope map.
                        "description": "str",  # Optional. The user friendly description of
                          the scope map.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "type": "str"  # Optional. The type of the scope map. E.g. BuildIn
                          scope map.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        registry_name: str,
        scope_map_name: str,
        scope_map_update_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a scope map with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param scope_map_name: The name of the scope map. Required.
        :type scope_map_name: str
        :param scope_map_update_parameters: The parameters for updating a scope map. Required.
        :type scope_map_update_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "actions": [
                            "str"  # The list of scoped permissions for registry
                              artifacts."nE.g.
                              repositories/repository-name/content/read,"nrepositories/repository-name/metadata/write.
                              Required.
                        ],
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of scope map.
                        "description": "str",  # Optional. The user friendly description of
                          the scope map.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "type": "str"  # Optional. The type of the scope map. E.g. BuildIn
                          scope map.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_update(
        self,
        resource_group_name: str,
        registry_name: str,
        scope_map_name: str,
        scope_map_update_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a scope map with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param scope_map_name: The name of the scope map. Required.
        :type scope_map_name: str
        :param scope_map_update_parameters: The parameters for updating a scope map. Is either a model
         type or a IO type. Required.
        :type scope_map_update_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "actions": [
                            "str"  # The list of scoped permissions for registry
                              artifacts."nE.g.
                              repositories/repository-name/content/read,"nrepositories/repository-name/metadata/write.
                              Required.
                        ],
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of scope map.
                        "description": "str",  # Optional. The user friendly description of
                          the scope map.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "type": "str"  # Optional. The type of the scope map. E.g. BuildIn
                          scope map.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                scope_map_name=scope_map_name,
                scope_map_update_parameters=scope_map_update_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class TokensOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~container_registry_management_client.ContainerRegistryManagementClient`'s
        :attr:`tokens` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, resource_group_name: str, registry_name: str, **kwargs: Any) -> Iterable[JSON]:
        """Lists all the tokens for the specified container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of scope map.
                        "credentials": {
                            "certificates": [
                                {
                                    "encodedPemCertificate": "str",  # Optional.
                                      Base 64 encoded string of the public certificate1 in PEM format
                                      that will be used for authenticating the token.
                                    "expiry": "2020-02-20 00:00:00",  # Optional.
                                      The expiry datetime of the certificate.
                                    "name": "str",  # Optional. Known values are:
                                      "certificate1" and "certificate2".
                                    "thumbprint": "str"  # Optional. The
                                      thumbprint of the certificate.
                                }
                            ],
                            "passwords": [
                                {
                                    "creationTime": "2020-02-20 00:00:00",  #
                                      Optional. The creation datetime of the password.
                                    "expiry": "2020-02-20 00:00:00",  # Optional.
                                      The expiry datetime of the password.
                                    "name": "str",  # Optional. The password name
                                      "password1" or "password2". Known values are: "password1" and
                                      "password2".
                                    "value": "str"  # Optional. The password
                                      value.
                                }
                            ]
                        },
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "scopeMapId": "str",  # Optional. The resource ID of the scope map to
                          which the token will be associated with.
                        "status": "str"  # Optional. The status of the token example enabled
                          or disabled. Known values are: "enabled" and "disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_tokens_list_request(
                    resource_group_name=resource_group_name,
                    registry_name=registry_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, registry_name: str, token_name: str, **kwargs: Any) -> JSON:
        """Gets the properties of the specified token.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param token_name: The name of the token. Required.
        :type token_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of scope map.
                        "credentials": {
                            "certificates": [
                                {
                                    "encodedPemCertificate": "str",  # Optional.
                                      Base 64 encoded string of the public certificate1 in PEM format
                                      that will be used for authenticating the token.
                                    "expiry": "2020-02-20 00:00:00",  # Optional.
                                      The expiry datetime of the certificate.
                                    "name": "str",  # Optional. Known values are:
                                      "certificate1" and "certificate2".
                                    "thumbprint": "str"  # Optional. The
                                      thumbprint of the certificate.
                                }
                            ],
                            "passwords": [
                                {
                                    "creationTime": "2020-02-20 00:00:00",  #
                                      Optional. The creation datetime of the password.
                                    "expiry": "2020-02-20 00:00:00",  # Optional.
                                      The expiry datetime of the password.
                                    "name": "str",  # Optional. The password name
                                      "password1" or "password2". Known values are: "password1" and
                                      "password2".
                                    "value": "str"  # Optional. The password
                                      value.
                                }
                            ]
                        },
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "scopeMapId": "str",  # Optional. The resource ID of the scope map to
                          which the token will be associated with.
                        "status": "str"  # Optional. The status of the token example enabled
                          or disabled. Known values are: "enabled" and "disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_tokens_get_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            token_name=token_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_initial(
        self,
        resource_group_name: str,
        registry_name: str,
        token_name: str,
        token_create_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(token_create_parameters, (IO, bytes)):
            _content = token_create_parameters
        else:
            _json = token_create_parameters

        request = build_tokens_create_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            token_name=token_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        token_name: str,
        token_create_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a token for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param token_name: The name of the token. Required.
        :type token_name: str
        :param token_create_parameters: The parameters for creating a token. Required.
        :type token_create_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                token_create_parameters = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of scope map.
                        "credentials": {
                            "certificates": [
                                {
                                    "encodedPemCertificate": "str",  # Optional.
                                      Base 64 encoded string of the public certificate1 in PEM format
                                      that will be used for authenticating the token.
                                    "expiry": "2020-02-20 00:00:00",  # Optional.
                                      The expiry datetime of the certificate.
                                    "name": "str",  # Optional. Known values are:
                                      "certificate1" and "certificate2".
                                    "thumbprint": "str"  # Optional. The
                                      thumbprint of the certificate.
                                }
                            ],
                            "passwords": [
                                {
                                    "creationTime": "2020-02-20 00:00:00",  #
                                      Optional. The creation datetime of the password.
                                    "expiry": "2020-02-20 00:00:00",  # Optional.
                                      The expiry datetime of the password.
                                    "name": "str",  # Optional. The password name
                                      "password1" or "password2". Known values are: "password1" and
                                      "password2".
                                    "value": "str"  # Optional. The password
                                      value.
                                }
                            ]
                        },
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "scopeMapId": "str",  # Optional. The resource ID of the scope map to
                          which the token will be associated with.
                        "status": "str"  # Optional. The status of the token example enabled
                          or disabled. Known values are: "enabled" and "disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of scope map.
                        "credentials": {
                            "certificates": [
                                {
                                    "encodedPemCertificate": "str",  # Optional.
                                      Base 64 encoded string of the public certificate1 in PEM format
                                      that will be used for authenticating the token.
                                    "expiry": "2020-02-20 00:00:00",  # Optional.
                                      The expiry datetime of the certificate.
                                    "name": "str",  # Optional. Known values are:
                                      "certificate1" and "certificate2".
                                    "thumbprint": "str"  # Optional. The
                                      thumbprint of the certificate.
                                }
                            ],
                            "passwords": [
                                {
                                    "creationTime": "2020-02-20 00:00:00",  #
                                      Optional. The creation datetime of the password.
                                    "expiry": "2020-02-20 00:00:00",  # Optional.
                                      The expiry datetime of the password.
                                    "name": "str",  # Optional. The password name
                                      "password1" or "password2". Known values are: "password1" and
                                      "password2".
                                    "value": "str"  # Optional. The password
                                      value.
                                }
                            ]
                        },
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "scopeMapId": "str",  # Optional. The resource ID of the scope map to
                          which the token will be associated with.
                        "status": "str"  # Optional. The status of the token example enabled
                          or disabled. Known values are: "enabled" and "disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        token_name: str,
        token_create_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a token for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param token_name: The name of the token. Required.
        :type token_name: str
        :param token_create_parameters: The parameters for creating a token. Required.
        :type token_create_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of scope map.
                        "credentials": {
                            "certificates": [
                                {
                                    "encodedPemCertificate": "str",  # Optional.
                                      Base 64 encoded string of the public certificate1 in PEM format
                                      that will be used for authenticating the token.
                                    "expiry": "2020-02-20 00:00:00",  # Optional.
                                      The expiry datetime of the certificate.
                                    "name": "str",  # Optional. Known values are:
                                      "certificate1" and "certificate2".
                                    "thumbprint": "str"  # Optional. The
                                      thumbprint of the certificate.
                                }
                            ],
                            "passwords": [
                                {
                                    "creationTime": "2020-02-20 00:00:00",  #
                                      Optional. The creation datetime of the password.
                                    "expiry": "2020-02-20 00:00:00",  # Optional.
                                      The expiry datetime of the password.
                                    "name": "str",  # Optional. The password name
                                      "password1" or "password2". Known values are: "password1" and
                                      "password2".
                                    "value": "str"  # Optional. The password
                                      value.
                                }
                            ]
                        },
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "scopeMapId": "str",  # Optional. The resource ID of the scope map to
                          which the token will be associated with.
                        "status": "str"  # Optional. The status of the token example enabled
                          or disabled. Known values are: "enabled" and "disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        token_name: str,
        token_create_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a token for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param token_name: The name of the token. Required.
        :type token_name: str
        :param token_create_parameters: The parameters for creating a token. Is either a model type or
         a IO type. Required.
        :type token_create_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of scope map.
                        "credentials": {
                            "certificates": [
                                {
                                    "encodedPemCertificate": "str",  # Optional.
                                      Base 64 encoded string of the public certificate1 in PEM format
                                      that will be used for authenticating the token.
                                    "expiry": "2020-02-20 00:00:00",  # Optional.
                                      The expiry datetime of the certificate.
                                    "name": "str",  # Optional. Known values are:
                                      "certificate1" and "certificate2".
                                    "thumbprint": "str"  # Optional. The
                                      thumbprint of the certificate.
                                }
                            ],
                            "passwords": [
                                {
                                    "creationTime": "2020-02-20 00:00:00",  #
                                      Optional. The creation datetime of the password.
                                    "expiry": "2020-02-20 00:00:00",  # Optional.
                                      The expiry datetime of the password.
                                    "name": "str",  # Optional. The password name
                                      "password1" or "password2". Known values are: "password1" and
                                      "password2".
                                    "value": "str"  # Optional. The password
                                      value.
                                }
                            ]
                        },
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "scopeMapId": "str",  # Optional. The resource ID of the scope map to
                          which the token will be associated with.
                        "status": "str"  # Optional. The status of the token example enabled
                          or disabled. Known values are: "enabled" and "disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_initial(
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                token_name=token_name,
                token_create_parameters=token_create_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, registry_name: str, token_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_tokens_delete_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            token_name=token_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, registry_name: str, token_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Deletes a token from a container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param token_name: The name of the token. Required.
        :type token_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                token_name=token_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _update_initial(
        self,
        resource_group_name: str,
        registry_name: str,
        token_name: str,
        token_update_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(token_update_parameters, (IO, bytes)):
            _content = token_update_parameters
        else:
            _json = token_update_parameters

        request = build_tokens_update_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            token_name=token_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        registry_name: str,
        token_name: str,
        token_update_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a token with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param token_name: The name of the token. Required.
        :type token_name: str
        :param token_update_parameters: The parameters for updating a token. Required.
        :type token_update_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                token_update_parameters = {
                    "properties": {
                        "credentials": {
                            "certificates": [
                                {
                                    "encodedPemCertificate": "str",  # Optional.
                                      Base 64 encoded string of the public certificate1 in PEM format
                                      that will be used for authenticating the token.
                                    "expiry": "2020-02-20 00:00:00",  # Optional.
                                      The expiry datetime of the certificate.
                                    "name": "str",  # Optional. Known values are:
                                      "certificate1" and "certificate2".
                                    "thumbprint": "str"  # Optional. The
                                      thumbprint of the certificate.
                                }
                            ],
                            "passwords": [
                                {
                                    "creationTime": "2020-02-20 00:00:00",  #
                                      Optional. The creation datetime of the password.
                                    "expiry": "2020-02-20 00:00:00",  # Optional.
                                      The expiry datetime of the password.
                                    "name": "str",  # Optional. The password name
                                      "password1" or "password2". Known values are: "password1" and
                                      "password2".
                                    "value": "str"  # Optional. The password
                                      value.
                                }
                            ]
                        },
                        "scopeMapId": "str",  # Optional. The resource ID of the scope map to
                          which the token will be associated with.
                        "status": "str"  # Optional. The status of the token example enabled
                          or disabled. Known values are: "enabled" and "disabled".
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of scope map.
                        "credentials": {
                            "certificates": [
                                {
                                    "encodedPemCertificate": "str",  # Optional.
                                      Base 64 encoded string of the public certificate1 in PEM format
                                      that will be used for authenticating the token.
                                    "expiry": "2020-02-20 00:00:00",  # Optional.
                                      The expiry datetime of the certificate.
                                    "name": "str",  # Optional. Known values are:
                                      "certificate1" and "certificate2".
                                    "thumbprint": "str"  # Optional. The
                                      thumbprint of the certificate.
                                }
                            ],
                            "passwords": [
                                {
                                    "creationTime": "2020-02-20 00:00:00",  #
                                      Optional. The creation datetime of the password.
                                    "expiry": "2020-02-20 00:00:00",  # Optional.
                                      The expiry datetime of the password.
                                    "name": "str",  # Optional. The password name
                                      "password1" or "password2". Known values are: "password1" and
                                      "password2".
                                    "value": "str"  # Optional. The password
                                      value.
                                }
                            ]
                        },
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "scopeMapId": "str",  # Optional. The resource ID of the scope map to
                          which the token will be associated with.
                        "status": "str"  # Optional. The status of the token example enabled
                          or disabled. Known values are: "enabled" and "disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        registry_name: str,
        token_name: str,
        token_update_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a token with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param token_name: The name of the token. Required.
        :type token_name: str
        :param token_update_parameters: The parameters for updating a token. Required.
        :type token_update_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of scope map.
                        "credentials": {
                            "certificates": [
                                {
                                    "encodedPemCertificate": "str",  # Optional.
                                      Base 64 encoded string of the public certificate1 in PEM format
                                      that will be used for authenticating the token.
                                    "expiry": "2020-02-20 00:00:00",  # Optional.
                                      The expiry datetime of the certificate.
                                    "name": "str",  # Optional. Known values are:
                                      "certificate1" and "certificate2".
                                    "thumbprint": "str"  # Optional. The
                                      thumbprint of the certificate.
                                }
                            ],
                            "passwords": [
                                {
                                    "creationTime": "2020-02-20 00:00:00",  #
                                      Optional. The creation datetime of the password.
                                    "expiry": "2020-02-20 00:00:00",  # Optional.
                                      The expiry datetime of the password.
                                    "name": "str",  # Optional. The password name
                                      "password1" or "password2". Known values are: "password1" and
                                      "password2".
                                    "value": "str"  # Optional. The password
                                      value.
                                }
                            ]
                        },
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "scopeMapId": "str",  # Optional. The resource ID of the scope map to
                          which the token will be associated with.
                        "status": "str"  # Optional. The status of the token example enabled
                          or disabled. Known values are: "enabled" and "disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_update(
        self,
        resource_group_name: str,
        registry_name: str,
        token_name: str,
        token_update_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a token with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param token_name: The name of the token. Required.
        :type token_name: str
        :param token_update_parameters: The parameters for updating a token. Is either a model type or
         a IO type. Required.
        :type token_update_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationDate": "2020-02-20 00:00:00",  # Optional. The creation date
                          of scope map.
                        "credentials": {
                            "certificates": [
                                {
                                    "encodedPemCertificate": "str",  # Optional.
                                      Base 64 encoded string of the public certificate1 in PEM format
                                      that will be used for authenticating the token.
                                    "expiry": "2020-02-20 00:00:00",  # Optional.
                                      The expiry datetime of the certificate.
                                    "name": "str",  # Optional. Known values are:
                                      "certificate1" and "certificate2".
                                    "thumbprint": "str"  # Optional. The
                                      thumbprint of the certificate.
                                }
                            ],
                            "passwords": [
                                {
                                    "creationTime": "2020-02-20 00:00:00",  #
                                      Optional. The creation datetime of the password.
                                    "expiry": "2020-02-20 00:00:00",  # Optional.
                                      The expiry datetime of the password.
                                    "name": "str",  # Optional. The password name
                                      "password1" or "password2". Known values are: "password1" and
                                      "password2".
                                    "value": "str"  # Optional. The password
                                      value.
                                }
                            ]
                        },
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Creating", "Updating", "Deleting", "Succeeded",
                          "Failed", and "Canceled".
                        "scopeMapId": "str",  # Optional. The resource ID of the scope map to
                          which the token will be associated with.
                        "status": "str"  # Optional. The status of the token example enabled
                          or disabled. Known values are: "enabled" and "disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                token_name=token_name,
                token_update_parameters=token_update_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class WebhooksOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~container_registry_management_client.ContainerRegistryManagementClient`'s
        :attr:`webhooks` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, resource_group_name: str, registry_name: str, **kwargs: Any) -> Iterable[JSON]:
        """Lists all the webhooks for the specified container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "actions": [
                            "str"  # The list of actions that trigger the webhook to post
                              notifications. Required.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the webhook at the time the operation was called. Known values are:
                          "Creating", "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "scope": "str",  # Optional. The scope of repositories where the
                          event can be triggered. For example, 'foo:*' means events for all tags under
                          repository 'foo'. 'foo:bar' means events for 'foo:bar' only. 'foo' is
                          equivalent to 'foo:latest'. Empty means all events.
                        "status": "str"  # Optional. The status of the webhook at the time
                          the operation was called. Known values are: "enabled" and "disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_webhooks_list_request(
                    resource_group_name=resource_group_name,
                    registry_name=registry_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, registry_name: str, webhook_name: str, **kwargs: Any) -> JSON:
        """Gets the properties of the specified webhook.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param webhook_name: The name of the webhook. Required.
        :type webhook_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "actions": [
                            "str"  # The list of actions that trigger the webhook to post
                              notifications. Required.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the webhook at the time the operation was called. Known values are:
                          "Creating", "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "scope": "str",  # Optional. The scope of repositories where the
                          event can be triggered. For example, 'foo:*' means events for all tags under
                          repository 'foo'. 'foo:bar' means events for 'foo:bar' only. 'foo' is
                          equivalent to 'foo:latest'. Empty means all events.
                        "status": "str"  # Optional. The status of the webhook at the time
                          the operation was called. Known values are: "enabled" and "disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_webhooks_get_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            webhook_name=webhook_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_initial(
        self,
        resource_group_name: str,
        registry_name: str,
        webhook_name: str,
        webhook_create_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(webhook_create_parameters, (IO, bytes)):
            _content = webhook_create_parameters
        else:
            _json = webhook_create_parameters

        request = build_webhooks_create_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            webhook_name=webhook_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        webhook_name: str,
        webhook_create_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a webhook for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param webhook_name: The name of the webhook. Required.
        :type webhook_name: str
        :param webhook_create_parameters: The parameters for creating a webhook. Required.
        :type webhook_create_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                webhook_create_parameters = {
                    "location": "str",  # The location of the webhook. This cannot be changed
                      after the resource is created. Required.
                    "properties": {
                        "actions": [
                            "str"  # The list of actions that trigger the webhook to post
                              notifications. Required.
                        ],
                        "serviceUri": "str",  # The service URI for the webhook to post
                          notifications. Required.
                        "customHeaders": {
                            "str": "str"  # Optional. Custom headers that will be added
                              to the webhook notifications.
                        },
                        "scope": "str",  # Optional. The scope of repositories where the
                          event can be triggered. For example, 'foo:*' means events for all tags under
                          repository 'foo'. 'foo:bar' means events for 'foo:bar' only. 'foo' is
                          equivalent to 'foo:latest'. Empty means all events.
                        "status": "str"  # Optional. The status of the webhook at the time
                          the operation was called. Known values are: "enabled" and "disabled".
                    },
                    "tags": {
                        "str": "str"  # Optional. The tags for the webhook.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "actions": [
                            "str"  # The list of actions that trigger the webhook to post
                              notifications. Required.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the webhook at the time the operation was called. Known values are:
                          "Creating", "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "scope": "str",  # Optional. The scope of repositories where the
                          event can be triggered. For example, 'foo:*' means events for all tags under
                          repository 'foo'. 'foo:bar' means events for 'foo:bar' only. 'foo' is
                          equivalent to 'foo:latest'. Empty means all events.
                        "status": "str"  # Optional. The status of the webhook at the time
                          the operation was called. Known values are: "enabled" and "disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        webhook_name: str,
        webhook_create_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a webhook for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param webhook_name: The name of the webhook. Required.
        :type webhook_name: str
        :param webhook_create_parameters: The parameters for creating a webhook. Required.
        :type webhook_create_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "actions": [
                            "str"  # The list of actions that trigger the webhook to post
                              notifications. Required.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the webhook at the time the operation was called. Known values are:
                          "Creating", "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "scope": "str",  # Optional. The scope of repositories where the
                          event can be triggered. For example, 'foo:*' means events for all tags under
                          repository 'foo'. 'foo:bar' means events for 'foo:bar' only. 'foo' is
                          equivalent to 'foo:latest'. Empty means all events.
                        "status": "str"  # Optional. The status of the webhook at the time
                          the operation was called. Known values are: "enabled" and "disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create(
        self,
        resource_group_name: str,
        registry_name: str,
        webhook_name: str,
        webhook_create_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a webhook for a container registry with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param webhook_name: The name of the webhook. Required.
        :type webhook_name: str
        :param webhook_create_parameters: The parameters for creating a webhook. Is either a model type
         or a IO type. Required.
        :type webhook_create_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "actions": [
                            "str"  # The list of actions that trigger the webhook to post
                              notifications. Required.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the webhook at the time the operation was called. Known values are:
                          "Creating", "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "scope": "str",  # Optional. The scope of repositories where the
                          event can be triggered. For example, 'foo:*' means events for all tags under
                          repository 'foo'. 'foo:bar' means events for 'foo:bar' only. 'foo' is
                          equivalent to 'foo:latest'. Empty means all events.
                        "status": "str"  # Optional. The status of the webhook at the time
                          the operation was called. Known values are: "enabled" and "disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_initial(
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                webhook_name=webhook_name,
                webhook_create_parameters=webhook_create_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, registry_name: str, webhook_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_webhooks_delete_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            webhook_name=webhook_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, registry_name: str, webhook_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Deletes a webhook from a container registry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param webhook_name: The name of the webhook. Required.
        :type webhook_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                webhook_name=webhook_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _update_initial(
        self,
        resource_group_name: str,
        registry_name: str,
        webhook_name: str,
        webhook_update_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(webhook_update_parameters, (IO, bytes)):
            _content = webhook_update_parameters
        else:
            _json = webhook_update_parameters

        request = build_webhooks_update_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            webhook_name=webhook_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        registry_name: str,
        webhook_name: str,
        webhook_update_parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a webhook with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param webhook_name: The name of the webhook. Required.
        :type webhook_name: str
        :param webhook_update_parameters: The parameters for updating a webhook. Required.
        :type webhook_update_parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                webhook_update_parameters = {
                    "properties": {
                        "actions": [
                            "str"  # Optional. The list of actions that trigger the
                              webhook to post notifications.
                        ],
                        "customHeaders": {
                            "str": "str"  # Optional. Custom headers that will be added
                              to the webhook notifications.
                        },
                        "scope": "str",  # Optional. The scope of repositories where the
                          event can be triggered. For example, 'foo:*' means events for all tags under
                          repository 'foo'. 'foo:bar' means events for 'foo:bar' only. 'foo' is
                          equivalent to 'foo:latest'. Empty means all events.
                        "serviceUri": "str",  # Optional. The service URI for the webhook to
                          post notifications.
                        "status": "str"  # Optional. The status of the webhook at the time
                          the operation was called. Known values are: "enabled" and "disabled".
                    },
                    "tags": {
                        "str": "str"  # Optional. The tags for the webhook.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "actions": [
                            "str"  # The list of actions that trigger the webhook to post
                              notifications. Required.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the webhook at the time the operation was called. Known values are:
                          "Creating", "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "scope": "str",  # Optional. The scope of repositories where the
                          event can be triggered. For example, 'foo:*' means events for all tags under
                          repository 'foo'. 'foo:bar' means events for 'foo:bar' only. 'foo' is
                          equivalent to 'foo:latest'. Empty means all events.
                        "status": "str"  # Optional. The status of the webhook at the time
                          the operation was called. Known values are: "enabled" and "disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        registry_name: str,
        webhook_name: str,
        webhook_update_parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a webhook with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param webhook_name: The name of the webhook. Required.
        :type webhook_name: str
        :param webhook_update_parameters: The parameters for updating a webhook. Required.
        :type webhook_update_parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "actions": [
                            "str"  # The list of actions that trigger the webhook to post
                              notifications. Required.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the webhook at the time the operation was called. Known values are:
                          "Creating", "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "scope": "str",  # Optional. The scope of repositories where the
                          event can be triggered. For example, 'foo:*' means events for all tags under
                          repository 'foo'. 'foo:bar' means events for 'foo:bar' only. 'foo' is
                          equivalent to 'foo:latest'. Empty means all events.
                        "status": "str"  # Optional. The status of the webhook at the time
                          the operation was called. Known values are: "enabled" and "disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_update(
        self,
        resource_group_name: str,
        registry_name: str,
        webhook_name: str,
        webhook_update_parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a webhook with the specified parameters.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param webhook_name: The name of the webhook. Required.
        :type webhook_name: str
        :param webhook_update_parameters: The parameters for updating a webhook. Is either a model type
         or a IO type. Required.
        :type webhook_update_parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "actions": [
                            "str"  # The list of actions that trigger the webhook to post
                              notifications. Required.
                        ],
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the webhook at the time the operation was called. Known values are:
                          "Creating", "Updating", "Deleting", "Succeeded", "Failed", and "Canceled".
                        "scope": "str",  # Optional. The scope of repositories where the
                          event can be triggered. For example, 'foo:*' means events for all tags under
                          repository 'foo'. 'foo:bar' means events for 'foo:bar' only. 'foo' is
                          equivalent to 'foo:latest'. Empty means all events.
                        "status": "str"  # Optional. The status of the webhook at the time
                          the operation was called. Known values are: "enabled" and "disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                registry_name=registry_name,
                webhook_name=webhook_name,
                webhook_update_parameters=webhook_update_parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def ping(self, resource_group_name: str, registry_name: str, webhook_name: str, **kwargs: Any) -> JSON:
        """Triggers a ping event to be sent to the webhook.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param webhook_name: The name of the webhook. Required.
        :type webhook_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str"  # Optional. The event ID.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_webhooks_ping_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            webhook_name=webhook_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list_events(
        self, resource_group_name: str, registry_name: str, webhook_name: str, **kwargs: Any
    ) -> Iterable[JSON]:
        """Lists recent events for the specified webhook.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param webhook_name: The name of the webhook. Required.
        :type webhook_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "eventRequestMessage": {
                        "content": {
                            "action": "str",  # Optional. The action that encompasses the
                              provided event.
                            "actor": {
                                "name": "str"  # Optional. The subject or username
                                  associated with the request context that generated the event.
                            },
                            "id": "str",  # Optional. The event ID.
                            "request": {
                                "addr": "str",  # Optional. The IP or hostname and
                                  possibly port of the client connection that initiated the event. This
                                  is the RemoteAddr from the standard http request.
                                "host": "str",  # Optional. The externally accessible
                                  hostname of the registry instance, as specified by the http host
                                  header on incoming requests.
                                "id": "str",  # Optional. The ID of the request that
                                  initiated the event.
                                "method": "str",  # Optional. The request method that
                                  generated the event.
                                "useragent": "str"  # Optional. The user agent header
                                  of the request.
                            },
                            "source": {
                                "addr": "str",  # Optional. The IP or hostname and
                                  the port of the registry node that generated the event. Generally,
                                  this will be resolved by os.Hostname() along with the running port.
                                "instanceID": "str"  # Optional. The running instance
                                  of an application. Changes after each restart.
                            },
                            "target": {
                                "digest": "str",  # Optional. The digest of the
                                  content, as defined by the Registry V2 HTTP API Specification.
                                "length": 0,  # Optional. The number of bytes of the
                                  content. Same as Size field.
                                "mediaType": "str",  # Optional. The MIME type of the
                                  referenced object.
                                "name": "str",  # Optional. The name of the artifact.
                                "repository": "str",  # Optional. The repository
                                  name.
                                "size": 0,  # Optional. The number of bytes of the
                                  content. Same as Length field.
                                "tag": "str",  # Optional. The tag name.
                                "url": "str",  # Optional. The direct URL to the
                                  content.
                                "version": "str"  # Optional. The version of the
                                  artifact.
                            },
                            "timestamp": "2020-02-20 00:00:00"  # Optional. The time at
                              which the event occurred.
                        },
                        "headers": {
                            "str": "str"  # Optional. The headers of the event request
                              message.
                        },
                        "method": "str",  # Optional. The HTTP method used to send the event
                          request message.
                        "requestUri": "str",  # Optional. The URI used to send the event
                          request message.
                        "version": "str"  # Optional. The HTTP message version.
                    },
                    "eventResponseMessage": {
                        "content": "str",  # Optional. The content of the event response
                          message.
                        "headers": {
                            "str": "str"  # Optional. The headers of the event response
                              message.
                        },
                        "reasonPhrase": "str",  # Optional. The reason phrase of the event
                          response message.
                        "statusCode": "str",  # Optional. The status code of the event
                          response message.
                        "version": "str"  # Optional. The HTTP message version.
                    },
                    "id": "str"  # Optional. The event ID.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_webhooks_list_events_request(
                    resource_group_name=resource_group_name,
                    registry_name=registry_name,
                    webhook_name=webhook_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_callback_config(
        self, resource_group_name: str, registry_name: str, webhook_name: str, **kwargs: Any
    ) -> JSON:
        """Gets the configuration of service URI and custom headers for the webhook.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param registry_name: The name of the container registry. Required.
        :type registry_name: str
        :param webhook_name: The name of the webhook. Required.
        :type webhook_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "serviceUri": "str",  # The service URI for the webhook to post
                      notifications. Required.
                    "customHeaders": {
                        "str": "str"  # Optional. Custom headers that will be added to the
                          webhook notifications.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_webhooks_get_callback_config_request(
            resource_group_name=resource_group_name,
            registry_name=registry_name,
            webhook_name=webhook_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)
