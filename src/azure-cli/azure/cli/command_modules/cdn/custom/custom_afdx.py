# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# --------------------------------------------------------------------------------------------

from typing import (Optional, List)
from azure.mgmt.cdn.models import (AFDEndpoint, HealthProbeRequestType, EnabledState, Route, LinkToDefaultDomain,
                                   ResourceReference, AFDEndpointProtocols, HttpsRedirect, ForwardingProtocol,
                                   AfdQueryStringCachingBehavior, HealthProbeParameters, MatchProcessingBehavior,
                                   AFDOrigin, AFDOriginGroup, SharedPrivateLinkResourceProperties, CompressionSettings,
                                   LoadBalancingSettingsParameters, SecurityPolicyWebApplicationFirewallParameters,
                                   SecurityPolicyWebApplicationFirewallAssociation, CustomerCertificateParameters,
                                   AFDDomain, AFDDomainHttpsParameters, AfdCertificateType, AfdMinimumTlsVersion,
                                   AFDEndpointUpdateParameters, SkuName, AfdPurgeParameters, ActivatedResourceReference,
                                   SecurityPolicy, ProfileUpdateParameters, AfdRouteCacheConfiguration,
                                   AutoGeneratedDomainNameLabelScope, Secret)

from azure.mgmt.cdn.operations import (AFDOriginGroupsOperations, AFDOriginsOperations, AFDProfilesOperations,
                                       SecretsOperations, AFDEndpointsOperations, RoutesOperations, RuleSetsOperations,
                                       RulesOperations, SecurityPoliciesOperations, AFDCustomDomainsOperations,
                                       ProfilesOperations)

from azure.cli.core.util import (sdk_no_wait)
from azure.cli.core.azclierror import (InvalidArgumentValueError)
from azure.core.exceptions import (ResourceNotFoundError)

from knack.log import get_logger
from msrest.polling import LROPoller, NoPolling

from .custom import _update_mapper
from azure.cli.core.aaz._base import has_value

from .custom_rule_util import (create_condition, create_action)

logger = get_logger(__name__)


def default_content_types():
    return ["application/eot",
            "application/font",
            "application/font-sfnt",
            "application/javascript",
            "application/json",
            "application/opentype",
            "application/otf",
            "application/pkcs7-mime",
            "application/truetype",
            "application/ttf",
            "application/vnd.ms-fontobject",
            "application/xhtml+xml",
            "application/xml",
            "application/xml+rss",
            "application/x-font-opentype",
            "application/x-font-truetype",
            "application/x-font-ttf",
            "application/x-httpd-cgi",
            "application/x-javascript",
            "application/x-mpegurl",
            "application/x-opentype",
            "application/x-otf",
            "application/x-perl",
            "application/x-ttf",
            "font/eot",
            "font/ttf",
            "font/otf",
            "font/opentype",
            "image/svg+xml",
            "text/css",
            "text/csv",
            "text/html",
            "text/javascript",
            "text/js",
            "text/plain",
            "text/richtext",
            "text/tab-separated-values",
            "text/xml",
            "text/x-script",
            "text/x-component",
            "text/x-java-source"]

from azure.cli.command_modules.cdn.aaz.latest.afd.origin import Create as _AFDOriginCreate
class AFDOriginCreate(_AFDOriginCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZBoolArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.enable_private_link = AAZBoolArg(options=['--enable-private-link'],
                                                  help="Indicates whether private link is enanbled on that origin.")
        return args_schema

    def pre_operations(self):
        args = self.ctx.args
        if has_value(args.enable_private_link) is False or args.enable_private_link is False:
            args.private_link_location = None
            args.private_link_resource = None
            args.private_link_request_message = None
            args.private_link_sub_resource_type = None

from azure.cli.command_modules.cdn.aaz.latest.afd.origin import Update as _AFDOriginUpdate
class AFDOriginUpdate(_AFDOriginUpdate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZBoolArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.enable_private_link = AAZBoolArg(options=['--enable-private-link'],
                                                  help="Indicates whether private link is enanbled on that origin.")
        return args_schema

    def pre_operations(self):
        args = self.ctx.args
        if has_value(args.enable_private_link) is False or args.enable_private_link is False:
            args.private_link_location = None
            args.private_link_resource = None
            args.private_link_request_message = None
            args.private_link_sub_resource_type = None

from azure.cli.command_modules.cdn.aaz.latest.afd.route import Create as _AFDRouteCreate
class AFDRouteCreate(_AFDRouteCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZBoolArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.enable_caching = AAZBoolArg(options=['--enable-caching'],
                                                  help="Indicates whether caching is enanbled on that route.")
        return args_schema

    def pre_operations(self):
        args = self.ctx.args
        if has_value(args.enable_caching) is False or args.enable_caching is False:
            args.query_string_caching_behavior = None
            args.query_parameters = None

from azure.cli.command_modules.cdn.aaz.latest.afd.route import Update as _AFDRouteUpdate
class AFDRouteUpdate(_AFDRouteUpdate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZBoolArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.enable_caching = AAZBoolArg(options=['--enable-caching'],
                                                  help="Indicates whether caching is enanbled on that route.")
        return args_schema

    def pre_operations(self):
        args = self.ctx.args
        if has_value(args.enable_caching) is False or args.enable_caching is False:
            args.query_string_caching_behavior = None
            args.query_parameters = None

from azure.cli.command_modules.cdn.aaz.latest.afd.rule import Create as _AFDRuleCreate
class AFDRuleCreate(_AFDRuleCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZStrArg, AAZDateArg, AAZBoolArg, AAZListArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.action_name = AAZStrArg(options=['--action-name'],
                                                  help="The name of the action for the delivery rule: https://docs.microsoft.com/en-us/azure/frontdoor/front-door-rules-engine-actions.")
        args_schema.cache_behavior = AAZStrArg(options=['--cache-behavior'],
                                                  help="Caching behavior for the requests.")
        args_schema.cache_duration = AAZDateArg(options=['--cache-duration'],
                                                    help="The duration for which the content needs to be cached. Allowed format is [d.]hh:mm:ss.")
        args_schema.custom_fragment = AAZStrArg(options=['--custom-fragment'],
                                                  help="Fragment to add to the redirect URL.")
        args_schema.custom_hostname = AAZStrArg(options=['--custom-hostname'],
                                                    help="Host to redirect. Leave empty to use the incoming host as the destination host.")
        args_schema.custom_path = AAZStrArg(options=['--custom-path'],
                                                    help="The full path to redirect. Path cannot be empty and must start with /. Leave empty to use the incoming path as destination pat")
        args_schema.custom_query_string = AAZStrArg(options=['--custom-query-string'],
                                                    help="The set of query strings to be placed in the redirect URL. leave empty to preserve the incoming query string.")
        args_schema.destination = AAZStrArg(options=['--destination'],
                                                    help="The destination path to be used in the rewrite.")
        args_schema.enable_caching = AAZBoolArg(options=['--enable-caching'],
                                                    help="Indicates whether to enable caching on the route.")
        args_schema.enable_compression = AAZBoolArg(options=['--enable-compression'],
                                                    help="Indicates whether content compression is enabled on AzureFrontDoor. Default value is false. If compression is enabled, content will be served as compressed if user requests for a compressed version. Content won't be compressed on AzureFrontDoor when requested content is smaller than 1 byte or larger than 1 MB.")
        args_schema.forwarding_protocol = AAZStrArg(options=['--forwarding-protocol'],
                                                    help="Protocol this rule will use when forwarding traffic to backends.")
        args_schema.header_action = AAZStrArg(options=['--header-action'],
                                                    help="Header action for the requests.")
        args_schema.header_name = AAZStrArg(options=['--header-name'],
                                                    help="Name of the header to modify.")
        args_schema.header_value = AAZStrArg(options=['--header-value'],
                                                    help="Value of the header.")
        args_schema.match_values = AAZListArg(options=['--match-values'],
                                                    help="Match values of the match condition. e.g, space separated values \"GET\" \"HTTP\".")
        args_schema.match_values.Element = AAZStrArg()
        args_schema.match_variable = AAZStrArg(options=['--match-variable'],
                                                    help="Name of the match condition: https://docs.microsoft.com/en-us/azure/frontdoor/rules-match-conditions.")
        args_schema.negate_condition = AAZBoolArg(options=['--negate-condition'],
                                                    help="If true, negates the condition.")
        args_schema.operator = AAZStrArg(options=['--operator'],
                                                    help="Operator of the match condition.")
        args_schema.origin_group = AAZStrArg(options=['--origin-group'],
                                                    help="Name or ID of the OriginGroup that would override the default OriginGroup.")
        args_schema.preserve_unmatched_path = AAZBoolArg(options=['--preserve-unmatched-path'],
                                                    help="If True, the remaining path after the source pattern will be appended to the new destination path.")
        args_schema.query_parameters = AAZStrArg(options=['--query-parameters'],
                                                    help="Query parameters to include or exclude.")
        args_schema.query_string_caching_behavior = AAZStrArg(options=['--query-string-caching-behavior'],
                                                    help="Defines how CDN caches requests that include query strings. You can ignore any query strings when caching, bypass caching to prevent requests that contain query strings from being cached, or cache every request with a unique URL.")
        args_schema.redirect_protocol = AAZStrArg(options=['--redirect-protocol'],
                                                    help="Protocol to use for the redirect.")
        args_schema.redirect_type = AAZStrArg(options=['--redirect-type'],
                                                    help="The redirect type the rule will use when redirecting traffic.")
        args_schema.selector = AAZStrArg(options=['--selector'],
                                                    help="Selector of the match condition.")
        args_schema.source_pattern = AAZStrArg(options=['--source-pattern'],
                                                    help="A request URI pattern that identifies the type of requests that may be rewritten.")
        args_schema.transforms = AAZListArg(options=['--transforms'],
                                                    help="Transform to apply before matching.")
        args_schema.transforms.Element = AAZStrArg()
        return args_schema
    def pre_operations(self):
        args = self.ctx.args
        # args.parameters.customer_certificate.secret_source = args.action_name
        # conditions
        conditions = []
        condition = create_condition(args.match_variable, args.operator, args.match_values, args.selector, args.negate_condition, args.transforms)
        if condition is not None:
            conditions.append(condition)
        args.conditions = conditions

        # actions
        actions = []
        action = create_action(args.action_name, args.cache_behavior, args.cache_duration, args.header_action,
                                args.header_name, args.header_value, None, args.query_parameters, args.redirect_type, args.redirect_protocol, args.custom_hostname,
                                args.custom_path, args.custom_query_string, args.custom_fragment, args.source_pattern,
                                args.destination, args.preserve_unmatched_path, 
                                origin_group=args.origin_group, 
                                sub_id=self.ctx.subscription_id,
                                enable_caching=args.enable_caching,
                                resource_group_name=args.resource_group,
                                profile_name=args.profile_name,
                                is_compression_enabled=None,
                                query_string_caching_behavior=args.query_string_caching_behavior,
                                forwarding_protocol=args.forwarding_protocol)
        if action is not None:
            actions.append(action)
        args.actions = actions

from azure.cli.command_modules.cdn.aaz.latest.afd.rule import Show as RuleShow
def add_condition(cmd, resource_group_name, profile_name, rule_set_name,
                           rule_name, match_variable, operator, match_values=None, selector=None,
                           negate_condition=None, transforms=None):
    existing_conditions = RuleShow(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name
    })["conditions"]
    condition = create_condition(match_variable, operator, match_values, selector, negate_condition, transforms)

    return _AFDRuleCreate(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name,
        "conditions": existing_conditions.append(condition)
    })

def add_afd_rule_condition(cmd, resource_group_name, profile_name, rule_set_name,
                           rule_name, match_variable, operator, match_values=None, selector=None,
                           negate_condition=None, transforms=None):

    existing_conditions = RuleShow(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name
    })["actions"]
    condition = create_condition(match_variable, operator, match_values, selector, negate_condition, transforms)

    return _AFDRuleCreate(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name,
        "conditions": existing_conditions.append(condition)
    })

def add_afd_rule_action(cmd, resource_group_name, profile_name, rule_set_name,
                        rule_name, action_name, cache_behavior=None, cache_duration=None,
                        header_action=None, header_name=None, header_value=None,
                        query_parameters=None, redirect_type=None, redirect_protocol=None, custom_hostname=None,
                        custom_path=None, custom_querystring=None, custom_fragment=None, source_pattern=None,
                        destination=None, preserve_unmatched_path=None, origin_group=None,
                        forwarding_protocol: ForwardingProtocol = None,
                        query_string_caching_behavior: AfdQueryStringCachingBehavior = None,
                        is_compression_enabled=None,
                        enable_caching=None):
    existing_actions = RuleShow(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name
    })["actions"]
    action = create_action(action_name, cache_behavior, cache_duration, header_action, header_name,
                           header_value, None, None if query_parameters is None else ",".join(query_parameters),
                           redirect_type, redirect_protocol, custom_hostname, custom_path, custom_querystring,
                           custom_fragment, source_pattern, destination, preserve_unmatched_path,
                           cmd=cmd, resource_group_name=resource_group_name,
                           forwarding_protocol=forwarding_protocol,
                           origin_group=origin_group, profile_name=profile_name,
                           query_string_caching_behavior=query_string_caching_behavior,
                           is_compression_enabled=is_compression_enabled,
                           enable_caching=enable_caching)

    return _AFDRuleCreate(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name,
        "actions": existing_actions.append(action)
    })

def remove_afd_rule_condition(cmd, resource_group_name, profile_name,
                              rule_set_name, rule_name, index):

    existing_conditions = RuleShow(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name
    })
    if len(existing_conditions) > 1 and index < len(existing_conditions):
        existing_conditions.pop(index)
    else:
        logger.warning("Invalid condition index found. This command will be skipped. Please check the rule.")

    return _AFDRuleCreate(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name,
        "conditions": existing_conditions,
    })

def remove_afd_rule_action(cmd, resource_group_name, profile_name, rule_set_name, rule_name, index):

    existing_actions = RuleShow(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name
    })["actions"]
    if len(existing_actions) > 1 and index < len(existing_actions):
        existing_actions.pop(index)
    else:
        logger.warning("Invalid condition index found. This command will be skipped. Please check the rule.")

    return _AFDRuleCreate(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name,
        "actions": existing_actions,
    })

def list_afd_rule_condition(cmd, resource_group_name,
                            profile_name, rule_set_name,
                            rule_name):
    rule = RuleShow(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name
    })

    return rule["conditions"]


def list_afd_rule_action(cmd, resource_group_name,
                         profile_name, rule_set_name,
                         rule_name):
    rule = RuleShow(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name
    })
    
    return rule["actions"]

from azure.cli.command_modules.cdn.aaz.latest.afd.secret import Create as _AFDSecretCreate
class AFDSecretCreate(_AFDSecretCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZStrArg, AAZBoolArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.secret_source = AAZStrArg(options=['--secret-source'],
                                                  help="Resource ID of the Azure Key Vault certificate, expected format is like /subscriptions/sub1/resourceGroups/rg1/providers/Microsoft.KeyVault/vaults/vault1/secrets/cert1.",
                                                  required=True)
        args_schema.secret_version = AAZStrArg(options=['--secret-version'],
                                                  help="Version of the certificate to be used.",
                                                  required=False)
        args_schema.use_latest_version = AAZBoolArg(options=['--use-latest-version'],
                                                  help="Whether to use the latest version for the certificate.",
                                                  required=False)
        return args_schema
    def pre_operations(self):
        args = self.ctx.args
        args.parameters.customer_certificate.secret_source = args.secret_source
        if has_value(args.secret_version):
            args.parameters.customer_certificate.secret_version = args.secret_version
        if has_value(args.use_latest_version):
            args.parameters.customer_certificate.use_latest_version = args.use_latest_version
            
from azure.cli.command_modules.cdn.aaz.latest.afd.secret import Create as _AFDSecretCreate
class AFDSecretCreate(_AFDSecretCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZStrArg, AAZBoolArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.secret_source = AAZStrArg(options=['--secret-source'],
                                                  help="Resource ID of the Azure Key Vault certificate, expected format is like /subscriptions/sub1/resourceGroups/rg1/providers/Microsoft.KeyVault/vaults/vault1/secrets/cert1.",
                                                  required=True)
        args_schema.secret_version = AAZStrArg(options=['--secret-version'],
                                                  help="Version of the certificate to be used.",
                                                  required=False)
        args_schema.use_latest_version = AAZBoolArg(options=['--use-latest-version'],
                                                  help="Whether to use the latest version for the certificate.",
                                                  required=False)
        return args_schema
    def pre_operations(self):
        args = self.ctx.args
        args.parameters.customer_certificate.secret_source = args.secret_source
        if has_value(args.secret_version):
            args.parameters.customer_certificate.secret_version = args.secret_version
        if has_value(args.use_latest_version):
            args.parameters.customer_certificate.use_latest_version = args.use_latest_version

from azure.cli.command_modules.cdn.aaz.latest.afd.secret import Update as _AFDSecretUpdate
class AFDSecretUpdate(_AFDSecretUpdate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZStrArg, AAZBoolArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.secret_source = AAZStrArg(options=['--secret-source'],
                                                  help="Resource ID of the Azure Key Vault certificate, expected format is like /subscriptions/sub1/resourceGroups/rg1/providers/Microsoft.KeyVault/vaults/vault1/secrets/cert1.",
                                                  required=True)
        args_schema.secret_version = AAZStrArg(options=['--secret-version'],
                                                  help="Version of the certificate to be used.",
                                                  required=False)
        args_schema.use_latest_version = AAZBoolArg(options=['--use-latest-version'],
                                                  help="Whether to use the latest version for the certificate.",
                                                  required=False)
        return args_schema
    def pre_operations(self):
        args = self.ctx.args
        args.parameters.customer_certificate.secret_source = args.secret_source
        if has_value(args.secret_version):
            args.parameters.customer_certificate.secret_version = args.secret_version
        if has_value(args.use_latest_version):
            args.parameters.customer_certificate.use_latest_version = args.use_latest_version

from azure.cli.command_modules.cdn.aaz.latest.afd.security_policy import Create as _AFDSecurityPolicyCreate
from azure.cli.core.aaz.utils import assign_aaz_list_arg
class AFDSecurityPolicyCreate(_AFDSecurityPolicyCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZListArg, AAZStrArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.domains = AAZListArg(options=['--domains'],
                                                  help="The domains to associate with the WAF policy. Could either be the ID of an endpoint (default domain will be used in that case) or ID of a custom domain.",
                                                  required=True)
        args_schema.domains.Element = AAZStrArg()
        args_schema.waf_policy = AAZStrArg(options=['--waf-policy'],
                                                  help="The ID of Front Door WAF policy.",
                                                  required=True)
        return args_schema
    def pre_operations(self):
        args = self.ctx.args
        args.web_application_firewall.waf_policy = args.waf_policy
        args.web_application_firewall.associations[0].domains = assign_aaz_list_arg(
            args.web_application_firewall.associations[0].domains,
            args.domains,
            element_transformer=lambda _, domains_id: {"id": domains_id})
    
from azure.cli.command_modules.cdn.aaz.latest.afd.security_policy import Update as _AFDSecurityPolicyUpdate
class AFDSecurityPolicyUpdate(_AFDSecurityPolicyUpdate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZListArg, AAZStrArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.domains = AAZListArg(options=['--domains'],
                                                  help="The domains to associate with the WAF policy. Could either be the ID of an endpoint (default domain will be used in that case) or ID of a custom domain.",
                                                  required=True)
        args_schema.domains.Element = AAZStrArg()
        
        args_schema.waf_policy = AAZStrArg(options=['--waf-policy'],
                                                  help="The ID of Front Door WAF policy.",
                                                  required=True)
        return args_schema
    def pre_operations(self):
        args = self.ctx.args
        args.web_application_firewall.waf_policy = args.waf_policy
        args.web_application_firewall.associations[0].domains = assign_aaz_list_arg(
            args.web_application_firewall.associations[0].domains,
            args.domains,
            element_transformer=lambda _, domains_id: {"id": domains_id})