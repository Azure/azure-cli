# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# --------------------------------------------------------------------------------------------

from typing import (Optional, List)
from azure.mgmt.cdn.models import (AFDEndpoint, HealthProbeRequestType, EnabledState, Route, LinkToDefaultDomain,
                                   ResourceReference, AFDEndpointProtocols, HttpsRedirect, ForwardingProtocol,
                                   AfdQueryStringCachingBehavior, HealthProbeParameters, MatchProcessingBehavior,
                                   AFDOrigin, AFDOriginGroup, SharedPrivateLinkResourceProperties, CompressionSettings,
                                   LoadBalancingSettingsParameters, SecurityPolicyWebApplicationFirewallParameters,
                                   SecurityPolicyWebApplicationFirewallAssociation, CustomerCertificateParameters,
                                   AFDDomain, AFDDomainHttpsParameters, AfdCertificateType, AfdMinimumTlsVersion,
                                   AFDEndpointUpdateParameters, SkuName, AfdPurgeParameters, ActivatedResourceReference,
                                   SecurityPolicy, ProfileUpdateParameters, AfdRouteCacheConfiguration,
                                   AutoGeneratedDomainNameLabelScope, Secret, RuleIsCompressionEnabled, RequestMethodOperator)

from azure.mgmt.cdn.operations import (AFDOriginGroupsOperations, AFDOriginsOperations, AFDProfilesOperations,
                                       SecretsOperations, AFDEndpointsOperations, RoutesOperations, RuleSetsOperations,
                                       RulesOperations, SecurityPoliciesOperations, AFDCustomDomainsOperations,
                                       ProfilesOperations)

from azure.cli.core.commands.client_factory import get_subscription_id
from azure.cli.core.util import (sdk_no_wait)
from azure.cli.core.azclierror import (InvalidArgumentValueError)
from azure.core.exceptions import (ResourceNotFoundError)

from knack.log import get_logger
from msrest.polling import LROPoller, NoPolling

from .custom import _update_mapper
from azure.cli.core.aaz._base import has_value
from msrestazure.tools import is_valid_resource_id

logger = get_logger(__name__)


def default_content_types():
    return ["application/eot",
            "application/font",
            "application/font-sfnt",
            "application/javascript",
            "application/json",
            "application/opentype",
            "application/otf",
            "application/pkcs7-mime",
            "application/truetype",
            "application/ttf",
            "application/vnd.ms-fontobject",
            "application/xhtml+xml",
            "application/xml",
            "application/xml+rss",
            "application/x-font-opentype",
            "application/x-font-truetype",
            "application/x-font-ttf",
            "application/x-httpd-cgi",
            "application/x-javascript",
            "application/x-mpegurl",
            "application/x-opentype",
            "application/x-otf",
            "application/x-perl",
            "application/x-ttf",
            "font/eot",
            "font/ttf",
            "font/otf",
            "font/opentype",
            "image/svg+xml",
            "text/css",
            "text/csv",
            "text/html",
            "text/javascript",
            "text/js",
            "text/plain",
            "text/richtext",
            "text/tab-separated-values",
            "text/xml",
            "text/x-script",
            "text/x-component",
            "text/x-java-source"]

from azure.cli.command_modules.cdn.aaz.latest.afd.origin import Create as _AFDOriginCreate
class AFDOriginCreate(_AFDOriginCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZBoolArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.enable_private_link = AAZBoolArg(options=['--enable-private-link'],
                                                  help="Indicates whether private link is enanbled on that origin.")
        return args_schema

    def pre_operations(self):
        args = self.ctx.args
        if has_value(args.enable_private_link) is False or args.enable_private_link is False:
            args.private_link_location = None
            args.private_link_resource = None
            args.private_link_request_message = None
            args.private_link_sub_resource_type = None

from azure.cli.command_modules.cdn.aaz.latest.afd.origin import Update as _AFDOriginUpdate
class AFDOriginUpdate(_AFDOriginUpdate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZBoolArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.enable_private_link = AAZBoolArg(options=['--enable-private-link'],
                                                  help="Indicates whether private link is enanbled on that origin.")
        return args_schema

    def pre_operations(self):
        args = self.ctx.args
        if has_value(args.enable_private_link) is False or args.enable_private_link is False:
            args.private_link_location = None
            args.private_link_resource = None
            args.private_link_request_message = None
            args.private_link_sub_resource_type = None

from azure.cli.command_modules.cdn.aaz.latest.afd.route import Create as _AFDRouteCreate
class AFDRouteCreate(_AFDRouteCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZBoolArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.enable_caching = AAZBoolArg(options=['--enable-caching'],
                                                  help="Indicates whether caching is enanbled on that route.")
        return args_schema

    def pre_operations(self):
        args = self.ctx.args
        if has_value(args.enable_caching) is False or args.enable_caching is False:
            args.query_string_caching_behavior = None
            args.query_parameters = None

from azure.cli.command_modules.cdn.aaz.latest.afd.route import Update as _AFDRouteUpdate
class AFDRouteUpdate(_AFDRouteUpdate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZBoolArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.enable_caching = AAZBoolArg(options=['--enable-caching'],
                                                  help="Indicates whether caching is enanbled on that route.")
        return args_schema

    def pre_operations(self):
        args = self.ctx.args
        if has_value(args.enable_caching) is False or args.enable_caching is False:
            args.query_string_caching_behavior = None
            args.query_parameters = None

from azure.cli.command_modules.cdn.aaz.latest.afd.rule import Create as RuleCreate, Show as RuleShow

def create_afd_rule(cmd, resource_group_name, profile_name, rule_set_name,
                    order, rule_name, action_name, match_variable=None, operator=None,
                    match_values=None, selector=None, negate_condition=None, transforms=None,
                    cache_behavior=None, cache_duration=None, header_action=None,
                    header_name=None, header_value=None, query_parameters=None,
                    redirect_type=None, redirect_protocol=None, custom_hostname=None, custom_path=None,
                    custom_querystring=None, custom_fragment=None, source_pattern=None,
                    destination=None, preserve_unmatched_path=None, origin_group=None,
                    enable_caching=None, is_compression_enabled=None, query_string_caching_behavior=None,
                    match_processing_behavior: MatchProcessingBehavior = None,
                    forwarding_protocol: ForwardingProtocol = None):
    from azure.mgmt.cdn.models import Rule
    from .custom import create_condition
    from .custom import create_action

    conditions = []
    condition = create_condition(match_variable, operator, match_values, selector, negate_condition, transforms)
    if condition is not None:
        conditions.append(condition)

    actions = []
    action = create_action(action_name, cache_behavior, cache_duration, header_action, header_name,
                           header_value, None, None if query_parameters is None else ",".join(query_parameters),
                           redirect_type, redirect_protocol, custom_hostname, custom_path, custom_querystring,
                           custom_fragment, source_pattern, destination, preserve_unmatched_path,
                           origin_group=origin_group,
                           cmd=cmd,
                           enable_caching=enable_caching,
                           resource_group_name=resource_group_name,
                           profile_name=profile_name,
                           is_compression_enabled=is_compression_enabled,
                           query_string_caching_behavior=query_string_caching_behavior,
                           forwarding_protocol=forwarding_protocol)
    if action is not None:
        actions.append(action)

    rule = Rule(
        name=rule_name,
        order=order,
        conditions=conditions,
        actions=actions,
        match_processing_behavior=match_processing_behavior
    )

    return RuleCreate(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name,
        "rule": rule,
    })

from azure.cli.command_modules.cdn.aaz.latest.afd.rule import Create as _AFDRuleCreate
class AFDRuleCreate(_AFDRuleCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZStrArg, AAZDateArg, AAZBoolArg, AAZListArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.cache_behavior = AAZStrArg(options=['--cache-behavior'],
                                                  help="Caching behavior for the requests.")
        args_schema.cache_duration = AAZDateArg(options=['--cache-duration'],
                                                    help="The duration for which the content needs to be cached. Allowed format is [d.]hh:mm:ss.")
        args_schema.custom_fragment = AAZStrArg(options=['--custom-fragment'],
                                                  help="Fragment to add to the redirect URL.")
        args_schema.custom_hostname = AAZStrArg(options=['--custom-hostname'],
                                                    help="Host to redirect. Leave empty to use the incoming host as the destination host.")
        args_schema.custom_path = AAZStrArg(options=['--custom-path'],
                                                    help="The full path to redirect. Path cannot be empty and must start with /. Leave empty to use the incoming path as destination pat")
        args_schema.custom_query_string = AAZStrArg(options=['--custom-query-string'],
                                                    help="The set of query strings to be placed in the redirect URL. leave empty to preserve the incoming query string.")
        args_schema.destination = AAZStrArg(options=['--destination'],
                                                    help="The destination path to be used in the rewrite.")
        args_schema.enable_caching = AAZBoolArg(options=['--enable-caching'],
                                                    help="Indicates whether to enable caching on the route.")
        args_schema.enable_compression = AAZBoolArg(options=['--enable-compression'],
                                                    help="Indicates whether content compression is enabled on AzureFrontDoor. Default value is false. If compression is enabled, content will be served as compressed if user requests for a compressed version. Content won't be compressed on AzureFrontDoor when requested content is smaller than 1 byte or larger than 1 MB.")
        args_schema.forwarding_protocol = AAZStrArg(options=['--forwarding-protocol'],
                                                    help="Protocol this rule will use when forwarding traffic to backends.")
        args_schema.header_action = AAZStrArg(options=['--header-action'],
                                                    help="Header action for the requests.")
        args_schema.header_name = AAZStrArg(options=['--header-name'],
                                                    help="Name of the header to modify.")
        args_schema.header_value = AAZStrArg(options=['--header-value'],
                                                    help="Value of the header.")
        args_schema.match_values = AAZListArg(options=['--match-values'],
                                                    help="Match values of the match condition. e.g, space separated values \"GET\" \"HTTP\".")
        args_schema.match_values.Element = AAZStrArg()
        args_schema.match_variable = AAZStrArg(options=['--match-variable'],
                                                    help="Name of the match condition: https://docs.microsoft.com/en-us/azure/frontdoor/rules-match-conditions.")
        args_schema.negate_condition = AAZBoolArg(options=['--negate-condition'],
                                                    help="If true, negates the condition.")
        args_schema.operator = AAZStrArg(options=['--operator'],
                                                    help="Operator of the match condition.")
        args_schema.origin_group = AAZStrArg(options=['--origin-group'],
                                                    help="Name or ID of the OriginGroup that would override the default OriginGroup.")
        args_schema.preserve_unmatched_path = AAZBoolArg(options=['--preserve-unmatched-path'],
                                                    help="If True, the remaining path after the source pattern will be appended to the new destination path.")
        args_schema.query_parameters = AAZStrArg(options=['--query-parameters'],
                                                    help="Query parameters to include or exclude.")
        args_schema.query_string_caching_behavior = AAZStrArg(options=['--query-string-caching-behavior'],
                                                    help="Defines how CDN caches requests that include query strings. You can ignore any query strings when caching, bypass caching to prevent requests that contain query strings from being cached, or cache every request with a unique URL.")
        args_schema.redirect_protocol = AAZStrArg(options=['--redirect-protocol'],
                                                    help="Protocol to use for the redirect.")
        args_schema.redirect_type = AAZStrArg(options=['--redirect-type'],
                                                    help="The redirect type the rule will use when redirecting traffic.")
        args_schema.selector = AAZStrArg(options=['--selector'],
                                                    help="Selector of the match condition.")
        args_schema.source_pattern = AAZStrArg(options=['--source-pattern'],
                                                    help="A request URI pattern that identifies the type of requests that may be rewritten.")
        args_schema.transforms = AAZListArg(options=['--transforms'],
                                                    help="Transform to apply before matching.")
        args_schema.transforms.Element = AAZStrArg()
        return args_schema
    def pre_operations(self):
        args = self.ctx.args
        from azure.cli.core.aaz import AAZObjectArg
        # conditions
        condition = create_condition(args.match_variable, args.operator, args.match_values, args.selector, args.negate_condition, args.transforms)
        args.conditions.append(condition)
        
        # actions
        action = create_action(args.action_name, args.cache_behavior, args.cache_duration, args.header_action,
                               args.header_name, args.header_value, args.query_string_caching_behavior,
                               args.query_parameters, args.redirect_type, args.redirect_protocol, args.custom_hostname,
                               args.custom_path, args.custom_query_string, args.custom_fragment, args.source_pattern,
                               args.destination, args.preserve_unmatched_path, args.origin_group, 
                               cmd=self.cmd, resource_group_name=args.resource_group_name, profile_name=args.profile_name)
        args.actions.append(action)

def create_condition(match_variable, operator, match_values=None, selector=None, negate_condition=None, transforms=None):
    from azure.cli.core.aaz import AAZObjectArg
    condition = AAZObjectArg()
    if match_variable == 'RemoteAddress':
        condition.remote_address.parameters.match_values = match_values
        condition.remote_address.parameters.negate_condition = negate_condition
        condition.remote_address.parameters.operator = operator
        condition.remote_address.parameters.transforms = transforms
    if match_variable == 'RequestMethod':
        condition.request_method.parameters.match_values = match_values
        condition.request_method.parameters.negate_condition = negate_condition
        condition.request_method.parameters.operator = RequestMethodOperator.EQUAL
    if match_variable == 'QueryString':
        condition.query_string.parameters.match_values = match_values
        condition.query_string.parameters.negate_condition = negate_condition
        condition.query_string.parameters.operator = operator
        condition.query_string.parameters.transforms = transforms
    if match_variable == 'PostArgs':
        condition.post_args.parameters.match_values = match_values
        condition.post_args.parameters.negate_condition = negate_condition
        condition.post_args.parameters.operator = operator
        condition.post_args.parameters.transforms = transforms
        condition.post_args.parameters.selector = selector
    if match_variable == 'RequestHeader':
        condition.request_header.parameters.match_values = match_values
        condition.request_header.parameters.negate_condition = negate_condition
        condition.request_header.parameters.operator = operator
        condition.request_header.parameters.transforms = transforms
        condition.request_header.parameters.selector = selector
    if match_variable == 'RequestUri':
        condition.request_uri.parameters.match_values = match_values
        condition.request_uri.parameters.negate_condition = negate_condition
        condition.request_uri.parameters.operator = operator
        condition.request_uri.parameters.transforms = transforms
    if match_variable == 'RequestBody':
        condition.request_body.parameters.match_values = match_values
        condition.request_body.parameters.negate_condition = negate_condition
        condition.request_body.parameters.operator = operator
        condition.request_body.parameters.transforms = transforms
    if match_variable == 'RequestScheme':
        condition.request_scheme.parameters.match_values = match_values
        condition.request_scheme.parameters.negate_condition = negate_condition
        condition.request_scheme.parameters.operator = RequestMethodOperator.EQUAL
    if match_variable == 'UrlPath':
        condition.url_path.parameters.match_values = match_values
        condition.url_path.parameters.negate_condition = negate_condition
        condition.url_path.parameters.operator = operator
        condition.url_path.parameters.transforms = transforms
    if match_variable == 'UrlFileExtension':
        condition.url_file_extension.parameters.match_values = match_values
        condition.url_file_extension.parameters.negate_condition = negate_condition
        condition.url_file_extension.parameters.operator = operator
        condition.url_file_extension.parameters.transforms = transforms
    if match_variable == 'UrlFileName':
        condition.url_file_name.parameters.match_values = match_values
        condition.url_file_name.parameters.negate_condition = negate_condition
        condition.url_file_name.parameters.operator = operator
        condition.url_file_name.parameters.transforms = transforms
    if match_variable == 'HttpVersion':
        condition.http_version.parameters.match_values = match_values
        condition.http_version.parameters.negate_condition = negate_condition
        condition.http_version.parameters.operator = operator
        condition.http_version.parameters.transforms = transforms
    if match_variable == 'IsDevice':
        condition.is_device.parameters.match_values = match_values
        condition.is_device.parameters.negate_condition = negate_condition
        condition.is_device.parameters.operator = operator
        condition.is_device.parameters.transforms = transforms
    if match_variable == 'Cookies':
        condition.cookies.parameters.match_values = match_values
        condition.cookies.parameters.negate_condition = negate_condition
        condition.cookies.parameters.operator = operator
        condition.cookies.parameters.transforms = transforms
        condition.cookies.parameters.selector = selector
    if match_variable == 'SocketAddr':
        condition.socket_addr.parameters.match_values = match_values
        condition.socket_addr.parameters.negate_condition = negate_condition
        condition.socket_addr.parameters.operator = operator
        condition.socket_addr.parameters.transforms = transforms
    if match_variable == 'ClientPort':
        condition.client_port.parameters.match_values = match_values
        condition.client_port.parameters.negate_condition = negate_condition
        condition.client_port.parameters.operator = operator
        condition.client_port.parameters.transforms = transforms
    if match_variable == 'ServerPort':
        condition.server_port.parameters.match_values = match_values
        condition.server_port.parameters.negate_condition = negate_condition
        condition.server_port.parameters.operator = operator
        condition.server_port.parameters.transforms = transforms
    if match_variable == 'HostName':
        condition.host_name.parameters.match_values = match_values
        condition.host_name.parameters.negate_condition = negate_condition
        condition.host_name.parameters.operator = operator
        condition.host_name.parameters.transforms = transforms
    if match_variable == 'SslProtocol':
        condition.ssl_protocol.parameters.match_values = match_values
        condition.ssl_protocol.parameters.negate_condition = negate_condition
        condition.ssl_protocol.parameters.operator = operator
        condition.ssl_protocol.parameters.transforms = transforms
    return condition

def create_action(action_name, cache_behavior=None, cache_duration=None, header_action=None,
                  header_name=None, header_value=None, query_string_behavior=None, query_parameters=None,
                  redirect_type=None, redirect_protocol=None, custom_hostname=None, custom_path=None,
                  custom_query_string=None, custom_fragment=None, source_pattern=None, destination=None,
                  preserve_unmatched_path=None, cmd=None, resource_group_name=None, profile_name=None,
                  endpoint_name=None, origin_group=None, query_string_caching_behavior=None,
                  is_compression_enabled=None, enable_caching=None, forwarding_protocol=None):
    from azure.cli.core.aaz import AAZObjectArg
    action = AAZObjectArg()
    if action_name == "CacheExpiration":
        action.cache_expiration.parameters.cache_duration = cache_duration
        action.cache_expiration.parameters.cache_behavior = cache_behavior
        return action
    if action_name in ('RequestHeader', 'ModifyRequestHeader'):
        action.modify_request_header.parameters.header_action = header_action
        action.modify_request_header.parameters.header_name = header_name
        action.modify_request_header.parameters.value = header_value
        return action
    if action_name in ('ResponseHeader', 'ModifyResponseHeader'):
        action.modify_response_header.parameters.header_action = header_action
        action.modify_response_header.parameters.header_name = header_name
        action.modify_response_header.parameters.value = header_value
        return action
    if action_name == "CacheKeyQueryString":
        action.cache_key_query_string.parameters.query_string_behavior = query_string_behavior
        action.cache_key_query_string.parameters.query_parameters = query_parameters
        return action
    if action_name == "UrlRedirect":
        action.url_redirect.parameters.custom_host = custom_hostname
        action.url_redirect.parameters.custom_path = custom_path
        action.url_redirect.parameters.custom_query_string = custom_query_string
        action.url_redirect.parameters.custom_fragment = custom_fragment
        action.url_redirect.parameters.destination_protocol = redirect_protocol
        action.url_redirect.parameters.redirect_type = redirect_type
        return action
    if action_name == "UrlRewrite":
        action.url_rewrite.parameters.destination = destination
        action.url_rewrite.parameters.preserve_unmatched_path = preserve_unmatched_path
        action.url_rewrite.parameters.source_pattern = source_pattern
        return action
    if action_name == "OriginGroupOverride":
        if not is_valid_resource_id(origin_group):
            # Ideally we should use resource_id but Auzre FrontDoor portal extension has some case-sensitive issues
            # that prevent it from displaying correctly in portal.
            origin_group = f'/subscriptions/{get_subscription_id(cmd.cli_ctx)}/resourcegroups/{resource_group_name}' \
                           f'/providers/Microsoft.Cdn/profiles/{profile_name}/endpoints/{endpoint_name}' \
                           f'/origingroups/{origin_group.lower()}'
        action.origin_group_override.parameters.origin_group.id = origin_group
        return action
    if action_name == "RouteConfigurationOverride":
        if not is_valid_resource_id(origin_group):
            # Ideally we should use resource_id but Auzre FrontDoor portal extension has some case-sensitive issues
            # that prevent it from displaying correctly in portal.
            origin_group = f'/subscriptions/{get_subscription_id(cmd.cli_ctx)}/resourcegroups/{resource_group_name}' \
                           f'/providers/Microsoft.Cdn/profiles/{profile_name}/endpoints/{endpoint_name}' \
                           f'/origingroups/{origin_group.lower()}'
        action.route_configuration_override.parameters.cache_configuration.query_string_caching_behavior = query_string_caching_behavior
        action.route_configuration_override.parameters.cache_configuration.query_parameters = query_parameters
        action.route_configuration_override.parameters.cache_configuration.cache_behavior = cache_behavior
        action.route_configuration_override.parameters.cache_configuration.cache_duration = cache_duration
        action.route_configuration_override.parameters.cache_configuration.is_compression_enable = RuleIsCompressionEnabled.ENABLED.value if is_compression_enabled else RuleIsCompressionEnabled.DISABLED.value,
        action.route_configuration_override.parameters.origin_group_override.forwarding_protocol = forwarding_protocol
        action.route_configuration_override.parameters.origin_group_override.origin_group.id = origin_group
        return action if enable_caching else None
    return action

def add_afd_rule_condition(cmd, resource_group_name, profile_name, rule_set_name,
                           rule_name, match_variable, operator, match_values=None, selector=None,
                           negate_condition=None, transforms=None):
    existing_rule = RuleShow(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name
    })

    from .custom import create_condition

    condition = create_condition(match_variable, operator, match_values, selector, negate_condition, transforms)
    existing_rule["conditions"].append(condition)

    return RuleCreate(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name,
        "rule": existing_rule,
    })

def add_afd_rule_action(cmd, resource_group_name, profile_name, rule_set_name,
                        rule_name, action_name, cache_behavior=None, cache_duration=None,
                        header_action=None, header_name=None, header_value=None,
                        query_parameters=None, redirect_type=None, redirect_protocol=None, custom_hostname=None,
                        custom_path=None, custom_querystring=None, custom_fragment=None, source_pattern=None,
                        destination=None, preserve_unmatched_path=None, origin_group=None,
                        forwarding_protocol: ForwardingProtocol = None,
                        query_string_caching_behavior: AfdQueryStringCachingBehavior = None,
                        is_compression_enabled=None,
                        enable_caching=None):

    existing_rule = RuleShow(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name
    })

    from .custom import create_action
    action = create_action(action_name, cache_behavior, cache_duration, header_action, header_name,
                           header_value, None, None if query_parameters is None else ",".join(query_parameters),
                           redirect_type, redirect_protocol, custom_hostname, custom_path, custom_querystring,
                           custom_fragment, source_pattern, destination, preserve_unmatched_path,
                           cmd=cmd, resource_group_name=resource_group_name,
                           forwarding_protocol=forwarding_protocol,
                           origin_group=origin_group, profile_name=profile_name,
                           query_string_caching_behavior=query_string_caching_behavior,
                           is_compression_enabled=is_compression_enabled,
                           enable_caching=enable_caching)

    existing_rule["actions"].append(action)

    return RuleCreate(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name,
        "rule": existing_rule,
    })

def remove_afd_rule_condition(cmd, resource_group_name, profile_name,
                              rule_set_name, rule_name, index):

    existing_rule = RuleShow(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name
    })
    if len(existing_rule["conditions"]) > 1 and index < len(existing_rule["conditions"]):
        existing_rule["conditions"].pop(index)
    else:
        logger.warning("Invalid condition index found. This command will be skipped. Please check the rule.")

    return RuleCreate(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name,
        "rule": existing_rule,
    })


def remove_afd_rule_action(cmd, resource_group_name, profile_name, rule_set_name, rule_name, index):

    existing_rule = RuleShow(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name
    })
    if len(existing_rule["actions"]) > 1 and index < len(existing_rule["actions"]):
        existing_rule["actions"].pop(index)
    else:
        logger.warning("Invalid condition index found. This command will be skipped. Please check the rule.")

    return RuleCreate(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name,
        "rule": existing_rule,
    })


def list_afd_rule_condition(cmd, resource_group_name,
                            profile_name, rule_set_name,
                            rule_name):
    rule = RuleShow(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name
    })

    return rule["conditions"]


def list_afd_rule_action(cmd, resource_group_name,
                         profile_name, rule_set_name,
                         rule_name):
    rule = RuleShow(cli_ctx=cmd.cli_ctx)(command_args={
        "resource_group": resource_group_name,
        "profile_name": profile_name,
        "rule_set_name": rule_set_name,
        "rule_name": rule_name
    })
    
    return rule["actions"]

from azure.cli.command_modules.cdn.aaz.latest.afd.secret import Create as _AFDSecretCreate
class AFDSecretCreate(_AFDSecretCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZStrArg, AAZBoolArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.secret_source = AAZStrArg(options=['--secret-source'],
                                                  help="Resource ID of the Azure Key Vault certificate, expected format is like /subscriptions/sub1/resourceGroups/rg1/providers/Microsoft.KeyVault/vaults/vault1/secrets/cert1.",
                                                  required=True)
        args_schema.secret_version = AAZStrArg(options=['--secret-version'],
                                                  help="Version of the certificate to be used.",
                                                  required=False)
        args_schema.use_latest_version = AAZBoolArg(options=['--use-latest-version'],
                                                  help="Whether to use the latest version for the certificate.",
                                                  required=False)
        return args_schema
    def pre_operations(self):
        args = self.ctx.args
        args.parameters.customer_certificate.secret_source = args.secret_source
        if has_value(args.secret_version):
            args.parameters.customer_certificate.secret_version = args.secret_version
        if has_value(args.use_latest_version):
            args.parameters.customer_certificate.use_latest_version = args.use_latest_version
            
from azure.cli.command_modules.cdn.aaz.latest.afd.secret import Create as _AFDSecretCreate
class AFDSecretCreate(_AFDSecretCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZStrArg, AAZBoolArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.secret_source = AAZStrArg(options=['--secret-source'],
                                                  help="Resource ID of the Azure Key Vault certificate, expected format is like /subscriptions/sub1/resourceGroups/rg1/providers/Microsoft.KeyVault/vaults/vault1/secrets/cert1.",
                                                  required=True)
        args_schema.secret_version = AAZStrArg(options=['--secret-version'],
                                                  help="Version of the certificate to be used.",
                                                  required=False)
        args_schema.use_latest_version = AAZBoolArg(options=['--use-latest-version'],
                                                  help="Whether to use the latest version for the certificate.",
                                                  required=False)
        return args_schema
    def pre_operations(self):
        args = self.ctx.args
        args.parameters.customer_certificate.secret_source = args.secret_source
        if has_value(args.secret_version):
            args.parameters.customer_certificate.secret_version = args.secret_version
        if has_value(args.use_latest_version):
            args.parameters.customer_certificate.use_latest_version = args.use_latest_version

from azure.cli.command_modules.cdn.aaz.latest.afd.secret import Update as _AFDSecretUpdate
class AFDSecretUpdate(_AFDSecretUpdate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZStrArg, AAZBoolArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.secret_source = AAZStrArg(options=['--secret-source'],
                                                  help="Resource ID of the Azure Key Vault certificate, expected format is like /subscriptions/sub1/resourceGroups/rg1/providers/Microsoft.KeyVault/vaults/vault1/secrets/cert1.",
                                                  required=True)
        args_schema.secret_version = AAZStrArg(options=['--secret-version'],
                                                  help="Version of the certificate to be used.",
                                                  required=False)
        args_schema.use_latest_version = AAZBoolArg(options=['--use-latest-version'],
                                                  help="Whether to use the latest version for the certificate.",
                                                  required=False)
        return args_schema
    def pre_operations(self):
        args = self.ctx.args
        args.parameters.customer_certificate.secret_source = args.secret_source
        if has_value(args.secret_version):
            args.parameters.customer_certificate.secret_version = args.secret_version
        if has_value(args.use_latest_version):
            args.parameters.customer_certificate.use_latest_version = args.use_latest_version

from azure.cli.command_modules.cdn.aaz.latest.afd.security_policy import Create as _AFDSecurityPolicyCreate
from azure.cli.core.aaz.utils import assign_aaz_list_arg
class AFDSecurityPolicyCreate(_AFDSecurityPolicyCreate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZListArg, AAZStrArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.domains = AAZListArg(options=['--domains'],
                                                  help="The domains to associate with the WAF policy. Could either be the ID of an endpoint (default domain will be used in that case) or ID of a custom domain.",
                                                  required=True)
        args_schema.domains.Element = AAZStrArg()
        args_schema.waf_policy = AAZStrArg(options=['--waf-policy'],
                                                  help="The ID of Front Door WAF policy.",
                                                  required=True)
        return args_schema
    def pre_operations(self):
        args = self.ctx.args
        args.web_application_firewall.waf_policy = args.waf_policy
        args.web_application_firewall.associations[0].domains = assign_aaz_list_arg(
            args.web_application_firewall.associations[0].domains,
            args.domains,
            element_transformer=lambda _, domains_id: {"id": domains_id})
    
from azure.cli.command_modules.cdn.aaz.latest.afd.security_policy import Update as _AFDSecurityPolicyUpdate
class AFDSecurityPolicyUpdate(_AFDSecurityPolicyUpdate):
    @classmethod
    def _build_arguments_schema(cls, *args, **kwargs):
        from azure.cli.core.aaz import AAZListArg, AAZStrArg
        args_schema = super()._build_arguments_schema(*args, **kwargs)
        args_schema.domains = AAZListArg(options=['--domains'],
                                                  help="The domains to associate with the WAF policy. Could either be the ID of an endpoint (default domain will be used in that case) or ID of a custom domain.",
                                                  required=True)
        args_schema.domains.Element = AAZStrArg()
        
        args_schema.waf_policy = AAZStrArg(options=['--waf-policy'],
                                                  help="The ID of Front Door WAF policy.",
                                                  required=True)
        return args_schema
    def pre_operations(self):
        args = self.ctx.args
        args.web_application_firewall.waf_policy = args.waf_policy
        args.web_application_firewall.associations[0].domains = assign_aaz_list_arg(
            args.web_application_firewall.associations[0].domains,
            args.domains,
            element_transformer=lambda _, domains_id: {"id": domains_id})